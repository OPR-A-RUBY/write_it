1234567890123456789012345678901234567890123456789012345678901234567890123456789012345
         1         2         3         4         5         6         7         8  
Lesson_02 ---------------------------------------------------------------------------

ОПЕРАТОР puts.

	puts "Hello"

	puts - это put string (положить строку)


ЗАПУСК ПРОГРАММЫ. 
	В терминале, в папке с программой набираем
	следующую команду: 
	# ruby app1.rb
	(где app1.rb - это сама программа на Ruby)


СООБЩЕНИЕ ОБ ОШИБКЕ.
	Может появиться в терминале, следующего вида:
	app1.rb:3:in `main': undefined local variable or method `....
	Это говорит, что на третьей строке встретился оператор 	или перемнная, 
	которую Ruby не может обработать.


СОЗДАНИЕ КОМЕНТАРИЯ.

	Для создания коментария используется знак # 
	Всё, что после этого знака - это коментарий 
	Новая строка уже не будет кометарием.


ОПEРАТОР gets

	gets - написанный в конце программы остановливает программу и ждут ввода данных 
		   с клавиатуры (или просто Enter)
	

ОПЕРАТОР print
	
	опрератор print не переводит строку, в отличии от puts
	
	Удобнее использовать оба оператора:
	print "Enter your name: "
	my_name = gets
	puts "Hello " + my_name	
	
	
СПЕЦИАЛЬНЫЕ СИМВОЛЫ.

	\n - (new line) - новая линия
	
	
МЕТОД .chomp

	my_name = gets 		- здесь Имя и Enter
	my_name = gets.chomp	- здесь Имя (а Enter - удалился)
	(см.пример: app6.rb)
	
	Этот метод удаляет только символы переноса в конце строки.
	Второй раз применять данный метод не имеет смысла т.к. символов переноса строки 
	уже не бeдет.


End of Lesson_02
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_03

irb - 
	Выход из него по команде exit или quit 
	Ctrl + C - прерывает выполнение irb при зависании или зацикливании.
	Если запустить irb в терминале, то можно попробовать как работает та, 
	или другая команда.

	В этой оболочке:
	> + 2 * 2 
	=> 6

	> puts 2 + 2 * 2
	6
	=> nil
 
	здесь nil - это нулевой объект.

	Чтобы определить тип данных нудно в irb сделать:
	> 1.class
	=> Fixnum

	> "asdasdasd".class
	=> String

	> 2.14.class
	=> Float


ТИПЫ
	String	"aa" "2"
	Fixnum	2 22 100000 2^30
	Bignum	2^30+1 ... и более
	Fload   3.14 29.5
	Array	[...]
	Hash	{...}
	
	Fixnum + Bignum = Integer

	
МЕТОД .to_i 

	to Integer
	Преобразование к целому числу, обычно используется к тексту, что бы результат 
	был пригоден для вычислений.
	(см.пример: app7.rb)
	
	> 'gdhjkduhekufh'.to_i 	# => 0


МЕТОД .to_f 

	to Float
	Преобразование к типу с плавающей точкой.
	(см.пример: app8.rb)

	
МЕТОД .to_s 

	to String
	Преобразование к типу строка 	


End of Lesson_03
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_04


	Существует множество вариантов написания кода, например:
 
	x = gets 	# если ожидаем строку (или символ)
	y = gets	# если ожидаем целое число
	z = gets	# если ожидаем вещественное число

	x = x.chomp
	y = y.to_i
	z = z.to_f

	... аналогичное решение можно записать следующий вариант:

	x = gets.chomp
	y = gets.to_i
	z = gets.to_f


ИНТЕРПОЛЯЦИЯ СТРОК.

	Применяется для вывода строки на экран, позволяя не задумываться о типе выводимой
	перемнной. Выглядит это так  "#{ ... }"

	В программе будет выглядеть так:

	x = 5
	puts "x = #{x}"

	На экран будет выведено: х = 5


КОДИРОВКА ЛИСТИНГА.

	Ruby по-умолчанию использует кодировка UTF-8
	Но под Windows использование русского шрифта в RUBY приводит к различным ошибкам.
	В Linux и Mac таких проблем нет. 
	
	Чтобы в Windows переключить ruby на русский шрифт нужно вначале файла написать 
	такую строку:

	# encoding: cp866

	cp - это 'code page' - кодовая страница
	866 - это номер кодовой страницы, используемой в консоли Windows
		  по-умолчанию в рускоязычной версии Windows.
		  
	Все символы этой специальной строки должны быть записаны в Ваш файл.


МЕТОД .chomp

	Есть ещё один способ обрезать символ переноса курсора на новую строку \n  
	Он заключается в следующем. Раньше мы писали так:
	
	str = str.chomp

	а можно писать короче и понятнее:
	
	str.chomp!

	здесь ! указывает, что действи выполняется над самой переменной.
	Так запись выглядит нагляднее и короче.
	

МЕТОД .methods

	Выводит список всех операций, которые мы можем сделать с данной пременной 
	(объектом). Этот список разный для разных переменных и типов.
	Это очень полезно, если Вы хотите вспомнить какой-то метод, но не 
	помните как он пишется. Например метод .size
	
	Запоминать их все не нужно. О них можно прочитать в документации по адресу: 
	WEB http://www.ruby-doc.org/core-2.1.1/String.html	
	
МЕТОД . size
	
	Выводит длину данной переменной. Для разных переменных будут получены разные 
	значения.
	
	x = "aaabbb555"
	puts x.size

	выведет длину данной строковой переменной, т.е. 9

	то же в irb
	
	> x = "aaabbb"
	"aaabbb"

	> y.size
	6

	
МЕТОД .empty?

	Вывводит результат проверки на пустоту. Знак ? говорит, что здесь возможно только
	два варианта резкльтата:
								true - Истина
								fals - Ложь
	
	y = ""
	puts y.emty?

	напишет true - Верно.
	
	то же в irb

	> y = ""
	nil

	> y.empty?
	true

WEB http://www.ruby-doc.org/core-2.1.1/String.html
	адрес, где можно прочитать документацию по String
	
!!! Очень хорошо, если брать пример из этой документации и попробоватm выполнить эти 
	примеры в irb. Можно поменять что-то в этих примерах и посмотреть как работают 
	методы для String перемнной.
	

МЕТОД * integer
	метод позволяет повторить строку "ааа" заданное количество раз. 
	Типа "ааа" * 3 получиться "ааааааааа" т.е. три раза "ааа".
	
	Обратная запись типа 3 * "ааа" - это работать не будет, т.к. операция * 
	применяется к String и затем должен быть Integer
	
	Overloading - перегрузка 	

	
WEB http://www.ruby-doc.org/core-2.1.1/Integer.html	
	адрес, где можно прочитать документацию по Intager

	
МЕТОД .even? 
	
	Возвращает true если число чётное.

	
МЕТОД .odd?

	Обратный метод, методу .even? 

	
МЕТОД .next

	метод возвращает следующее число, например 50.next выводит 51


МЕТОД .pred

	метод возвращает предыдущее число, например 50.pred выводит 49


WEB https://www.kickstarter.com/ 
	Ресурс для сбора денег на новый проект. Вы описываете свою идею, а люди со всего 
	мира собирают сумму для его реализации. Если, конечно, вы их убедили своими 
	аргументами!	


МЕТОД .times
	
	метод повторяет указанное число раз блок, который указан в фигурных скобках, 
	есть два способа использовать его (с параметром или без)
	
	ПЕРВЫЙ ВАРИАНТ - (без параметра)
	формат записи 10.times { puts "Hello" }
 	пример работы этого метода можно посмотреть в irb
 	этот пример выведет на экран 10 раз слово "Hello"
 	
 	s = "aaa-s"
	n = 5
	n.times { print s }	
	
	"aaa-saaa-saaa-saaa-saaa-s"
	
	ВТОРОЙ ВАРИАНТ - (с параметром)
	использования ментода .times (с параметром)
	формат записи 10.times { |i| puts i.to_s }
	пример нужно попробовать в irb
	этот пример выведет на экрае числа от 0 до 9 (включ)
	всего 10 чисел, всегда начинается с 0 (zero)
	
	> 100.times { |i| puts "i = #{i} " }
	
	i = 0
	i = 1
	...
	i = 99
	
	Вертикальные строки - это труба (pip), в которой пишется переменная параметра для
	данного блока { ... } 
	
	За пределами данного блока параметр i уже не существует.
	Он живёт только внутри этого блока.
	
	> 51.times { |i| puts "i = #{i}, even: #{i.even?} " }
	выводит:
	i = 0, even: true
	i = 1, even: false
	i = 2, even: true
	...
	i = 50, even: true
	
End of Lesson_04
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_05	
	
МЕТОД .upto  

	Метод "вверх до" перебирает числа от 5 до 15 ВВЕРХ (возрастание)
	В варианте 10.times выводит от 0 до 9 (всегда от 0)
	
	> 5.upto(15) { |x| puts x }
	выводит:
	5
	6
	....
	14
	15
	
!!! В программировании обычно принято использовать: 
	i и j - для обозначения итератора (повторителя) или индекс. 
	n и m - как натуральное число.
	
МЕТОД .downto

	Метод "вниз до" перебирает числа от 15 до 5 ВНИЗ (убывание)
	Например:
	
	> 15.downto(5) { |x| puts x }
	выводит:
	15
	14
	13
	...
	6
	5
	
	
МЕТОД .capitalize

	Метод делает большой первую букву и делает маленькими все остальные.
	
	
ТРАНС: workaround - существует метод обход этой проблеммы.		

	
МЕТОД .strip
	
	метод обрезает все пробелы, табуряция, конец строки и ... 
	всё это есть = whitespase (белое пространство)
			

СИМВОЛЫ СПЕЦИАЛЬНЫЕ

	\n	# На новую строку (new)  
	\t	# Табуляция (tab) e.g.: > pust "\tВася"
	\r	# Перевод коретки в начало текущей строки (return) 
	\\	# Выод на экран символа \
	Эти симыолы работают только в " ", и не работают с ' '.
	
	\n - Line feed (LF)
	\r - Carriage Return (CR)
	
	Часто пишется \r\n  или  cr lf
	
	С помощью \n символа можно вывести две строки одной командой:
	> puts "Line-1 \nLine-2" 
	
	Чтобы вывести сам этот спец символ нужно использовать двойной:
	> puts "\\n" # => \n
	> puts "\\r" # => \r

	
End of Lesson_05
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_06		

МЕТОД .sleep 1

	Ждёт 1 секунду. 
	> sleep 0.05
	
		
БЛОКИ - бывают разные:
	
	1. Бок фигурные скобки { .. }
	Используется если пишется один оператор и в одну строку.
	10.times { puts 'aa' }
	10.times { |i| puts i }
	
	2. Блок do .. end 
	Используется если нужно написать несколько операторов.
	10.times do
	  puts ...
	  print ...
	  gets ...
	end
	
	10.times do |i|
	  puts i
	end    
	
	БЛОКИ МОЖНО ВКЛАДЫВАТЬ ДРУЗ В ДРУГА
	10.times do |i|
		print "Hello"
		
		x.times do
			print "!"
		end
		
		puts
	end
	
	Или то же самое сильно короче но (менее понятно):
	
	10.times { |i| puts "Helo#{'!'*i}" }
	
	(1..10).each { |x| puts x }	

МЕТОД rand(5)

	rand 5 Выдаёт целые числа 0,1,2,3,4	
	rand 1000 выдаёт целые числа от 0 до 999
	rand (10..20) выдаёт целые числа от 9 до 19
	rand (11..21) выдаёт целые числа от 10 до 20
	rand (0.03..0.09) выдаёт действительные числа из диапазона
	
	
End of Lesson_06
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_07

!!! Переменная, объявленная внутри блока (в пайпах) будет действовать только внутри 
	своего блока. После выхода из блока она уничтожается.
	
!!! Sublime Text 3

	Изменение переменной среды:
	<Win> + <Print Screen>	- 
	или
	Мой комп 
		- Свойства 
			- Изменить параметры 
				- Перемнные среды 
					- PATH 
						- Изменить
						и вводим в поле
	PATH = 'c:\tools\sublime3'
	Note: если там уже что-то есть, то ставим ; и пишем наш путь
	
	Пкреименовали 'sublime.exe' to 's.exe'
	Теперь для открытия достаточно набрать 's app2.rb' и наш файл откроется в новом 
	редакторе SubLime.

ОПЕРАТОРЫ СРАВНЕНИЯ

	== - равно
	!= - НЕ равно
	<= - меньше или равно
	>= - больше или равно
	<	- меньше
	>	- больше
	=== - строгое сравнение
	
METHOD if - (Если)	

	if a == 4
		puts a
	end
	
	if а == 4
		puts 4
	else
		puts '-'
	end			

	if a == 4
		puts 4
	elsif f == 5
		puts 5
	elsif a == 7
		puts 7
	else
		puts '-'
	end				

	if a == 4 && b == 8		# Если (первое условие) и (второе условие) 
		puts a*b
	end	

	if a == 4 || b == 8		# Если (первое условие) или (второе условие) 
		puts 'Ok'
	end

METHOD exit - (выход)

	Этот метод останавливает выполнение программы.
	
		
!!! Программу пишут не для того чтобы компьютер её лучше понимал, а для того, 
	чтобы програмист эту программу легко мог читать, и конечно поняв её смог вносить 
	в неё изменения.


End of Lesson_07
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_08

	x = 1_000_000_000
	y = 43_568.67


!!! Эффективность программиста = 15 строк в день. Очень часто ты что-то пишешь, 
	потом что-то удаляешь, потом ещё что-то пишешь, опять удаляешь, тестируешь, 
	исправляешь, удаляешь и добавляешь и в итоге программист в среднем пишет 
	15 строк в день.	
	
	
КАЛЬКУЛЯТОР

	print 'Enter A: '
	a = gets.to_f
	
	print 'Enter B: '
	b = gets.to_f
	
	print 'Enter Your action ( + - * / ): '
	op = gets.strip
	
	if op == '/' && b ==0
		puts "It's Error. Divisy by zero!"
	end	

	if op == '+' 
		rezult = a + b
	
	elsif op == '-'
		rezult = a - b
	
	elsif op == '*'		
		rezult = a * b
		
	elsif op == '/'
		rezult = a / b
	
	else
		puts 'Bad action'
		exit
	end

	puts "#{a} #{op} #{b} = #{rezult}"

	
METHOD breack

	Позволяет выйти из текущего блока.
	
	if  a == 4
		puts
		print
		
		breack # Выйти из if-блока
		
		puts # не выполнится 

	end
	puts # Сюда переходит управление после breack
	
	
METHOD while 

	while a == b 
		puts
		puts
	end	
	
	Пока условие a == b есть true  блок будет выполнятся постоянно.
	Как только это условие станет false то программа выйдет из блока.


METHOD .reverse

	перевернуть строку (в обратном порядке)
	

METHOD .each - (каждый)
	
	Перебирать каждый элемент
	
	
RANGES

	(1..10).each { |x| puts x }
	1..5 	1 2 3 4 5
	1...5	1 2 3 4	
	
	('a'..'s').each { |x| puts x }
	('aa'..'bs').each { |x| puts x }

	('10a'..'20s').each { |x| puts x }


!!! Ruby Shoes - GUI framework - для написания программ с графической оболочкой. 
	Искать лучше на stackoverflow.com 
	
	Запрос: ruby linux gui frameworck site:ctackoverflow.com
	
	shoesrb.com
		
End of Lesson_08
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_09

- ЛЯМБДА ВЫРАЖЕНИЯ или ДЕЛЕГАТЫ

	Это указатель на функцию. 
	
	
- ХЕШ - это структура данных.	


ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ

	@bbb - глобальная переменная, т.е. она будет доступна везде, и в основной 
	программе, и в процедурах, и в функциях ...
		   

ФУНКЦМЯ - МЕТОД - ПРОЦЕДУРА - ПОДПРОГРАММА - это всё одно и то же.

	Как ОПРЕДЕЛИТЬ метод?
	
	def get_password
	end
		
	# def - это define - (определить)
	# Процедуры пишутся для многократных запусков Reuseble.
	
	e.g.:
	
	def get_password
		print "Type password: " # Введите пароль
		return gets.chomp
	end
	
	xx = get_password
	
	puts "Был введён пароль: #{xx}"	
	
	# по оператору return возвращается значение из этого метода и прерывание 
	# выполнения процедуры (возврат).
	# по-умолчанию Ruby возвращает результат последнего выражения т.е. в нашей 
	# процедуре можно удалить слово return получится вот так: 
	 
	def get_password
		print "Type password: " # Введите пароль
		gets.chomp
	end
	# чаще всего return не пишут (опускают)
	# return - говорит: что нужно вернуть из функции.
	
	# в качестве последнего выражения может быть использовано:
	2 * 2
	gets.chomp * 3
	
	# В процедуру можно передать параметры
	# Параметр пишется после имени процедуры
	# Значение этого параметра указывается в строке вызова процедуры
	
	def print_greting name
		puts "Hello, #{name}"
	end
	
	print_greting "Roman"
	 
	# Внутри метода все переменные определяются заново, т.е. они не связаны с 
	# переменными в основной программе. 
	#                                    (кроме переменных переданых как параметр)
	
	# Другой способ передать перемнную в процедуру - это определить переменную как 
	# глобальную. У глобальной перемнной вначале есть специальный символ @
	

ОБЪЕКТЫ = ЭКЗЕМПЛЯРЫ КЛАССА = instance - (экземпляр)	   	
	
	HEAP MEMORY - (куча памяти)


SYMBOL
	
	1000.times
		"aaa"
	end	
	
	# Программа создаст 1000 "aaa" в памяти, и это займёт 1000 мест  
	# (когда программа закончится, то эта память освободится)
	#
	# Однако:
	# Если создать symbol то он займёт всего одно место в памяти.	 
	
	1000.times
		:aaa
	end	
	
	# symbol - используется для ускорения и оптимизации.
	# это очень обосновано, если используются повторения ...
	# при повторении не используется новые места в памяти.
	
	С символами можно работать как с обычными строками-константами
	a = :abba
	b = :music
	puts a
	
	> 'aaa'.object_id 	# => 288293290
	> 'aaa'.object_id 	# => 288390023
	# одна строка - два разных объекта
	
	> :aaa.object_id 	# => 703688
	> :aaa.object_id 	# => 703688
	# один символ - один объект
 
 	
METHOD .equal?

	Сравнивает объекты.
	> "aaa".equal? "aaa" 	# false
	> :aaa.equal? :aaa 		# true	
	
	
МАССИВ - Array - набор объектов	(Начало)
	
	http://www.ruby-doc.org/core-3.  /Array.html
	Массивы - гомиаморфны (числа + строки + ...)
	14, 22, 31, 5, "Вася", 44, 88, 
	
	определяем массив следующей командой:
	arr = []			 - пустой массив	
	arr = [14, 22, 31]   - три элемента в массиве
	
	e.g.:
	arr = [1, 22, 38]
	puts arr
	arr << 17		# добавление элемента в массив
	arr << 'food'	# ещё добавим элемент
	puts arr
	puts arr.size	# размер = 5 элементов
	
	
METHOD .uniq

	Отобрать уникальные (исключить повторение значений)
	
	
End of Lesson_09
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_10

МАССИВ - Array - набор объектов	(продолжение)
	
	Способы инициализации массива
	
	arr = []
	arr = ["Roma", 32]
	arr << "Mike"
	arr = %w[Roman 32 Mike]
	arr = [:left, :right, ...]
	arr = Array.new
	
	Элементы в массиве имеют индекс. Индекс начинается с 0
	
	Получить доступ к конкретному элементу массива можно получить через
	его индекс (полядковый номер в массиве).
	
	a = arr[0] 	   # возвращает первый элемент массива
	b = arr[-1]    # возвращает последний элемент массива
	c = arr[-2]    # возвращает второй элемент с конца массива
	d = arr[1..3]  # возвращает 2,3,4 элементы
	e = arr[1...3] # возвращает 2,3 элементы
	
	Между следующими далее двумя способами задания массива есть разница
	arr = ["bot", "tom", "cat", 22]
	arr = %w[bot tom cat 22]
	элемент 22 во втором случае - есть строка "22", а не число. 
	
	# Способ вывода элементов через блок (позволит обработать элементы)
	arr = ["bot", "tom", "cat", 22]
	x = 0
	arr.each do |item|
		puts "#{x} #{item}"
		x = x + 1
	end
	
	# .each - это каждый	
	
	arr = ["bot", "tom", "cat", 22]
	puts arr[1..3][0]
	#
	# ["tom", "cat", 22] - получили новый массив [1..3]
	# ["tom"]			 - получение новый массив [0]
	# 
	
	# Удаление элементов в массиве
	# item   0      1      2     3    
	arr = ["bot", "tom", "cat", 22]
	arr.delete_at 0  # удалится "bot"
	arr.delete 22    # удалится 22
	
	# Многомерный массив
	#
	arr = ["bot", "tom", "cat", 22]
	arr1 << arr
	arr = ["boy", "man", "boss"]
	arr1 << arr
	#
	# [["bot", "tom", "cat",   22], ["boy", "man", "boss"]]
	#                                     				
	#   |_0_|, |_1_|, |_2_|, |_3_|	 |_0_|, |_1_|, |__2__|   - 2 level
	#
	#  |_____________0___________|, |_________1__________|   - 1 level	
	#

	# ПРОГРАММА "Имя - Возраст"
	#
	arr = []

	loop do

		arr0 = []
		
		print "Введите имя: "
		name = gets.strip
		
		break if name == ""
		
		print "Введите возраст: "
		age = gets.strip
		
		arr0 << name
		arr0 << age
		
		arr << arr0
		
	end

	x=0

	arr.each do |item|
		x = x + 1
		puts "#{x} #{item[0]} #{item[1]}"
	end
	#
	# конец программы "Имя - Возраст"

METHOD .each_with_index

	перебирает элементы массива используя его элемент и его индекс

	Из 11 урока:
	
	arr = ["bot", "tom", "cat", 22]
	
	arr.each_with_index do |item, i|
		puts "#{i+1} - #{item}"
	end
	

End of Lesson_10
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_11

СОБЕСЕДОВАНИЕ

	Есть a=50 b=20 поменять значение перемнных    (без использования третьей)
											
	В Ruby есть такой синтаксис a, b = b, a
	- это для любых объектов
	
	или
	
	a = a + b
	b = a - b
	a = a - b
	- это для действительных чисел и целых в том числе


METHOD break 

	Метод позволяет выйти из цикла.
	
	loop do
		...
		break if a == 5 
		...
	end


ХЕШИ - Hash - Key value storage - (Ключ-значение Хранилище)

	Структура данных. Чэш это не фишка Ruby. 
	Ещё называют как: 
		Dictionary или 
		Hashtable или
		Ассоциаливные массивы
		NOSQL - No only SQL

	Хэш определяется следующим образом:

	hh = {}    - это хеш
	arr = []   - это массив
	
	Как ввести данные в Хэш:
	
	hh = {'Mike' => '35373', 'Jessie' => '31380'}
	#      key       value     key        value

	hh = {:left => 1234567}
	#      key      value
	
	=> - hash rocket - (хеш-ракета)

	Хеши часто используются как параметры:
	options = {:font_size => 10, :font_family => 'Arial', arr => [1,2]}

	Чтобы получить какое-либо значение из хэша нужно указать ключ:
	#
	x = options[:font_size]  
	puts x 						# = 10
	
	Как добавить значение в хеш? 
	#
	hh [ key ] = value
	#
	hh[:Mike] = '353747'
	#
	hh['boss'] = 'Sergey Evstifeev'
	hh['boss_phome'] = 9278154329
	hh[aaa] = bbb
	
	     !!! ключ в хэше должен быть уникальным. !!!	
	
	Для перебора хэша в целях обработки или вывода на экран
	#
	hh.each do |key, value|
		puts "#{key} - #{value}"
	end	
	# в хеше нет гарантии, что элементы будут выведены по порядку.


End of Lesson_11
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_12

ХЕШИ - Hash - Key value storage - (продолжение)

	Тип  key  в хэше - может быть любым
	Тип value в хэше - может быть любым	
	
	k = hh.keys		# массив ключей
	v = hh.value	# массив значений

	hh.each do |key, value|
		...
	end
		
	# Можно пройтись по всем ключам или по всем зачениям:
	hh.each_key do |key|		# - перебираем ключи
		...
	end
			
	hh.each_value do |value|	# - перебираем значения
		...
	end

METHOD .has_key?
		
	Чтобы проверить, есть ли такой КЛЮЧ в хэше:
	hh = {'cat' => 'кошка'}
	hh.has_key? 'cat'  # => true / false
			
	# используется в условиях.
	if hh.has_key? 'cat'				# результат = bolean
		puts 'В словаре есть кошка'
	end
	
	if hh['cat'] 						# результат = bolean
		puts 'В словаре есть кошка !!'
	end 
	
	puts 'никогда не сработает' if nil 	
	# nil преобразуется в false
	
	
METHOD .has_value?

	Чтобы проверить, есть ли такое ЗНАЧЕНИЕ в хэше:
	hh = {'cat' => 'кошка'}
	hh.has_value? 'cat'  # => true / false

	
ФУНКЦМЯ - МЕТОД - ПРОЦЕДУРА - ПОДПРОГРАММА - (продолжение)
	
	# В процедуру передаются параметры используюя хэш:
	#
	def print_details details
		puts details[:name] if details[:name]
		puts details[:age] if details[:age]
		puts details[:address] if details[:address]
	end
	
	hh = {:name => 'Mike', :age => '42', :address => '123 West Street'}	
	
	print_details hh
	# 
	# Здесь теперь, если даже в хэше будут указаны не все парамертры, то не возникнет
	# ошибки, т.к. в процедуре обработка происходит по условию существования данных в
	# хэше.
	

End of Lesson_12
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_13

ПЕТЛИ - ЦИКЛЫ и выходы из них

	# Петля (бесконечный цикл) и выход по условию
	loop do
		...
		break if ...
		...
	end
	
	# Петля (бесконечный цикл) и выход по условию
	while true
		...
		break if ...
		...
	end
	
	# Процедура и нестандартный возврат по return с результатом ...1
	def name
		...
		return ...1
		...
	end
	
	# Завершение выполнения программы. Из любой точки.
	exit
	#
	
СОЗДАНИЕ ХЭШЕЙ и МАССИВОВ              (в тетрадь)

	hh = {}		или hh = Hash.new
	
	arr = []	или arr = Array.new
	
	# Способы наполнения массива:
		arr = ["bot", "tom", "cat", 22]
		arr << 'bag'
		
	
	# Способы наполнения хэша:
		hh['Mike'] = 65
		hh['Jessie'] = 25
	# или
		hh = {'Mike' => 65, 'Jessie' => 25}
	#
	
ВЫВОД ХЭШЕЙ

	puts hh
	#
	puts hh.inspect
	#
	hh.each do |k, v|
		puts "#{k} - #{v}"
	end

	# Вывод ключей хеша
	puts hh.keys
	puts hh.keys.inspect

	# Вывод значений хеша
	puts hh.values
	puts hh.values.inspect

	# работа с ключами, через ключи
	hh.keys.each do |key|
		value = hh[key]
	end	
	
	# работа со значениями 
	hh.value.each do |value|
		...
	end

ОЧИСТКА ХЭША

	hh.clear
	
ПРОВЕРКА НА НАЛИЧИЕ ключа В ХЭШЕ	

	# 
	if hh.has_key? 'Mike'
		puts hh['Mike']
	end
	
	# то же, но более короткий синтаксис
	if hh.key? 'Mike'			# сокращённый синтаксис
		puts hh['Mike']
	end		

	# ещё способ проверить наличие ключа
	if hh['Mike']
		...
	end
	
	# самый короткий способ проверить наличие записи с ключём в хэше
	... if hh['Mike']


ПРОВЕРКА НА НАЛИЧИЕ значения В ХЭШЕ	

	# 
	if hh.has_value? '64'
		...
	end
	
	# то же, но более короткий синтаксис
	if hh.value? 65				# сокращённый синтаксис
		...
	end		


УДАЛЕНИЕ ЗАПИСИ из ХЭША

	# Удалить их хэша можно только целитком всю пару.
	# отдельно key или value не получится, можно только заменить 
	# она так и называется: key-value pair
	# 
	hh.delete 'Mike'


ОПРЕДЕЛЕНИЕ ПРОЦЕДУРЫ

	# app18.rb - листинг программы для запуска
	@hh = {}
	def add_person name, age
	# добавляет пару в хэш
		puts 'Already exsist!' if @hh[name]
		@hh[name] = age
	end
	
	def show_hash 
	# выводит полностью весь хэш
		@hh.each do |key, value|
			puts "#{key} - #{value}"
		end
	end
	
	loop do
	# 
		print 'Enter name: '
		name = gets.chomp.capitalize
		
		break if name = ''
		
		print 'Enter age: '
		age = gets.to_i
		
		add_person name, age
		
		show_hash 
		
	end 	

!!! Если всё плохо получается, то это значит, что есть прогресс.
	Если всё быстро получается, значит это слишкои просто для Вас и значит 
	нет прогресса.

ПЕРЕДАТЬ ПАРАМЕТВЫ В ПРОЦЕДУРУ. с помощью ХЭША!
	
!!!	Передавать параметры в процедуру удобнее с помощью хэша, 
	в котором количество параметров может быть разным,
	т.е. можно будет "опустить" часть параметров.
	
	При этом, во время обработки этих входных параметров внутри процедуры нужно будет
	проверять наличие каждого конкретного параметра.
	
	Выигрыш в том, что при вызове процедуры указывается только имя хэша options 
	например, а в него заводятся те, параметры, которы нужны для обработки.
	
	Теперь уже не так важен порядок передаваемых данных.
	Это создаёт дополнительную гибкость.
	
	# В данной  ситуации в качестве ключей нужно использовать символы	Например, 
	# формируем данные в хэш для передачи их в процедуру:
	hash_opt = { :name => 'Igor', :age => 45, :phone => '234-654-45-90'}
	
	# вызываем процедуру:
	save_person hash_opt
		
	# процедура будет выглядеть следующим образом:
	def save_person options
		@hh_phone[options[:name]] = options[:phone] if options[:phone]
		@hh_age[options[:name]] = options[:age] if options[:age]
	end
	 
	предыдуший пример программы в файле app18.rb  был переработан и
	пример использования смотри в файле app18+.rb

	# сформировать хэш можно и непосредственно при вызове процедуры:
	save_person ({:name=> 'Igor', :age=> 45, :phone=> '234-654-45-90'})
	# здесь дополнительные круглые скобки - обязательны!
	
	# или ещё
	save_person :name => 'Igor', :age => 45, :phone=> '234-654-45-90'
	# порядок параметров - не важен.  Важно только значение символов.
	# в качестве параметра может быть переменная :name => k
	
	Если передаются переменные и хэш, то хеш всегда ставится в конец 
	списка передаваемых параметров.
	
	
METHOD .merge

	# смотри её в файле: app19.rb
	def show_book book
		# выводит на экран записную книгу
		puts '='*12
		book.keys.each do |key|
			age = book[key]
			puts "Name: #{key}, age: #{age}"
		end
		puts '='*12
	end
	
	book1 = { 'Mike' => 45, 'Gus' => 36, 'Linda' => 48}
	show_book book1
	
	book2 = { 'Walt' => 50, 'Jessie' => 25 }
	show_book book2
	
	для того, чтобы объединить два ХЭША используется метод .merge
	book3 = book1.merge book2
	
	или наоборот, что то же самое:
	book3 = book2.merge book1
	
	После объединения появился НОВЫЙ ХЭШ, 
	исходные хэши остались без изменения, но
	если написать: 
	book1.merge! book2 		# book2 добавится к book1
	
	book2.merge! book1 		# book1 добавится к book2
	
ПЕРЕНАПРАВЛЕНИЕ ВЫВОДА в файл     (в тетрадь)
	
	ruby app1.rb > file.txt		# переписать файл
	ruby app1.rb >> file.txt	# дописать в файл
	
	Никто не спросит разрешения для перезаписи файла. 
	Нужно быть очень внимательным с этими операциями.
	
	Перенаправить файл можно и в file.html
	ruby app1.rb > file.html
	
	
HTML - формат					(в тетрадь)

	<body>			- указывает на начало html кода
	... (html-код)
	</body>			- указывает на конец html кода
		
	<br/>  			- переводит на новую строку.
	
	<b> ... </b>  	- bold (жирный)
	
	<i> ... </i>	- зона курсив 
	
	heading - заголовки в текстах:
	
	<h1> ... </h1> - самый КРУПНЫЙ шрифт заголовка
	<h2> ... </h2>
	<h3> ... </h3>
	<h4> ... </h4>
	<h5> ... </h5> - самый мелкий шрифт заголовка
	
	/
	
			
End of Lesson_13
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_14

ООП - Объектно ориентированной программирование.

	КЛАСС - это чертёж какой-то детали 
		  - это шаблон или pattern
	
	ОБЪЕКТ - это как раз эта деталь 
		   - экземпляр класса - 'class instance'
		   - детаей можно сделать сколько угодно, а чертёж ОДИН 

СОЗДАНИЕ КЛАССА

	class Animal		# Создаём шаблон (Класс)
		def run
			@name  = 'Dog'
			puts 'Уже бегу ...'
		end
		...
	end

	aa = Animal.new 	# Создаём новый объект - животное aa
	aa.run

	x = Animal.new		# Другое животное x
	x.run
	
	Переменная @name (см. выше) - будет доступна во всём классе, т.к. она глобальная 
	(со знаком @), но Если переменная будет без этого знака, то она будет доступна 
	только внутри своего метода. 
	
	В другом методе переменная с таким же именем будет совсем другим объектом, т.е. 
	это разные переменные.
	
	Открой программу "Записная книжка" из файлв app20 - book.rb
					
# НАЧАЛО ПРОГРАММЫ                          (в тетрадь)
# coding: utf-8
#
def me_line
	puts "="*30				# Линия из 30 знаков '='
end
	
class Book

    def initialize              	# При создании элемента класса Book ...
        @hh = Hash.new                  # создаётся хеш @hh
        @last_person = String.new       # создаётся строковая переменная
    end
    
    def add_person opt     			# Добавление элемента в хеш и запоминание персоны
        @last_person = opt[:name]
        @hh[opt[:name]] = opt[:age] 
    end

    def show_all                        # Вывод на экран содержимое хеша
        me_line
        @hh.each do |nam, vol|
            puts "|| Name: #{nam}     Age: #{vol}  ||"
        end    
        me_line
    end
    
    def hash                        # Метод возвращает хеш из объекта
        @hh
    end
    
    def last_person             	# Метод возвращает имя последней персоны
        @last_person
    end
    
end

book1 = Book.new
    
book1.add_person :name => 'Dimon', :age => 28 # Передаём в параметр opt
book1.add_person :name => 'Roman', :age => 32
book1.add_person :name => 'Sasha', :age => 47

book1.show_all

puts book1.hash 		# обратится к хэшу можно через отдельный метод
						# в нашем случае это метод hash (см.выше)

me_line
puts "Last person: #{book1.last_person}"
# КОНЕЦ ПРОГРАММЫ

	Здесь:
	метод initialize - не вызывается. Он исполняется когда создаётся 
	новый объект (экземпляр класса).
	
	Приимущества использования КЛАССОВ:
	- доступ к хэшу имеют только методы, описанные в данном классе
		(иначе доступ к хэшу имеет любой метод в программе)
		
	- приимущество "масштабирования": если нам захочется создать ещё одну записную 
		книгу, то это делается одной командой. 
		(иначе нам придётся создавать новый хэш с новым именем, добавлять процедуры 
		для обраблотки нового хэша, или изменить их.)
		
		Так очень легко запутаться и внести изменения не в ту книгу, т.к. будет 
		не понятно, какой метод для с какой глобальной переменной работает.
	
	Имя переменной и имя метода могут совпадать. Они не мешаю друг другу
	
	
АТРИБУТЫ КЛАССА 

	Писать методы для каждой перенной класса очень неудобная вещь, и разработчики Ruby
	придумали как это облегчить. Были введены атрибуты класса:
	
	class Book
	
		attr_reader :last_person 	# разрешено только читать извне
		attr_writer :secret_code	# разрешено только писать извне
		attr_accessor :name_book	# можно и читать, и писать извне
		
		def ...
		...
		end
		
		...
	end	

	при записи внутри класса attr_reader :last_person создаётся дополнительный метод,
	ползволяющий извне прочитать значение last_person
	
	при записи attr_accessor :name_book создаётся два дополнительных метода, 
	позволяющие и прочитать значение name_book, так и изменить его значение. 
	accessor = reader + writer
	
	Для каждого экземпляра класса (каждого объекта) эти атрибуты свои и будут иметь 
	свои значения. Но в каждом объекте они точно будут.
	
	
Открой программу "Самолёты" из файлв app21 - Airplane.rb	
	
	Там больше кода с классами, и они завязаны друг за друга: 
	экземпляры класса САМОЛЁТ принадлежат к экхемпляру класса АЭРОПОРТ
		
	
End of Lesson_14
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_15

КЛАСС - в общем случае выглядит так:    (в тетрадь)
	
	class Airplane
	
		attr_reader :a		# R    - читать
		attr_writer :b		#  W   - писать
		attr_accessor :c	# RW   - читать и писать
		
		def initialize par1, par2, ...
			@a = par1
			@b = par2
			...
		end
		
		def fly
		...
		end
			
	end
	
	plane.a = 1 	# W записываем в переменную класса a значение 1
	puts plane.a 	# R считываем из переменной класса её значение
	# в случае attr_accessor - можно выполнить и запись (W) и чтение (R)
	Это всё уровни доступа к отдельным свойствам объекта.

	Местоположение attr_... в классе - произвольное.
	
	def initialize  # - это конструктор объекта
	end

	переменные, доступные внутри класса - называются свойствами объекта
	
	class Song
		attr_accessor :name, :duration
		def initialize nme, duration
			@name = name
			@duration = duratiun
		end
	end
	song1 = Song.new 'The show must go on', 6
	puts song1.name
	puts song1.duration
	
	Свойства объекта можно перечислить через запятую, но это не так наглядно, 
	как запись в столбик.
	
	Глобальные переменные класса желательно определить в конструкторе т.е. когда мы 
	пишем .new Это позволяет исключить ошибки когда мы обращаемся к массиву через 
	метод-2, а этот массив инициируется в методе-1 вместо initialize а метод-1 мы ещё
	не вызвали.
	
	Смотри программу app22 - '(class-class-class)_.rb'
	
	Здесь три класса Самолёт-Аэропорт-Страна и несколько методов, позволяющих 
	добавлять самолёты на аэродромы и прикреплять аэродромы к стране


НАСЛЕДОВАНИЕ В КЛАССАХ  (в тетрадь)

	Смотри программу в файле: app23 - (Animal-Dog-Cat)_.rb
	# -------------------------------------------------------------------------------
	class Animal
	
	  def initialize name
	    @name = name
	  end	
	  
	  def run
        puts "#{@name} is runing ..."
	  end
	  
	  def jump
	    puts "#{@name} is jumping ..."
	  end
	
	end
	# -------------------------------------------------------------------------------
	class Dog < Animal
	  def initialize
	    super 'dog'
	  end  
	  def say
	    puts 'dog say: Woof-woof!'
	  end
	end	
	# -------------------------------------------------------------------------------
	class Cat < Animal
	  def initialize
	    super 'cat'
	  end
	  def say
	    puts 'cat say: Meeeoooow!'
	  end 
	end
	# =============================================================== B E G I N =====
	cat = Cat.new
	cat.jump
	cat.run
	cat.say
				puts
	dog = Dog.new
	dog.jump
	dog.run
	dog.say
	# =================================================================== E N D =====
	
	Jumping ...
	Running ....
	Meeeoooow!
	
	Jumping ...
	Running ....
	Woof-woof!
	
	Здесь класс Dog и класс Cat наследуют все свойства и методы из класса Animal 
	В то же время они имеют собственные методы .say у каждого свой метод, хотя имена 
	у них одинаковые.
	
	При инициализации объекта cat параметр 'cat' по слову super передаётся в 
	супер-класс т.е. в класс Animal (в его initialize)
	
	http://phrogz.net/programmingruby/tut_classes.html

	
End of Lesson_15
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_16

КОНСТРУКТОР в КЛАССЕ - в общем случае выглядит так:    (в тетрадь)
	
	# -------------------------------------------------------------------------------
	class Animal
		def initialize par1, par2
			@a = par1
			@b = par2
			@arr = [ ... ]
			@hh = { ... }
		end		
	end	
	# =============================================================== B E G I N =====
	animal = Animal.new 5, 'abc'
	# =================================================================== E N D =====

НАСЛЕДОВАНИЕ свойств КЛАССОВ                          (в тетрадь)    

	# -------------------------------------------------------------------------------
	class Animal	# Класс "родитель" - super класс
		.... 		# и все его свойства будут ... 
	end
	# -------------------------------------------------------------------------------
	class Dog < Animal	# ... будут переданы классу Dog (классу "наследнику")
		....
	end
	# -------------------------------------------------------------------------------

!!! Naming conventions - (соглашение об именах)
	JessiePinkman
	Jessie_Pinkman
	
	В разных командах приняты разные соглашения об именах.
	
УКАЗАНИЕ ПАРАМЕТРОВ ДОСТУПА к определённым МЕТОДАМ

	Это фишка ООП: 
					public		- открытый, доступный
					protected	- ???
					private		- скрытый (приватный) часный
	# -------------------------------------------------------------------------------
	class Animal
		def initialize name
			@name = name
		end
		# _____ по-умолчанию доступен открытый (public) блок с методами
		ger run
			puts "#{@nme} is runing..."
		end
		def jump
			eat								# -здесь вызываем из privet
			puts "#{@nme} is jumping..."	
			sleep							# - и ещё здесь
		end
		private	# ___________ начало частного (private) блока с методами
		def eat
			puts "I am eating..."
		end
		def sleep
			puts "I am sleeping..."
		end
		public # ____________ начало ещё одного открытого (public) блока
		def hi
			puts '............Ooops!'
		end
	end
	# -------------------------------------------------------------------------------
	class Dog < Animal
		def initialize
			super 'dog'
		end
		def bark
			puts 'Wouf-wouf!'
			sleep
		end
	end		
	# =============================================================== B E G I N =====
	animal = Animal.new 'cat'
	animal.jump
	# animal.sleep		# -	работать не будут т.к. они в блоке privat 
	# animal.eat		# .. т.е. могут работать только при вызове их
						# .. из любого метода своего класса.
	animal.hi
	
	dog = Dog.new		# !!! Имя здесь не указываем, т.к. оно уже ука-
						# зано в initialize и передаётся в super класс
	dog.jump	# для этого, нового объекта будет работать функционал
				# от кошки. Мало того, все унаследованные в том числе
	dog.bark	# private методы могут быть исполльзованы в Dog классе	
	# =================================================================== E N D =====	
	Вывод программы:
						I am eating...
						cat is jumping...
						I am sleeping...
						............Ooops!
						I am eating...
						dog is jumping...
						I am sleeping...
						Wouf-wouf!
						I am sleeping...
	
	Методы, описанные в private блоке не могут быть вызваны извне.
	Их можно вызвать только через другие методы этого класса. 

(!)	private - ограничивает доступ к методам только непосредственно из этого класса. 
			  
	Как это применяется: Например программист пишет метод приготовления
	яичницы. Метод "Делать_яичницу" - делится на более мелкие методы:
		Поставить сковороду на плиту - 
		Включить плиту - 
		Разбить яйцо -
		Посолить - 
		Убавить огонь - 
		Ждать 5 минут - 
		Выключить плиту - 
		Переложить в тарелку ...
	Все эти методы будут private т.к. они по отдельности не должны вызываться, 
	их вызывает наш главный public метод "Делать_яичницу".
	 
	Если этого не сделать, то объект будет способен на безумие, 
			например - Разбить яйцо (без сковороды).
			Это есть - нарушение поведения класса (!!!) 
	
	А так, каждая операция в процедуре "Делать_яичницу" имеет свой блок кода, 
	отделённый от соседних операций. Это удобно.
	В том числе при поиске ошибки - "если яичница подгорела". 
	
	Вторым неоспоримым удобством является возможность использовать эти элементарные 
	операции в создании других методов, напрмер: 
											  "Приготовить_борщ" или "Сварить_яйцо".
	
	Совокупность открытых методов для класса часто называют:
	API - Application Program Interface.
	
	
СТАТИЧЕСКИЕ МЕТОДЫ								(в тетрадь)

	# -------------------------------------------------------------------------------
	class Man
		def self.say_hi		# staric - статический метод
			puts 'Hi!'
		end
		def self.say_bye	# staric - статический метод
			puts 'Bye!'
		end
	end
	# =============================================================== B E G I N =====
	Man.say_hi 
	Man.say_bye 
	# =================================================================== E N D =====
	
	важное слово здесь: self
	
	Другой пример программы:
	# -------------------------------------------------------------------------------
	class RandomEngine															# Машина случайных чисел
		def self.get_random_value
			rand(100..999)
		end
	end
	# -------------------------------------------------------------------------------
	class GameEngine
		def self.play
			a = RandomEngine.get_random-value       
		end	
	end
	# =============================================================== B E G I N =====
	GameEngine.play
	# =================================================================== E N D =====
	
	Здесь программа разделилась на два блока: 
				- отвечает зп получение случайного числа
				- отвечает за саму игру
	Каждому программисту можно поручить отдельный класс. И в случае если с программой
	работают несколько программистов, то разделение на классы позволяет ограничить 
	влияние друг на друга.
	
	
yield - КЛЮЧЕВОЕ СЛОВО

	# -------------------------------------------------------------------------------
	class run_5_times
		5.times do
			yield
		end		
	end
	# =============================================================== B E G I N =====
	run_5_times { puts 'Something' }
	# =================================================================== E N D =====				

	Ключевое слово yield возвращает выполнение в блок { ... } вызывающего 
	метода run_5_times
	
	При вызове не передаётся никакого параметра, 

	# -------------------------------------------------------------------------------
	class run_5_times 		# это аналог 5.times
		x = 0
		while x < 5
			yield xб 55	 	# возвращает x в блок вызвавшей процедуры { |i, v| ... }
			x += 1			# здесь это x = x + 1
		end		
	end
	# =============================================================== B E G I N =====
	run_5_times { |i, v| puts "Something, index: #{i}, Val = #{v}" }
	# =================================================================== E N D =====


Lambda - указатель на функцию

	# -------------------------------------------------------------------------------
	x = lambda { |a| ... }
	# -------------------------------------------------------------------------------
	y = lambda do |a|
		...
	end	
	# =============================================================== B E G I N =====
	x.call 55					# вызов с параметром
	# =================================================================== E N D =====
		
	Иногда очень удобно переменным присваивать указатели на функций.
	Например удобно иметь массив указателей на функции.
	
  1.Пример программы с использованием массива:
	# -------------------------------------------------------------------------------
	say_hi = lambda {puts 'Hi'}
	say_bye = lambda {puts 'Bye'}
	# =============================================================== B E G I N =====
	week = [ say_hi, say_hi, say_hi, say_hi, say_hi, say_bye, say_bye ]
	week.each do |day|
		day.call
	end
	# =================================================================== E N D =====
	Вывод на дисплей:
						Hi
						Hi
						Hi
						Hi
						Hi
						Bye
						Bye
	

  2.Ещё пример использования:
	# -------------------------------------------------------------------------------
	sub_10 = lambda do |x|
		return x - 10
	end
	# -------------------------------------------------------------------------------
	sub_20 = lambda { |x| return x - 20 }
	# -------------------------------------------------------------------------------
	add_40 = lambda { |x| x + 40 }
	# =============================================================== B E G I N =====
	a = 1000
	a = sub_10.call a
	puts a
	a = sub_20.call a
	puts a
	a = add_40.call a
	puts a
	# =================================================================== E N D =====
	Вывод на дисплей: 
						990
						970
						1010
	
  3.Третий пример использования lambda с хэшем.
	Надо:
	    до 300 - плюс 10
	    до 600 - плюс 20
	больше 600 - минус 5
	# -------------------------------------------------------------------------------
	add_10 = lambda { |x| x + 10 }
	# -------------------------------------------------------------------------------
	add_20 = lambda { |x| x + 20 }
	# -------------------------------------------------------------------------------
	sub_5 = lambda { |x| x - 40 }
	# =============================================================== B E G I N =====
	balance = 1000
	hh = {  111 => add_10, 222 => add_10, 333 => add_20, 
			444 => add_20, 555 => add_20, 666 => sub_5, 
			777 => sub_5,  888 => sub_5,  999 => sub_5 }
	loop do
		x = rand(100..999)
		puts "Combination: #{x}"
		if hh[x]
			f = hh[x]
			balance = f.call balance
			puts 'Lambda called'
		esle
			balance = sub_5 balance
		end
		puts "Balance: #{balance}"
		puts 'Press Enter to continue ...'
		gets
	end
	# =================================================================== E N D =====
	
	
МОДУЛИ - Module - NameSpace (Пространство имён) 	
	
	http://www/tutorialspoint.com/ruby/ruby_modules.html
	Позволяют сделать множественное наследование.
	
	Mixin - перемешивать
	
	Модуль содержит несколько классов,
			Класс содержит несколько методов.
			
	Модули и Классы - это абстракция, которая должна облегчать жизнь программиста.		
	
	# -------------------------------------------------------------------------------
	module A
		def a1
		end
		def a2
		end
	end
	# -------------------------------------------------------------------------------
	module B
		def b1
		end
		def b2
		end
	end	
	# -------------------------------------------------------------------------------
	class Sample
	include A
	include B
		def s1
		end
	end
	# =============================================================== B E G I N =====
	samp = Sample.new
	samp.a1
	samp.a2
	samp.b1
	samp.b2
	samps1
	# =================================================================== E N D =====	
	
	
	Пример модулей:
	# -------------------------------------------------------------------------------
	module Numans
		class Manager
			Puts 'Hi'
		end
		class Hipster
			puts 'Hiiii, yo!'
		end
		class Jessie_Pinkman
			puts 'Hi, Bitch!'
		end
	end
	# -------------------------------------------------------------------------------
	module Animals 
		class Dog
		end
		class Cat
		end
	end
	# =============================================================== B E G I N =====
	hipdter = Humans::Hipster.new
	hipster.say_hi
	dog = Animals::Dog.new
	# =================================================================== E N D =====
	
	
ПОДКЛЮЧЕНИЕ другого ФАЙЛА

	require './file1.rb'
	
	require - (требовать)
	
	./ - означает текущую директорию
	Обычно требует полный путь, но можно и так. (Зависит от ОС).

	Пример с подключением другого файла:
	# ----------------------------------------------------- файл app24-1.rb ---------
	require './app24-2.rb'
	BB.say_hi

	# ----------------------------------------------------- файл app24-2.rb ---------	
	module BB
		def self.say_hi
			puts 'hi'
		end
	end
	# -------------------------------------------------------------------------------
	     Запускаем: ruby app24-1.rb
	Выводит: hi из файла app24-2.rb

	Здесь не используется класс, просто есть модуль BB который содержит один 
	СТАТИЧЕСКИЙ метод. (self - перед методом)
	
	Если сделать классы, то можно будет не использовать статические методы, а 
	обращатся через объекты этого класса.
	
	Разбиение на файлы удобно тем, что каждый программист работает над отдельным 
	файлом и они друг другу не мешают. Каждый пишет свой модуль, это очень удобно.


ТИПЫ ПЕРЕМЕННЫХ

	1. Глобальная переменная. Доступна в любом месте программы
		$global_var = "I'm global and live everywhere"
	
	2. Локальная переменная. Доступна только в том блоке где определена
		lacal_var = 'I only live in code blocks'
	
	3. Переменная экземляра. Доступна внутри этого экземпляра
		@instance_var = 'There is one of me per class instance'
	
	4. Переменная классаю Доступна всем экземплярам этого класса
		@@class_var = 'There is one of me per class'

	5. Константа. Не может быть изменена
		CONSTANT = 'I NEVER CHANGE! AARRRGGGGHHHH!!!!'
	
	
	Описание переменных и их места в программе
	# -------------------------------------------------------------------------------
	class App
		CONSTANT = 'I NEVER CHANGE! AARRRGGGGHHHH!!!!'
		@@class_var = 'There is one of me per class'

		def print_variables
			@instance_var = 'There is one of me per class instance'
			lacal_var = 'I only live in code blocks'
			
			puts $global_var
			puts CONSTANT
			puts @@class_var
			puts @instance_var
			puts local_var
		end
	end
	# =============================================================== B E G I N =====
	$global_var = "I'm global and live everywhere"
	App.new.print_variables
	# =================================================================== E N D =====
	
	Книга скачать: "Roman's Kindle for PC - The Rapid Rubyist"
	
	Пример использования переменной класса
	# -------------------------------------------------------------------------------
	class Song
		@@times = 0
		def play
			@@times += 1
		end
		def total_times
			@@times
		end
	end
	# =============================================================== B E G I N =====
	song_1 = Song.new
	song_2 = Song.new
	song_3 = Song.new
	
	song_1.play
	song_2.play
	
	puts song_3.total_times
	# =================================================================== E N D =====
 	Выводит: 2
 	
 	Здесь мы дважды обратились в play методу, 
 	а прочитали переменгнцю класса через третий объект, через который play не 
 	вызывалась.
 	
 	Эта переменная доступна всем экземплярам данного класса. Она общая для них всех.
 	
 	
End of Lesson_16
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_17

МЕТАПРОГРАММИРОВАНИЕ 

METHOD send 

  1.Вызов функции с помощью символа
	# -------------------------------------------------------------------------------
	def mm
		puts 'Hi'
	end
	# =============================================================== B E G I N =====
	send :mm
	# =================================================================== E N D =====
	Выводит: Hi
	
	
  2.Вызов функции с помощью символа и передачей параметра
	# -------------------------------------------------------------------------------
	def mm args
		puts args
	end
	# =============================================================== B E G I N =====
	send :mm, 555 					# - meta-programming
	# =================================================================== E N D =====
	Выводит: 555
	
  3.Вызов функции с помощью символа и передачей параметра в виде ХЭША
	# -------------------------------------------------------------------------------
	def mm hach
		puts hash.inspect
	end
	# =============================================================== B E G I N =====
	send :mm, :x => 1, :y => 2  
	send "mm", :x => 1, :y => 2 
	# =================================================================== E N D =====
	Выводит: 555
	
	
  4.Создание объекта - (использование функции send() )
	# -------------------------------------------------------------------------------
	class Something
		attr_accessor :name			# Без accessor присвоение ниже работать не будет
		def initialize
			# @name = "aaa"			# Это же действие делает следующая строка
			send("name=", "Mike")	# .. это присвоение
		end
	end	
	# =============================================================== B E G I N =====
	s = Something.new
	puts s.inspect
	
	#puts s.name
	# =================================================================== E N D =====
	Выводит все параметры объекта s
	
	
  5.Создание объекта - (использование ХЭШ с функцией send)
	# -------------------------------------------------------------------------------
	class Something
		attr_accessor :x, :y, :z		# перечислим все переменные экземпляра
		def initialize hash				# при создании сюда передаётся Хэш параметров 
			hash.each do |key, value|	# перебираем все пары хеша и 
				send "#{key}=", value	# создаём поочереди переменные экземпляра
			end
		end
		# Это эквивалентно следующему коду:
		# def initialize x, y, x
		# 	@x = x
		# 	@y = y
		#	@z = z
		# end
		# Чем больше будет параметров, тем больше станет программа (длиннее код)
		# В предыдущем варианте длина кода не зависит от количества параметров (!)
	end	
	# =============================================================== B E G I N =====
	s = Something.new :x => 1, :y => 2
	puts s.x
	# =================================================================== E N D =====
	Выводит.


METHOD method_missing	
	
  1.Использование метода "method_missing" для отсутствующих методов класса
	# -------------------------------------------------------------------------------
	class Something
		...
		def method_missing name
			puts "Calling unknown method #{name}"
			...
		end
		...
	end	
	# =============================================================== B E G I N =====
	s = Something.new 
	s.asdblabla1234				# такого метода нет
	# =================================================================== E N D =====
	# Здесь при вызове метода, которого нет в данном классе - будет вызван метод
	# method_missing - как "заглушка" от ошибки вызова отсутствующего метода	
	 
	method_missing - (отсутствие метода)
	Это специальное зарезервированное слово, как initialize
	
	
  2.Использование метода "method_missing" для обработки других методов (через Хэш)
	# -------------------------------------------------------------------------------
	class Albuquerque
		def initialize actions
			@actions = actions
		end 
		...
		def method_missing name
			value = @actions[name]
			value = 'no number' if value = ''
			puts "If you want to #{name}, you must be call #{value}"
		end
	end	
	# =============================================================== B E G I N =====
	a = Albuquerque.new :cook => "Walt", :take_a_ride => "Jessie", :die => "Gus"
	a.cook
	a.take_a_ride
	a.die 
	a.bala-bla-bla
	# =================================================================== E N D =====
	# Здесь при вызове метода, которого нет в данном классе - будет напечатано
	# значение из хэша, соответствующее этому ключу, а если такого ключа нет, то 
	# фраза-заглушка "no number"	
	Выводит:
	If you want to cook, you must be call Walt
	If you want to take_a_ride, you must be call Jessie
	If you want to die, you must be call Gus
	If you want to bla-bla-bla, you must be call no number
	
	Приимущество в том, что Нам не нужно определять кучу разных методов 

	3.Использование метода "method_missing" без создания класса
	# =============================================================== B E G I N =====
	def method_missing name
			puts "Calling unknown method #{name}"
	end
	
	asdrfrhguru
	# =================================================================== E N D =====
	
	
METHOD define_method
	
	1.Использование метода "define_method" для определения методов
	# -------------------------------------------------------------------------------
	send :define_method, "aaa" do
		puts "Hello, I'm new method"
	end
	# это эквивалентно следующей записи:
	def aaa 
		puts "Hello, I'm new method"
	end
	# =============================================================== B E G I N =====
	aaa
	# =================================================================== E N D =====
	# Эта запись определяет метод. Аналогично обычной записи. 

	# During runtime (Во время выполнения программы) имеется возможность определить
	# свой метод с именем, заданныв переменной (вместо "aaa") и использовать его
	# для последующих операций
	# send :define_method, "aaa" - Это определение метода по имени. 
	
	
	2.Использование метода "define_method" для определения метода через консоль
	# =============================================================== B E G I N =====
	print "Name of method to define: "
	method_name = gets.strip
	
	send :define_method, mathod_name do
		puts "Hello, I'm new method"
	end
	
	send mathod_name
	# =================================================================== E N D =====
	# Здесь название метода задаёт пользователь и программа хнаеит его в переменной 
	# method_name 
	# Вызов этого метода происходит через send
	
	В метапрограммировании есть много особенностей и возможностей.
	Подробности нужно смотреть в документации ...
		
	
	3.Использование метода "define_method" в простейше варианте (есть два метода)
	# -------------------------------------------------------------------------------
	def left
		puts "Robot goes left" 		# Превый метод
	end
	# -------------------------------------------------------------------------------
	def rigth
		puts "Robot goes right"		# Второй метод
	end
	# =============================================================== B E G I N =====
	print "Where to go (left/right): "
	a = gets.strip
	
	send a 
	# =================================================================== E N D =====
	# Здесь пользователь сам вводит имя нужного метода для выполнения
	# например в играх, где вводятся команды: lefr, right

ЗАКОНЧИЛИ МЕТАПРОГРАММИРОВАНИЕ
	
	
(!)	При передачи параметров сначала пишут переменные, а в конце хэш
		ХЭШ всегда на последнем месте:
		
		a.rows "something", :x => 1, :y => 2, :z => '34'
		

METHOD .split

	Разделить (расщепить). Есть сепаратор
	s = 'January, 10, 55, 81'
	arr = s.split
	

ПОИСК ИНФОРМАЦИИ НА САЙТЕ stackoverflow.com

	Пишем в посковике на английском:
	
	google: ruby read file site:stackoverflow.com
	руби читать файл сайт: токой-то
	
	google: ruby write to docx site:stackoverflow.com
	
	Так легко найти ответы на многие вопрос и не толко по руби.

	
РАБОТА С ФАЙЛАМИ					

METHOD .open
METHOD .close

	input = File.open("test.txt", "r") 
	output = File.open("output.txt", "w")
	# Здесь скобки можно не писать
	Если не указан полный путь, то файл читается (или пишется) в текущей директории.
	
	"r" - режим чтения (read)
	"w" - режим записи (write)
	
	"r+" - read + Write
	"w+" - write + read
	Последние два - аналогичные за исключением различных блокировок.
	
	"a" - append (добавить) - открыть файл с "w" и передвинуть курсор в конец файла.
				типа - дописать.
	# -------------------------------------------------------------------------------
	# =============================================================== B E G I N =====
	# =================================================================== E N D =====
	
	# Файл для записи
	# =============================================================== B E G I N =====
	output = File.open "test.txt", "w"
	output.write "Something \n"
	output.close
	# =================================================================== E N D =====

	# Файл для чтения
	# =============================================================== B E G I N =====
	input = File.open "test.txt", "r"
	while (line = input.gets)
		puts line
	end
	input.close
	# =================================================================== E N D ===== 

	Пример использования.
	# -------------------------------------------------------------------------------
	# file: "app25 - test.txt"
					Январь, 100, 6
					Февраль, 30, 7
					Март, 60, 0
					Апрель, 90, 3
					Май, 110, 6
					Июнь, 80, 3
					Июль, 30, 6 
					Август, 70, 8
					Сентябрь, 50, 2
					Октябрь,110, 5
					Ноябрь, 75, 3
					Декабрь, 95, 2
	# =============================================================== B E G I N =====
	input = File.open "app25 - test.txt", "r"
	total_summ_1 = 0
	total_summ_2 = 0
	while (line = input.gets)
		arr = line.split(',')
		item_1 = arr[1].strip.to_i
		item_2 = arr[2].strip.to_r
		total_summ_1 += item_1
		total_summ_2 += item_2
	end
	puts "Total_summ = #{total_summ_1}"
	puts "Small_summ = #{total_summ_2}"
	input.close
	# =================================================================== E N D =====
	
METHOD .rename

	File.rename file_name_1, fole_name_2
	# здесь всё просто


АТРИБУТЫ ДОСТУПА К ФАЙЛАМ

METHOD .chmod

	In Linux 
	
	chmod 777 file1.rb
	
	r - Read
	w - Write
	x - eXecute	
	
	r  w  x  |  8
	---------+-----
	0  0  0  |  0
	0  0  1  |  1
	0  1  0  |  2
	0  1  1  |  3
	1  0  0  |  4
	1  0  1  |  5
	1  1  0  |  6
	1  1  1  |  7
	
	 
	7 7 7 
	| | + - все остальные (other)
	| + - - для группы  (group)
	+ ----- для хозяина (owner)

	Наиболее часто применяемые комбинации:
	      own  grou oter
	755 = rwx  r-x  r-x
	666 = rw-  rw-  rw-
	644 = rw-  r--  r--
	
	Изменить права можно с помощью команды File.chmod 
	
	
METHOD .pwd

	> puts Dir.pwd   # выводит рабочую директорию (print working directory)	
	
	> Dir.chdir	'..' # сменить рабочую директорию
	
	> Dir.entries "C:/projects"
	=> [".", "..", "bak", "Lesson13", "Lessom14", "Lesson15", "Lesson16", "Lesson17"] 	
	# возвращает массив всех элементов в указаной директории
	
	stop
		
End of Lesson_17
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_18

	http://rubyschool.us/files/Lesson18/password.txt
	Файл с паролями.
	
	# =============================================================== B E G I N =====
					input = File.open "password.txt", "r"
					while (line = input.gets)
						puts line if line.strip.size == 6
					end
	# =================================================================== E N D =====	
	# Открываем файл и читаем построчно в переменную line
	# Для вывода результата в файл пишем > ruby app26.rd > password-6.txt
	
	
	Ещё программа которая анализирует введённый пароль.
	# =============================================================== B E G I N =====
					input = File.open "password.txt", "r"
					print "Enter your password: "
					your_pass = gets.strip

					i = 0
					while (line = input.gets)
						line.strip!
						i += 1
						if your_pass == line
							puts
							puts "Your password #{your_pass} is weak!"
							exit
						end
						print ". #{i} - Working: #{line} "+" "*15+"\r"
						sleep 0.005                
					end
					puts
					puts "Your password #{your_pass} is NOT weak!"
	# =================================================================== E N D =====
	
	
	# app26-2.rb
	# -------------------------------------------------------------------------------
					def is_your_password_weak? pass
						input = File.open "password.txt", "r"
						while (line = input.gets)
							line.strip!
							if pass == line
								return true
							end
						end
						return false
					end
	# =============================================================== B E G I N =====
					print "Enter your password: "
					your_pass = gets.strip

					if is_your_password_weak? your_pass
						puts "Your password #{your_pass} is weak!"
					else
						puts "Your password #{your_pass} is NOT weak!"
					end
  # =================================================================== E N D =====
	Если мы пишем функцию, которая возвращает true или false то нужно писать знак ?
	

WEB ТЕХНОЛОГИИ 

	На собеседовании часто спрашиваю: 
	"Знаете ли Вы что происходт когда пользователь вводит адрес в строку браузера"?
	
	Или ещё: "Что такое GET и POST запросы, в чём разница"?
	
	Когда пользоваптель вводит что-то в адресную строку Браузер отправляе GET-запрос.
	GET - переводится как "ПОЛУЧИТЬ" т.е. браузер хочет получить что-то.
	
	POST - переводится "ОТПРАВИТЬ" какие либо параметры (и получить ответ сервера).
	
	Когда мы вводм Login и Password браузер сразу не отправляет эти данные на сервер.
	Он отправит эти данные когда мы нажмём специальную кнопку, например "Send".
	Внутри запроса видно, что используется POST-запрос и после всей служебной информации
	идёт специальная запись: login=admin&password=123456
	
	И на GET-запрос, и на POST-запрос сервер отправляет определённую страничку с сайта
	Эта страничка - последовательность символов и кодов, из которых браузер формирует
	отображение сайта в свойм окне.
		С этой текстовой информацией мы можем поработать. Можем её проанализировать. 
	
	Server - serv - (обслуживать)  Сервер сам ничего не отправляет.
	
	Есть удобная (бесплатная) программа для Windows:
	FIDLER - программа (прокси-сервер) который показывает все запросы и их параметры
			ROW - (сырой) сырой пакет - видно, что браузер отправляет на сервер.
			Там много различных данных к каждому запросу.
			Программа "вклинивается" между программой (браузером) и сетью интернет и пере-
			хватывает все запросы, пропуская их через себя. Это позволяет увидеть какие
			запросы куда направлены, какие ответы получены, что они содержат.
			Кроме браузеров в Fidler видны запросы всех прогдамм на компьютере.
			
	Думаю должна быть такая программа и для Linux. Для Mac - точно есть, но платная.
			
	Если посмотреть исходный код страницы входа на наш РОУТЕР, то можно увидеть там
	участок кода с тегами: 
	...
	<input ... name=login, ... />
	...
	<input ... name=password, ... />
	... 
	это и есть имена наших данных, который будет обрабатывать сервер.
	А вот их значения беруться браузерером из поля, в которое Вы его вводили. 
	Так формируется POST-запрос		
	
	Сервер говорит "Ок" или "Не Ок". Вариантов ответов сервера множество.
	
	См. документацию по rfc http (набрать в google). Там есть коды "удач" и " неудач". 
	https://www.opennet.ru/docs/RUS/http11/ - по русски.
	
	Std-lib - (стандартная библиотека) это то, что входит в сам Ruby.
						библиотека, имеет большой набор функций. См. документацию.
	
	Gems - это то, что пишут разработчики.
				 информация по конкретному gem нужно смотреть в документации к этому gem. 	
	
	Net::HTTP - это из Std-lib.
	
	И так,
	Используем прямое указание для метода get (GET-запрос)
	# =============================================================== B E G I N =====
			require 'net/http'    # Требовать класс http из модуля (пространства имён) net
			response = Net::HTTP.get 'rubyschool.us', '/router'
																# .get использует два параметра: домен и путь 
																# здесь написано для: http://rubyschool.us/router
			puts response           	# вывести текстовы код страницы в терминал
	# =================================================================== E N D =====
	Если запускать файл с дополнительной командой | grep div то вместо большого
	текста на экран будет выведены только те строки, в которых есть этот текст div
	> ruby app.rb | grep dev
	
	
	Не всегда удобно явно прописывать в две переменные адреса страницы сайта
	Чаще и удобнее использовать ссылку целиком.
	Это будет выглядеть так:
	# =============================================================== B E G I N =====
				require 'net/http'        # Требовать класс http из модуля net
				require 'uri'
				
				uri_var = URI.parse 'http://rubyschool.us/router' # Создаётся новый объект
				response = Net::HTTP.get uri_var									# Отправляем GET-запрос 
				puts response    # вывести (ответ сервера) текстовы код страницы в терминал
	# =================================================================== E N D =====
	URI — унифицированный идентификатор ресурса.    (Uniform Resource Identifier)
	По-русски иногда говорят [у́ри]. 
	URI — последовательность символов, 
															     идентифицирующая абстрактный или физический ресурс. 
	Ранее назывался Universal Resource Identifier — универсальный идентификатор ресурса.
	
	Результатом выполнения программы выше - будет текстовая информация с сервера.
	
	Если мы хотим подключится к своему роутеру, то нужно отправить POST-запрос с 
	параметрами login=admin&password=123456 Эти данные мы уже разбирали выше 
	см. упоминание тега <input .../>
	
	Для отправки POST-запроса роутеру нам понадобится метод .post_form 
	Этому методу мы передаём uri и хэш с параметрами.
	
	res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
	
	В нашем случае это будут: login=admin&password=123456
	Отправляем POST-запрос с параметрами на адрес в uri
	# =============================================================== B E G I N =====
				require 'net/http'      
				require 'uri'
				
				uri_var = URI.parse 'http://rubyschool.us/router'  # Создаём новый объект
				
				response = Net::HTTP.post_form(uri_var, :login => 'admin', 
																						 :password => '123456')
																										 
				puts response  
	# вывести (ответ сервера на POST) текстовы код страницы в терминал
	# =================================================================== E N D =====
	Ключи в хэше можно писать символами :login или строкой "login" 
	Значения всегда стока "ku-ku" или '234'	
	При правильном запросе нам возвращается объект и выводится id_объекта:
	=> Net::HTTPOK:0x000000305bdf8
	
	response - это объект с кодом страницы сайта
	В дальнейшем можно с ним работать:
		- искать вхождения
		- анализировать содержимое
		- проверять доступность ссылок и т.п.
	
	# Скобки в post_form можно не писать	
			response = Net::HTTP.post_form uri_var, :login => 'admin', :password => '123456' 	 
	
	Давайте проагализируем ответ с сервера.
	В нашем случае (в друго случае может быть подругому) если login или password были
	ошибочными, сервер присылает страницу, в которой есть фраза 'Access deniet'
	"Дотуп запрещён".
	
	Чтобы определить вошли мы или нет, нужно просто выяснить: содержится ли в ответе
	фраза 'Access deniet' или вообще 'denied'
	
			puts response.include? 'denied'
	
	Пишем программу
	# =============================================================== B E G I N =====
			require 'net/http'      
			require 'uri'
			
			def is_it_wrong_password? pass
				uri_ = URI.parse 'http://192.168.0.1/' 
				response = Net::HTTP.post_form(uri_, :login => 'admin', :password => pass).body
				return response.include? 'denied'  
			end	
			puts is_it_wrong_password? '1231213'
	# 
	# =================================================================== E N D =====
	
	
	Программа подбирает пароли к Вашему роутеру, перебирая варианты их файла.
	(У меня тормознул на 2770 - примерно, причина не выяснена)
	# file: app27-router.rb
	# -------------------------------------------------------------------------------
			require 'net/http'      
			require 'uri'
			def is_it_wrong_password? pass
				uri_ = URI.parse 'http://192.168.0.1/' 
				response = Net::HTTP.post_form(uri_, :login => 'admin', :password => pass).body
				return response.include? 'bad_auth'  
			end	
	# =============================================================== B E G I N =====
			input = File.open "password.txt", "r"
			i = 0
			while (line = input.gets)
				line.strip!
				i += 1
				if is_it_wrong_password? line
					puts "I am found! Your password is: #{line}"
					input.close
					exit
				end
				print ". № #{i} - Trying: #{line} "+" "*15+"\r"
			end
			puts "I don't found your password. Sorry..."
			puts "Because your password is very good"
			input.close
	# =================================================================== E N D =====	
	
End of Lesson_18
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_19

УСТАНОВКА RUBY НА WINDOWS.

	http://teamviewer.com
	
	dem install hipchat
	
'http://putshello.wordpress.com/2014/08/03/installing-ruby-for-windiws-the-right-way'
 
	http://rubyinsyaller.org/downloads/
	
	Other Useful Downloads - Другие полезные скачки
	
	Development Kit 

GEM - Sinatra

	gem install sinatra
		
	Браузер использует get чтобы отправить запрос на сервер
		
			#
			require sinatra
			#
			get '/' do
				'Hi'
			end
		
	запускаем в териминале
	>_ riby app1.rb
		
	далее будет выведена специальная информация и программа не будет завершена
	Это запустилась sinatra на нашем компьютере.
		
	Для просмотра нужно в браузере набрать адрес  
	link: localhost:4567			- ССЫЛКА ДЛЯ GEM SINATRA
		
	Это наш первый сайт! :-) 
	                                 Поздравляю!
	                                 
	Здесь мы обратились к серверу, который установлен на нашем компьютере.
	И соевер вывел Hi
		
	view - (вид, представление)
			
	В вакансиях программистов есть разделение (frontend - backend)
	Обычно задачи для программиста или frontend или backend   
	
	frontend - использует view - это отображение в браузере. Обычно это html-страница
						 но часто она записана в особом формате.
						 
	backend - это тот код, который расоположен на сервере и не виден пользователю.
	          обычно это набор контроллеров (отдельных методов) которые обеспечивают
	          обработку приходящих на сервер запросов. И конечно отправляют необходимые
	          данные назад в браузер. 
			
	MVC
	M - Model 			- модель
	V - View 				- представление
	C - Controller 	- контроллер

	# file: app.rb __________________________________________________________________
			system('clear') # Linux
			require 'sinatra'
	# =============================================================== B E G I N =====
			get '/' do
				erb :index	# index - это имя файла с представлением
			end
	# =================================================================== E N D =====
				
	
	# file: view/index.erb __________________________________________________________
			<h1>Hi</h1> 																	
			<-- Это пишу для исправления кривой зелёной расцветки / --> 
			
	erb - это 'template engine' - шаблона движок - Механизм получения html-файла
	
	Все варианты движков шаблона можно посмотреть на github по адресу:
	https://github.com/sinatra/sinatra
	Ищи в содержании раздел: 'Available Temlate Languages'	
		    
	
	Расширим возможности нашего сайта.
	Пусть сайт спрашивает логин и пароль.
	Если логин или пароль введены неправильно, то он выводит эти значения и просит 
	повторить ввод.
	А если логин и пароль (admin secret) то он выводит страничку приветствия welcome
	и напишет слова приветствия.	
	# filename: app.rb ______________________________________________________________
					system('clear') # Linux

					require 'sinatra'

	# =============================================================== B E G I N =====
					get '/' do
						erb :index	# index - это имя файла с представлением
					end

					post '/' do
						@login = params[:aaa]
						@password = params[:bbb]
						
						if @login == 'admin' && @password == 'secret'
							erb :welcome
						else  
							erb :index	# index - это имя файла с представлением
						end  
					end
	# =================================================================== E N D =====
	
	
	# filename: views/index.erb _____________________________________________________
					<h1>Hi</h1>

					<p>You typed: <%= @login %></p>
					<p>Your password: <%= @password %></p>


					<form action="/" method="POST">

						<input type="text" name="aaa" />
						<input type="password" name="bbb" />
						<input type="submit"/>

					</form> 
					
					
	<-- Это пишу для исправления кривой зелёной расцветки / --> 
	# filename: views/welcome.erb ___________________________________________________
					<h1>Congratulation!</h1>
					<h3>You are logged in!</h3>
	<-- Это пишу для исправления кривой зелёной расцветки / --> 
	
	scraping - "паучёк", который ходит по сайту и переходит по ссылкам, получает 
							страницы и анализирует эту информацию.
							
							Например кому-то нужно на сайте амазон проити по категории bestsellers
							по товару книги и собрать информацию о каких-то параметрах этих книг
							интересует первая сотня товаров.
							
							Эту программу можно написать на руби, и это не должно быть сложным,
							но эта программа позволит заработать какие-то деньги.
	
End of Lesson_19
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_20

	Есть такая "фишка".
	Когда нужно создать нескольно страниц сайта, то можно воспользоваться одним 
	представлением. Например создаём несколько методов:
	
					get '/contacts' do
						@title = 'Contacts'
						@message = 'Phone number: +7 958-842-85-42'
						erb :message
					end

					get '/faq' do
						@title = 'FAQ'
						@message = 'Under construction'
						erb :message
					end

					get '/something' do
						@title = 'Something'
						@message = 'Bla-Bla-Bla ...'
						erb :message
					end

	А представление должно выгдядеть так:
	
					<h1><%= @title %></h1>

					<p>
						<%= @message %>
					</p>
	
	Здесь важно отметить, что здесь в представление отправляются две глобальные 
	переменные @title и @message а значения у них в каждом варианте свои.
	
	(!!!) - Дополнительно можно использовать отдельный метод, который будет 
	формировать переменные для одинакового вывода представления
	
					def undre_construction options
						@title = ' Under construction'
						@message = 'This page is under construction'
						@title = options[:title] if options[:title]
						@message = options[:message] if options[:message]
						erb :message
					end
					
					get '/contacts' do
						under_construction :title => 'Contacts', :message => 'Phone: 123'
					end

					get '/faq' do
						under_construction :title => 'FAQ'
					end

					get '/something' do
						under_construction
					end
					
	Так можно 				
	
	______________________      G ____ I ___ T    ________________________
	
GIT - специальное приложение, которой позволяет вести контроль версий

	Установка GIT на Windows смотри с: 00:21:00 - 

		там внутри показали(37:00) как запускать node.js - оболочка для программирования
		на ДЖАВА-СКРИПТ - (говорит, что это типа RoR но для JS)

	Ставим ungit
	ungit - это пакет под node.js
		
	Чтобы проверить, что ungit установился и работает нужно создать пустую паку,
	перейти в неё и в этой папке через консоль стартовать ungit
	В результате он должен открыть страничку в браузере и показать, что в нашей папке
	нет репозитория.

	Здесь он сразу предлогает сделать в текущей папке репозиторий (хранилище версий)
	или предлогает склонировать репозиторий из указанного места.
	
	РЕПОЗИТОРИЙ (репо исходного кода) - отдельный каталог '.git'
	В этот каталок программа будет особым образом складывать версии файлов, упаковывает
	добавляет различную информация (для себя).
	
	Программа ungit при выполнении всегда обращается к программе git и выполняет все
	свои действия с помощию пакета git
	
	Нажатие на кнопку 'Make C:/Project/test a repository' фактически это выполнение 
	команды 'git init .' в терминале (в этой папке)
	
	Т.е. при работе в ungit фактически в БЭКГРАУНДЕ (за ценой) выполняются команды
	пакета git 
	
	COMMIT - (вклад) - смысл в том, что это вклад в репозиторий от Вас (программиста) 
 
	У каждого commit - есть автор, тот кто вложил эти изменения.
	
	Надпись master означает - где мы сейчас находимся. Это как стрелочка (указатель)
	
	Всё, что "закоммичено" - это уже неизменяемая история, её можно модефицировать, 
	создать отдельную ветку, и в ней можно внести отдельные изменения и это будет видно
	всегда. ПРи работк с сервером.
	Это очень удобно!
	
	Программа sinatra_20_3 - вариант записи на стрижку в парикмахерскую с возможностью
	записи введённой информации в отдельный файл. Файл будет в режиме 'a' - append 
	т.е. режим добавления информации (дописывания)
	
	(!!!) Файл  .gitognor обычно добавляют в commit чтобы при его модернизации 
	оставалась история.
	
 
End of Lesson_20
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_21

GIT - продолжение
	
	В WINDOWS чтобы запустить ungit (и чтобы остался доступным far) 
	нужно набрать в FAR-comandetre команду start ungit
	
	Команда 'Discard all' - отменить все изменений (внесённые после последнего commit)
	
	У каждого commit есть его ключ - это восемь знаков '9726aa5d' 
	
	Если ввести в терминале (открытом в папке, где есть папка .git) такую команду:
	git checkout 9726aa5d
	то он (git) перенесёт указатель (master) на commit с этим ключём и восстановит
	состояние всех файлов, какими они были на момен даного commit.
	Некое подобие "Машины времени". 
	Аналочично можно вернуться к любому commit
	(последние не-commit-енные изменения могут быть утеряны - Да! ЭТО ФАКТ )
	
	По ссылке можно понять логику Git - Преводится "Думай как GIT"
	https://think-like-a-git.net/
	Это хорошая обучалка.
	
	Ссылки в Git делают commits доступными.
	Сыллки - это: тэги или бранчи локальные или отдалённые. Здессь ТЭГ - это метка.
	
	Checkout теперь можно сделать на эту метку (ТЭГ) в web-интерфейсе в ungit
	
	Branch - ветвь.

	Информация из моего блокнота:
	> git init — создаём .git
	> git ststus — смотрим файлы для включения в репозиторий
	> git add -A — добавляем все файлы в учёт
	> git commit -m «Install commit» - вкладываем файлы в локальный репозиторий
	> git remote add origin git@github.com — вставляем сюда адрес дальнего репозитория  
	
SINATRA - продолжение

	Если в корневой папке создать папку public 
	то файлы в этой папке будут доступны из web 
	
	Наш файл из барбершопа (список записавшихся) нужно переместить в public
	тогда этот файл можно будет выгрузить с сервера через web
	дополнительно нужно изменить данные в программе (там где указан путь к файлу)
	
	http://localhost:4567/users.txt
	

HTML - формат

	Обычно html должен иметь такую структуру:
	
	'
					<html>
						<hed>
									... - Здесь дополнительная инфори=мация о странице и настройки
						</hed>
						
						<body>
									... - здесь большой код для отображения элементов на странице
						</body>	
					</html>
	'
	
	css - каскадная таблица стилей,
			- служит, чтобы придать сайту оформление
			
	упоминаение о файл css нужно положить в <hed>  
	<link href="/styles.css" rel="stylesheet" media="all" />
	
	В браузере (открыв исходный код страницы) можно по ссылке перейти на этот файл и
	убедится, что он есть.
	
	/* Hello */  - так указывается коментарий в файлах *.css
	
	Если создать в public дополнительную папку css/, то файл в ней будет доступен 
	по ссылке: 	<link href="/css/styles.css" rel="stylesheet" media="all" />
	
	Рассмотрим пример файла css:
	
/* It's remark */

body {														Когда браузер встретит тэг: body 
		font-family: Arial;						он применит этот																
}																	формат (в данном случае это ШРИФТ

/* bootstrap - tweeter ... */

h1 {															Аналогично с тэгом: h1
		background: Yellow;
		color: Blue;
}

h2 {
		background: lightblue;
		color: Red;
}

.somephing {										 .
		color: Green;
}

#slogan {													.
		color: Brown;
}


	Примеры файлов css можно посмтреть на любом сайте через 'исходный код' и клик по 
	ссылке в <hed>
	
	Перед ключевым словом можно ничего не ставит, ставить точку '.' или знак '#'
	
	'пусто' - правила применяются к ТЭГу
	
	
	'.' - правило применяется к тегу по атрибуту _class="" 
				например правило в css-файле:
				.somephing {										
						color: Green;
				}
				применится ко всем тегам, в html-файле, имеющим в признаке _class="something"
				'
				<p class="something" ...> ... </p>
				'
				и не важно сколько будет в файле таких мест, и как они будут обозначены.
				
			- применяется ко множеству элементов.	
				
	'#' - применяется по атрибуту id 
				id - должен быть уникальный в html-файле
	
	ВАЖНО!
	'.' '#' - ставятся только в css-файле, в html - они не ставятся
	
	
	
BOOTSTRAP - twitter bootstrap - набор стилей - css framework	(там есть и JS)

	Включает в себя шрифты, кнопки, таблицы, меню, компонеры (значки), картинки, рамки,
	всплывающие окна, блоки ввода, панели, media объекты, и т.д. и т.п.
	
	Информацию и примеры кода нужносмотреть на сайте: getbootstrap.com
		- там есть способ установки - (getting-started)
		- там есть коды (классы) для каждого элемента или шрифта
		
	Нужно просто копировать код из окон и переносить в свой файл.
	
	Хорошая статья по интеграции Bootstrap в наш сайт чмтай по адресу:
http://ningbit.github.io/blog/2013/06/28/how-to-integrate-bootstrap-css-into-your-sinatra-site/
	Руклводство длинное, но очень хороший результат.
	Но есть вариант проще:
	
	https://github.com/bootstrap-ruby/sinatra-bootstrap
	Получаем с github данные с адреса выше (делаем себе клон)
	
	> git clone <Ctrl>+V
	
	Затем, по руководству, нужно зайти в эту папку и в ней (в терминале) запустить 
	команду: > bundle install			# budle - эта команда загружает (проверяет, если есть)
																# все необходимые зависимости связанные dependency
	
	bundle exec ruby app.rb				# ruby запустится с теми gem, которы указал автор
																# а не стеми, что у нас могут быть установлены.
																# очень часто в ruby может не быть обратной 
																# совместимости	и если у нас скачена последняя версия
																# sinstra, а этому клону нужна более старая, то 
																# команда bundle exec как раз запустит программу со
																# старыми (родными) версиями gem-ов, а не с новыми.
																
	# Нужные версии gem-ов указаны в специальном файле: Gemfile.lock
	
	Then open: http://localhost:4567/
	 
	Удобнее всего копировать с сайта код (таблицу) и вставлять в свой	сайт,
	а затем удалить из него всё лишнее и добавить свои данные.
	Так будет быстрее происходить процесс программирования. 
	
	Copy as HTML    -->    Paste to Your Site-code.
	
			
End of Lesson_21
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_22

GIT CLONE работает в SSH если настроен github и у нас есть регистрация с ключами
	
	Если этого нет, то нужно переключить фориат вывода ссылки с SSH на HTTPS
	Тогда коменда git clone будет работать и без ключа.
	

СОЗДАНИЕ РЕПОЗИТОРИЯ на GITHUB.com

	-	Repository 
	-	New
	-	Вводим имя репозитория (должно быть уникальным в пределаз нашего аккаунта)
	-	Discription (не обязательно) Но с ним удобнее - это короткое описание
	- Public or Private - (скрытые только за деньги)	
			Есть друго сайл https://bitbucket.org/ 	- там бесплатно
	-	Хотим ли мы добавить файл Readme в наш репозиторий
	- Добавить ли файл .gitignore (можно добавить и потом)
	-	Добавить лицензию (обычно MIT - доступно для всех)
	Create Repository 
		Всё! Репозиторий создан.
		
		Забираем ссылку с нашего нового репозотория и клонируем приложение себе в комп
		git clone ....
		(сначала нужно зайти в папку, где лежат проекты - там появится новая папка)

	Запустим ungit 
		Теперь в браузере мы увидим уже два указателя:
		- master - это указательна копию программы на нашев компьютере (папка с клоном)			
		- origin/master - это указательна копию, которая на сайте github.com
		
	При очередном commit происходит создание новой точки и указатель master (локальный)
	перемещается на неё, а вот oridginal/master осталась на старой точке, т.е. на сайте
	осталась старая версия. 
			Чтобы её обновить нужно выполнить команду PUSH для этого нужно встать на master
	и нажать на кнопку PUSH справа от master (там будет стрелка - подсказка) 
		Так внесённые изменения (на нашейм компьютере) будут отправлены на сайт и теперь
	они станут доступны для всех, кто имеет доступ к этому репозиторию на сайте.
	
		Для принятия кем-то наших изменений нужно "затянуть" изменения с сервера 
	по команде git pull 
		Команду нужно вводить в той папке, гдк есть .git - папка
	
	layour - это шаблон страницы сайта. Он выводится всегда. Это как рамка для страниц
					 сайта. В нём (в layout) естьместо обозначенное словом '<% yield %>' 
					 вмето которого и вставляются все наши view, которые мы пишем
	view - это информация, которая вставляется в рамку (шаблон) нашего сайта. А вся 
				 рамка описывается именно в layout - файле.
				 
				 В нём же подключаются и bootstrap и другие вещи, а в наших view уже не нужно
	прописывать стили и всякие медиа.
	
				В layout обычно органиховано меню сайта, система навигации по сайту и право-
	вая информация о сайте (всё в одном файле)
	
	Чистый sinatra-bootstrap-clean - можно скачать (клонировать) с реползитория:
	https://github.com/rubyschool-us/sinatra-bootstrap-clean	
	
	Чтобы не перезавускать sinatra при изменени кода сайта нужно использовать отдельный
	gem sinatra-reloader Поставим его командой gem install sinatra-reloader (с sudo)
	в результате поставились 3 gem	
	
	Осталось добавить одну строку в файл app.rb
	require 'sinatra/reloader'
	
	Для создания формы нужно скопировать код формы из bootstrap (выбирай любую)
	Лишние поля можно удалить или можно добавить недостающие поля и формы.
	
	Важно! 
	У каждого тега <input ...> должно быть имя. Вот так <input name="nik" ...>
	По этому имени сервер будет понимать какая информация пришла.
	Запятых нет.
	
	У каждой формы (тег <form ...>) должны быть указаны два параметра.
	<form action="/visit", method="POST" ... >
	Эти параметры необходимы серверу для выбора обработчика информации.
	В данном случае это будет:
	
	post '/visit' do
		@nik_value = params[:nik]
		...
		erb :list_data 					# Указатель на view которы откроется после этого post.
	end

	в головном файле приложения (app.rb)
	
	Аналогично можно добавить другие параметры. Например "телефон" и "время"
	В этом случае нужно дважды скопировать блок с nik в ту же форму и изменить nik на
	telephon и time Ещё нужно заменить текстовые названия на "Телефон" и "Время"
	
	И конечно, в другом файле, где метод post тоже нужно добавить обращение к данным:
	
	post '/visit' do
		@nik_value = params[:nik]
		@tel_value = params[:telephon]
		@time_value = params[:time]
		...
		erb :list_data
	end 
	
	Обычно, полученные данные записываются в файл. 
	Все результаты может получить администратор (по паролю)
	
	Но это уже совсем другая история...
	
			
End of Lesson_22
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_23

	В bootstrap в разделе Forms есть подраздел Supported controls а в нём есть selects 
	который позволяет пользователю сделать выбор нужного (например парикмахера).
	
	Для этого так же берём код из bootstrap и вставляем себе в форму.
	
	25:00 - добавляем парикмахеров в форму (для записи на стрижку)
	
	29:00 - получение параметров из формы
	
	В sinatra существует специальный хэш с именем params
	Через него происходит передача всех данных из формы (браузер) в сервер для оработки
	
	Для отладки очень удобно использовать такой вывод из метода post
	
	post '/visit' do
		@nik_value = params[:nik]
		...
		erb "Your name is #{@nik_value}" 					# и так же с другими переменными
	end	
	
	Скрипты js обычно вомещают в <hed> блок страницы. В начало страницы пишут скрипты
	чтобы быстрее загрузилась страничка, а потом уже грузились "тяжёлые " скрипты.
	
	У 'css' (СТИЛИ) есть удобная библиотека = 'bootstrap'
	У 'javascript' (ЯЗЫК_НА_ФРОНТЕНД) тоже есть библиотека = 'jQuery'
	
	
	Для работы с 'CSS' и 'JavaScript' ничего подключать не надо.
	
	А для работы с их библиотеками 'bootstrap' и 'jQuery' нужно писать подключение.
	
	Библиотека 'jQuery' расширяет возможности скрипта 'JavaScript'
	Раньше вместо ней использовалась библиотека 'mootools'
	
	Обратите внимание, что подключение стилей и подключение скриптов разлючаются.
	<link href="/bootstrap.css" rel="stylesheet" media="all" />
	<script src="/bootstrap-5.1.3/bootstrap.min.js"></script>
	// Смотри на количество используемых тегов

  !!! ВАЖНО !!!
  Ссылки должны начинаться со слеша, тогда они станут доступны не только из первого
  уровня вложения ('/visit') но и со вложенных ('/visit/edit/3')/
  
	Мы можем прикрепть (написать) свой js в отдельную страницу и тогда он будет работать
	только, когда будет выводится именно эта страница. Вот примет для visit.erb

	<script>
		alert('Hello from visit page!');
	</script>
	//


jQuery - библиотека для js (Расширенная база)	

	Мы уже знаем о трёх серлекторах: nill, '.', '#'
	
	Любой код в jQ начинается со специального кода: $
	$('#aaa').css('background-color','yellow');
	
	Здесь:
	$ - говорит о том, что будет вызван расшиненный пакет javascript а именно jQuery
	  	  
	() - в скобках указывается параметр,
	
	'' - в кавычках пишется т.н. селектор:

					#aaa - если используется #, то в элементе мы указываем id="aaa"
					       (id используется только для одного элемента)
					       
					.bbb - если используем точку, то bbb мы должны поместить в _class=""
								 ( в случае с точкой правило можно применить к нескольким элементам )

		Или так: '<input id="aaa" name=...>'		- для префикса решётка $('#aaa').css
		Или так: '<div class="bbb ..." ...>'		- для префикса точка 	 $('.bbb').css
		
		Скрипт jQ для выбора цвета:
		https://github.com/tkrotoff/jquery-simplecolorpicker
		
		Для работы нужно подключить несколько файлов сос скриптами и CSS
		
		Далее нам нужно добавить код из раздела How to Use - (Как пользоваться)
		
		ВНИМАНИЕ! код этого нового плагина должен загрузится в начале, т.е. указание
		на подключение плагина нудно писать в голове <hed>
		При подключении скрипта в подвале - система не срабатыает. 
		См commits: #14971a0f и #409ec1db
		
		У этого плагина есть ещё ряд настроек, пока с ними не разбирался.
		
		Вызов плагина происходит сразу, как только браузер загрузил строки с вызовом.
		Если select (с цветами) ещё не загружен и первым грузится строки с вызовом
		плагина, сто плагин запустится, но не отработает свою задачу, т.к. у него не 
		будет данныз (select с цветами)
		Поэтому нужно сначала загрузить список цветов (select), а заткм строки с вызовом 
		плагина.
		
		Есть вариант переделать строки вызова следующим образом и тогда эти строки можно
		написать в любом месте нашего файла:
		
		<script type="text/javascript">
		$(function() {
			$('#color').simplecolorpicker();
		})
		</script>
		//
		
		Подробности на странице сайта: https://api.jquery.com/ready/

	
End of Lesson_23
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_24

	Если 'script' находится в <body>, а 'jQuery' загружается в <hed>, то это становится
	ошибкой. 
	
	jQuery - это framework для Javascript. 
	
	Для гарантировано правильного выполнения - нужно писать следующую конструкцию:
	
	<body>
	<script type="text/javascript">
	$(function() {...});
	</script>
	//

	Здесь: код, указанный в фигурных скобках {...} будет выполнятся только тогда, когда
	загрузится вся страница. Об этом есть подробная статья на ХАБР
	
	Здесь мы обернули свой вызов плагина в функцию от jQuery.	
		
	<body> 
	<script type="text/javascript">
	$(function() {
	
			... здесь наш код запуска плагина
			
	});
	</script>
	//	
		
		
	Более наглядный синтаксис имеет следующий вид:
	
	<body> 
	<script type="text/javascript">
	$(document).ready(function() {
	
		...  здесь наш код запуска плагина
	
	})
	</script>
	//	Это аналогичный предыдущему вариант. Он тоже будет раболтать.
	
	Правильная обёртка это $( ... )
	А запись function()
	{
		....
		....                  <- много строк.
		....
	}
	Нужна только для того, чтобы написать много строк.
	
	В Ruby используется:
	
												def name
													...
												end
												
	В JS используется:
												
												function ()
												{
													...
												}
																																	(В ТЕТРАДЬ)					
	Чаще всего нам придётся использовать "обёртку" типа: 
	$(function() {
	
	// Тут я могу написать любой javascript
  // который исполнится после загрузки сраницы
	
	}
	
(!!!)	__________ Чек - Лист (для работы с приложением в gem SINATRA) ________________
	
									1. Запущен Sublime на нужной директории
									2. Запущен ungit
									3. Запущено наше приложение bundle exec ruby app.rb
									4. В браузере открыт наш сайт (localhost:4567)


(!!!) _________________________ Вывод сообщения об ошибке ___________________________

	В файле layout.erb есть такой код:				
					' 
					<%if @error && @error.length > 0 then %>
		          <div class="alert alert-danger"><%=@error%></div>
		      <% end %>
					'
	Если пременная @error определена и её длина больше 0 
		то будет выведена эта переменная 
		
	В разных версиях bootstrap классы (иногда) изменят свой название от версии к версии
	Так класс 'alert-error' изменился на класс 'alert-denger'
	
АТОМАРНОСТЬ КОММИТОВ.
	Очень желательно каждое изменение коммитить отдельно. 	

VALIDATION - 

	1.) simple validation:  (простая валидация)
	
post '/visit' do
  @user_name = params[:user_name].capitalize
  @phone     = params[:phone]
  @date_time = params[:date_time]
  @barber    = params[:barber]
  @color     = params[:color]

  if @user_name == ''												# Простая валидация 
    @error = 'Введите имя (обязательно) !'
    return erb :visit
  end
  
  @title = 'Отлично!'
  @message = "Спасибо вам, #{@user_name}. Будем ждать Вас к #{@date_time}."

  erb :message 
end	

	Аналогично можно написать проверки и для остальных параметров, и это будет работать
	Но есть возможность упростить этот код. Сделаем РЕФАКТОРИНГ.
	
	РЕФАКТОРИНГ - это улучшение кода. Мы хотим сделать так, чтобы он был более понятен 
	для разработчиков.

	2.) Если параметров много, то применяется проверка данных по выбранным элементам
	PARAMS[] Причём проверка проходит с присвоением специальной переменной @error 
	значения, соответствующего имени параметра, который не был введён в форме (erb)
	
	Код по валидации будет иметь следующий вид:
		
post '/visit' do
  @user_name = params[:user_name].capitalize
  @phone     = params[:phone]
  @date_time = params[:date_time]
  @barber    = params[:barber]
  @color     = params[:color]

	#        key     =>    value
	hh = {:usre_name => 'Введите Ваше имя',
				:phone => 'Введите телефон',
				:barber => 'Введите дату и время' }
	
	hh.each do |key, value|
		# если параметр (пришёл из браузера) пустой, то ...
		if params[key] == ''
			# ..., то переменной @error присвоить value из хэша hh
			# (а value из хэша - это сообщение об ошибке в переменной под именем key)
			# т.е. переменная @error теперь станет иметь - текст сообщения об ошибке
			@error = hh[key]
			
			# вернуть представление vivsit (с сообщением об ошибке)
			return erb :visit
		end
	end
  
  @title = 'Отлично!'
  @message = "Спасибо вам, #{@user_name}. Будем ждать Вас к #{@date_time}."

  erb :message 
end	

	Если есть хотябы одна перемнная с неприсвоенным значением, то данный код отправит 
	пользователя обратно на форму (erb :visit) для повторного вввода данных.		
		
		
	Чтобы форма "запоминала" уже введённые значения нужно добавить дополнительный пра-
	метр с именем value="bla-bla-..." внутрь тега <input ... >
	Введённое значение будет отображаться в форме и будет отправлено на сервер при 
	отправке всей формы (по нажатию кнопки) 
	Значение этого параметра мы можем задавать с помощью одной из переменных 
	(например @phone) используя известный формат '<%= ... %>' 
	
	Это синтаксис подстановки перемнных из контроллера ruby в html-код страницы
	
	Ещё вариант валидации введённых параметров:
	
  @error = hh.select{|key,_| params[key]==""}.values.join(", ")
  
  return erb :visit if @error && @error.length > 0
					
	Здесь все ошибки выводятся сразу, указываются все поля, в которых не хватает данных
	
	Если приложение имеет множество url в которых вводится большое количество параметров
	то нам пришлось бы писать эти команды в каждом контроллере. 
	Для облегчения кода очень удачно будет вынести этот код в отдельный метод и вызывать
	его при необходимости с конкретными параметрами из каждого контроллера.

	Использование REDIRECT вместо RETURN не позволит передать уже введённые ранее 
	переменные в форму, т.е. все значения придётся вводить заново.
	
	C D N - Content Delivery Network - Сеть Доставки Конткнта
	Это сеть серверов, с которых можно загружать контент (например bootstrap) 
	Причём эти сервера расположены в различных частях мира и различные пользователи 
	нашего приложения находясь в США, Европпе и Китае загружают к себе контент с 
	наиболее близкого сервера CDN - Это ускоряет загрузку первой страницы сайта.
	
	В нашем случае мы используем загрузку контента с локального хоста. Это не всегда
	продуктивно, особенно если пользователи сайта будут находится в отдалённых частях
	света.
	
	Для предотвращения етого обычно используют например: 'boostrap CDN'
	
	Это ещё удобно и тем, что если Вы уже загрузили файлы bootstrap в память браузера и
	затем переходите на другой сайт с тем же bootctrap то эти файлы уже кэшированы и 
	повторная загругка не потребуется, а это значительно сократит время открытия сайта.
	 
	ПЛЮС сокращается трафик пользователя (и сервера).
	
	Другая строна вопроса. Если нам нужна 'супер-надёжность' - лучше использовать ло-
	кальные файлы на своём сервере.
	

GITHUB - настройка 
	
	> git config --global user.name "Rubynushka"
	> git config --global user.email "rubynushka@gmail.com"
					
	Разберёмся с этим позже.
	 
ОТПРАВКА ПОЧТЫ со страницы contacts

		https://stackoverflow.com/questions/2068148/contact-form-in-ruby-sinatra-and-haml
	При настройке в параметрах gmail нужно поставить галочку, чтобы разрешить исполь-
	зование специального порта '587'.
	
					
End of Lesson_24
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_25

GITHUB 

	Поддерживает два способа авторизации:
	1. По логину и паролю (неудобно тем, что нужно постоянно водить логин и паролль)
	2. Через ssh ключ 

	Нужно сгенерировать ключи (в windows есть в специальный файл ssh-keygen.exe)
	Его можно найти в по адресу C:\Program file (x86)\Git\bin\

	Переход в домашнюю директорию > cd %HOME%
	На C:\Users\You_name\ - домашняя директория  
	там есть (должен быть) каталог .ssh 
	Запомним этот путь C:\Users\You_name\.ssh 

	После запуска Программа спросит путь, куда сохранить пару ключей. 
	Нужно указать этот путь и добавить ещё \id_rsa

	Программа попросит ввести passphrase (паротльная фраза). Её вводить не надо, иначе 
	придётся её вводить постоянно. Это доволнительная защита, но она тянет за собой 
	дополнительное действие (при каждом обращении к ключу) для нас.
		Обращение к ключу будет при каждом коммите.
 
	Программа выведет:
	'
	Your identification has been saved in C:\Users\Your_name\.ssh\id_rsa.
	Your public key has been saved in C:\Users\Your_name\.ssh\id_rsa.pub.
	The key fingerprint is: 
	2e:9b:6f:bd:a5:1e:ca:16:97:b6:f7:fd:56:42:fc:b4 Your_name@YOUR_NAME
	'

	В нашей папке появилось два файла:
	id_rsa
	id_rsa.pub

	Нам нужен ключь: id_rsa.pub - публичный ключь

	Скопируем содержимое этого файла в буфер обмена.
	

	Переходим в gitbub, логинимся с помощью пароля, затем идём в раздел settings/ssh
	Далее жмём на кнопку 'Add SSH key' - (добавить ключ)
	Вводим в поле название ключа (эта запись толко для Вас, ключей может быть несколько)
	А в поле 'Key' вставляем скопированное содержимое публичного ключа.
	Осталось нажать 'Add key'
	Теперь вводим свой пароль и подтверждаем это.

	Всё, публичный ключ введён.

	Проверим работу ключа. Создадим тестовый репозиторий.
	После создания репозитория скопируем ссылку из ssh позиции и 
	клонируем свой новый репозиторий себе на машину.

	При первом клонировании программа git спросит верить ли этому ключу, 
	который прислали с адреса host 'github.com'
	Мы отвечаем 'yes' - (это же наш ключ)
	Дальше такой вопрос уже не будет задаваться программенй.  

	В выводе будут два Warning. В дальнейшем их уже не будет.

	Добавьте новывй тестовый файл рядом с .git папкой. Например: README.md
	Делаем коммит а ungit - должно всё сработать (это коммит на локальной манине)
	Далее встаём на 'master' (появится кнопка 'push') 
			и жмём её (это будет отправка изменений на сервер github)


gem sqlite3

	База данных - это хранилище с нашими данными. Данные - упорядочены.
	Для работы с данными из БД нам нужно знать язык БД.
	Для организации БД нам нужно дать немного больше информации о том:
		как будет хранится информация,
		в каком формате будет зранится информация
		какова максимальная длина информации
		каков формат информации
		... и так по каждому плю

	Больше времени на организацию БД, но ЗНАЧИТЕЛЬНЫЙ выигрыш по времени при получении
	требуемой информации из БД. 

	Речь идёт о СУБД - Система Управления Базами Данных - со специальным языком БД

	в мире существует много различных БД - много:
								sqlite3
								mysql
								postgres
								ms sqlserver
								oracale

								последние две - платные БД, но они значительно лучше бесплатных.

	NOSQL - мы проходить их не будем.


ЯЗЫК ЗАПРОСОВ - SQL - S Q L - (структурированный язык запросов)								

	Изначально язык был разработан для бухгалтеров. Структура очень тривиальная.

	SELECT * FROM Cars - выбрать все записи из таблицы 'Автомобили'

	SELECT * FROM Cars WHERE price>1000  - то же, ... где цена больше 1000$

установим sqlite3 - откройте ссылку https://sqlite3.org/download.html

	под windows Нужно скачать два архива: 
		- sqlite-shell-.......zip	
		- sqlite-dll-.........zip

	распакуйте архивы	
	скопируйте эти два файла с помощью команды:

	> copy * %WINDIR%\System32\

	Для проверки перейдите в другую папку и введите в консоле команду:
	> sqlite3 --version

	Теперь давайте установим специальный gem sqlite3
	> gem install sqlite3


	Для обучения очень удобно пройти на хороший ресурс: www.sqlishard.com	- SQL is Hard

	type a query here - введите сюда запрос, вводим следующую запись
	SELECT * FROM Customers     - выбрать все записи из таблицы Customers (покупатели)
	Далее жмём 'execute' - выполнить. И мы видим результат - таблица с покупателями.

	В таблице есть четыре столбца. Ещё говорят ЧЕТЫРЕ ПОЛЯ.
	Для вывода двух полей (id, FirstName) вводим следующую команду.

	>> SELECT id, FirstName FROM Customers

	порядок столбцов соблюдать не обязательно.  
	Слова SELECT и FROM - не обязательно писать большими буквами (раньше было нужно)

	>> SELECT * FROM Customers WHERE id = 5

	Нужно понимать что происходит в БД (behind scenes - за кулисами)

	Желательно иметь графическое приложение для работы с БД, чтобы видеть всё что 
	происходит в нашей БД. Будем создавать таблицы, соединять их связями и делать
	запросы к БД

	Создаём таблицу Cars.
	Создаём столбец. Первый столбец обычто это id - идентификатор (уникальный)
		Тип INTEGER, PRIMARY KEY, AUTOINCREMENT

CREATE TABLE "Cars"("id" INTEGER PRIMARY KEY AUTOINCREMENT, 
                    "Name" VARCHAR, 
                    "Price" INTEGER)

	INSERT INTO Cars (id,Name,Price) VALUES (1, 'BMW', 10000)

	но у нас стоит AUTOINCREMETN по полю id тогда запись превратится в 

	INSERT INTO Cars (Name,Price) VALUES ('BMW', 10000)	

	Файл ___,sqlite можно просмотреть в обычном текстовом редакторе, там будут видны 
	некоторые данные (Напрмер текстовые)

	(!!!) Название файла не имеет значения. А расширение можнл выбрать .db
	типа test_data.db	или freelanser.db 

	Для удобной работы очнь желательно иметь графическую программу (Database Manager) 
	Так будет удобно формировать db редактировать и представлять в её уме 
	(визуализировать).

CONSOLE SQLITE3

	Вход в консоль через терминал:
	> sqlite3 test.sqlite3 								(здесь teat.sqlite3 - это файд БД)
	В результате будет такое приветствие: sqlite>

	sql> .exit			- выход из консоли sqlite3

	Дальнейшая информация будет очень полезна, хоть это немного сложнее чем "в графике"
	(!!!) Для выполнения ЗАПРОСА необходимо завершать ввод команды символом ';'
	По Enter - команда не выполняется, а ждёт продолжения данных.
	Если забыли ввести ; то просто введите ; и нажмите Enter.

	sql> .tables 		 							- выводит список таблиц в нашей БД

	sql> SELECT * FROM Cars;    	- выводит все столбцы (поля) из таблицы Cars

	sql> .mode column							- предписывает выводить таблицы в выровненные солонки

	sql> .headers on							- выводит названия полей (шапка таблицы)

	sql> SELECT Name, Price FROM Cars;  	- вывести эти два поля (только)

	sql> INSERT INTO Cars (Name, Price) VALUES ('Zaz', '500') 	- добавление записи

	sql> CREATE TABLE "Cast" ("Id" INTEGER PRIMARY KEY AUTOINCREMENT, 
														"Name" VARCHAR,
														"Tel_Num" VARCHAR,
														"Sex" VARCHAR
														);
	CREATE TABLE "Cast" ("Id" INTEGER PRIMARY KEY AUTOINCREMENT, "Name" VARCHAR, "Tel_Num" VARCHAR, "Sex" VARCHAR);

	Запросы пишутся БОЛЬШИМИ БУКВАМИ - это легаси фишка. Стиль сохранисля от старых
	версий, топерь можно писать и маленькими буквами.

  Как обращатся к БД из программы?
	В программе пише следующие строчки:

listing do	
	require 'sqlite3'
	db = SQLite3::Database.new 'test.db'
	db.close
listing end	

  Эта короткая программа должна отрабатывать без ошибок и ничего не выводить на экран
  Теперь добавим обращение в БД


  Добавим дополнительные строки для ввода новой записи и вывода содержимого БД
  
listing do	
	require 'sqlite3'
	db = SQLite3::Database.new 'test.db'
		
	db.execute "INSERT INTO Cars (Name, Price) VALUES ('Jaguar', 777777)"
	 
  db.execute "SELECT * FROM Cars" do |car|
		puts car
		puts "==="
	end
	
	db.close
listing end

	С уществует возможность получения доступа к БД через ввод параметра, который 
	передаётся в команду БД. Так пользователь может изменить формат команды и
	сбросить (стереть) все данные из БД.

	Для предотвращения этого нужно изучить специальные техники (они уже есть)


End of Lesson_25
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_26

	Конструкция типа:
	______ ? _______ : ________

	a = ...
	b = ...
	#              (true)    (false)
	a + b == 4 ? _________ : __________

	Если условие переж вопросом ВЕРНО, то выполняется действие true
														НЕВЕРНО, то выполняется действие false

	Это равносильно следующей конструкции:

	if a + b == 4
		_________ #(true)
	else
		_________ #(false)
	end

	но первая конструкция значительно короче второй.

"
<td>
	<select class="form-select" aria-label="Default select example" name="barber">
	  <option <%= @barber == nil ? 'selected ' : ''%>>Open this select menu</option>
	  <option <%= @barber == 'Katya' ? 'selected ' : ''%>value="Katya">Katya</option>
	  <option <%= @barber == 'Lena' ? 'selected ' : ''%>value="Lena">Lena</option>
	  <option <%= @barber == 'Masha' ? 'selected ' : ''%>value="Masha">Masha</option>
	</select>
</td>
"
	В примере выше в форму добавлены дополнительные записи типа 
	'
	<%= @barber == 'Katya' ? 'selected ' : ''%>
	'
	которые проверяют @barber = значению в текущей строку (выбрана ли была эта строка)
	если ДА - то поставь сюда слово 'selected ', если НЕТ - то ничего не ставь.

	Исключение - первая строка (без value) 
	Если @barber ещё не выбрали ранее, то ОТМЕТИТЬ эту строку словом 'selected ', 
	а иначе (уже был выбор), то сработает один из ниженаписанных условий и 
	выбранная строка получит признак 'selected '.


	datetime - может быть зарезервированным словом в БД (могут быть ошибки)
	лучше использовать datestamp 

	Новая таблица создаётся следующей командой:

	CREATE TABLE `Users` (
	`id`	INTEGER PRIMARY KEY AUTOINCREMENT,
	`username`	TEXT NOT NULL,
	`datastamp`	TEXT NOT NULL,
	`phone`	TEXT NOT NULL,
	`barber`	TEXT NOT NULL,
	`color`	TEXT NOT NULL
);

	Если попытаться создать эту таблицу ещё раз, то будет ошибка.
	Для решения этого вопроса нужно добавить одну фразу в исходную команду.
	IF NOT EXISTS - ЕСЛИ НЕ СУЩЕСТВУЕТ

	CREATE TABLE IF NOT EXISTS `Users` (
	`id`	INTEGER PRIMARY KEY AUTOINCREMENT,
	`username`	TEXT NOT NULL,
	`datastamp`	TEXT NOT NULL,
	`phone`	TEXT NOT NULL,
	`barber`	TEXT NOT NULL,
	`color`	TEXT NOT NULL
);

	Такая команда, если её вводить несколько раз не приводит к ошибке.
	Это можно поробовать в sqlite3

	sql> CREATE TABLE IF NOT EXISTS "User" ...

	sql> .tables																- показать список таблиц
	sql> drop table Users												- удалить таблицу Users
	sql> .tables
	sql> CREATE TABLE IF NOT EXISTS "User" ...	- создать таблицу
	sql> CREATE TABLE IF NOT EXISTS "User" ...	- создать таблицу
	sql> .tables

	sql> CREATE TABLE IF NOT EXISTS "User" ...
Эту команду (СОЗДАНИЕ ТАБЛИЦЫ) очень удобно использовать при инициализации приложения

	В sinatra есть специальная команда, которая запускаетмя при иницализации приложения

	configure do 
		... 
	end

	configure do
		@db = SQLite3::Database.new 'barbershop.db'
		@db.execute "CREATE TABLE IF NOT EXISTS 
			`Users` 
			(
				`id`	INTEGER PRIMARY KEY AUTOINCREMENT,
				`username`	TEXT NOT NULL,
				`datastamp`	TEXT NOT NULL,
				`phone`	TEXT NOT NULL,
				`barber`	TEXT NOT NULL,
				`color`	TEXT NOT NULL
			) "
	end

	@db = SQLite3::Database.new 'barbershop.db'  - создать подключение к файлу с данной
	базой данных, а если её нет, то создать её.

	А затем, создать таблицу с параметрами, если такой таблицы нет.
	Точку с запятой можно не ставить, т.к. execute подразумевает, что будет выполнена
	одна команда.

	Есть очень хорошая ссылка по SQLite3-Riby
	http://rdoc.info/github/luislavena/sqlite3-ruby

	Плагин для показа ДАТЫ и ВРЕМЕНИ
	https://github.com/xdan/datetimepicker

	Чтобы скачать отдельный файл кликаем по нему в ГИТХАБЕ далее жмём кнопку RAW
	наш файл откроется в браузере (только файл) НУЖНО скопировать адресную строку.

	Открываем терминал в папке, куда будем закачивать этот файл и в терминале набираем
> wget https://raw.githubusercontent.com/xdan/datetimepicker/master/jquery.datetimepicker.css
> wget https://raw.githubusercontent.com/xdan/datetimepicker/master/jquery.datetimepicker.js
	готово.

	Если будут проблемы с загрузкой, то можно ввести после wget --no-check-srtificate

	Чтобы добавить плагин к сайту нужно:
	1. скачать файлы плагина ___.css и ___.js
	2. прописать пути к ним с именами в файле layout.erb в раздел <head>
	3. в файле представления, где используется этот плагин нужно (в данном случае)
	указать id="datetimepicker" к текстовому полю, в котором вводится дата и время
	а в разделе <script> этого же файла прописать запуск скрипта сразу после загрузки 
	страницы, причём, обёрнутую в $(function(){ ... }) см ниже:

<script>	
$(function() {
  // тут я могу написать любой javascript код, который
  // выполнится сразу после загрузки страницы
  $('#datetimepicker').datetimepicker();
})
</script>
//

	Теперь давайте выведем значения из БД
	db = SQLite3::Database.new 'barbershop.db'
	
	db.execute 'select * from Users' do |row|
		puts row
		puts '=================='
	end
	Самый простой вывод данных	

	row - это массив, и обратится к элементу массива можно по индексу.
	Попробуем вывести все имена

	db = SQLite3::Database.new 'barbershop.db'
	
	db.execute 'select * from Users' do |row|
		puts row[1]
		puts '=================='
	end

	а теперь имена и даты

	db = SQLite3::Database.new 'barbershop.db'
	
	db.execute 'select * from Users' do |row|
		print row[1]
		print "\t\t"
		puts  row[3]
		puts '=================='
	end

	тут нужно знать какой номер параметра к какому полю соответствует. Поэтому 

	Работать с массивом не очень удобно, особенно когда изменяется запрос 
	(выбранные в запросе поля я)
	В SQLite3 есть возможность выводить результат в виде ХЭША вместо МАССИВА.	
	
	db = SQLite3::Database.new 'barbershop.db'
	db.results_as_hash = true 									# один раз указали для всех запросов
	
	db.execute 'select * from Users' do |row|
		print row['username']
		print "\t\t"
		puts  row['datastamp']
		puts '=================='
	end
	Теперь row - это хэш. Использование Хэша делает программу более читабильной.

	'SELECT * FROM Users order by id desc '
	Выбрать всё из таблицы Users c сортировкой по id в порядке убывания.


End of Lesson_26
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_27

	Домашку хотелось бы увидеть ...

HTML tage <table>

	'
	<table>
	
		<tr>                                буква r здесь - это Row (СТРОКА)
			<td> ... </td> 									 	td - это тэг Данных таблицы 
			<td> ... </td>	                  вторые данные 
			<td> ... </td>                    третьи данные  
			...
		</tr>																КОНЧИЛАСЬ ПЕРВАЯ СТРОКА (Row)	
			
		<tr>                                ВТОРАЯ СТРОКА (Row)
			<td> ... </td>										первые данные (во второй строке)
			<td> ... </td>										вторые данные	
			...
		</tr>	                              КОНЧИЛАСЬ ВТОРАЯ СТРОКА

		...                                 ТРЕТЬЯ СТРОКА, и так далее ...
		
	</table>
	'	

	Внутрь тэга <table> можно добавить 'class=' для применения стилей к таблице.

	Создадим таблицу из трёх строк, в каждой строке будет по два элемента данных.

	'
	<table class="table">
	
		<tr>
			<td> aa </td>
			<td> bb </td>
		</tr>
	
		<tr>
			<td> aa </td>
			<td> bb </td>
		</tr>
		
		<tr>
			<td> aa </td>
			<td> bb </td>
		</tr>
		
	</table>
	'
	Готово.

	ВАЖНО. 
		Нужно всегда стараться держать свой кодв чистоте. А именно, 
		в серверной части программы должна быть отражена "логика" и не должно быть 
		действий по оформлению, 
		а в браузерной части нужно стараться оставлять только оформительскую часть и
		максимально исключить логику.

	Для вывода списка записавшихся клиентов нужно в сервеной части программы создать 
	метод, который будет делать запрос к БД и результат запроса отправлять в браузер
	для отображения списка (таблицы)  

get '/showusers' do
	db = get_db
	@results = db.execute 'SELECT * FROM Users ORDER BY ID DESC'

	erb :showusers
end

	Примечание: 'ORDER BY ID DESC' - это "Порядок по id нисходящий"
	По русски будет как: "Сортировать в поряждке уменьшения по полю id".

	Через переменную @results данные будут переданы из BACKEND в FRONTEND для показа.
	Для отображения информации мы опять воспользуемчя специальным синтаксисом.

	'
	<%= ... %> Результат выражения ... будет выведен в этом место HTML кода
	'

	'
	<% ... %>  Результат выражения ... будет ВЫЧИСЛЕН здесь, но НЕ БУДЕТ ВЫВЕДЕН ЗДЕСЬ
	'

	Используя это свойство синтаксиса создадим представдение showusers.erb
	'
	<table class="table">
	
		<% @results.each do |row| %>
		
			Something! 
		
		<% end %>
	
	</table>
	'

	Здесь выражение ... будет повторено столько раз, сколько строк будет в переменной 
	@results, а это как раз количество записей (или количество записавшихся клиентов) 
	"Эт! Круто!"

	Дорабатываем представление - формируем 5 данных в строке, а строки будут выводится
	через последовательный перебор всез записей (с помощью .each) из переменной @result 
	'
	<table class="table">
	
		<% @results.each do |row| %>
		
			<tr>
					<td><%= row['username'] %></td>
					<td><%= row['phone'] %></td>
					<td><%= row['dates'] %></td>
					<td><%= row['barber'] %></td>
					<td><%= row['color'] %></td>
			</tr>
		
		<% end %>
	
	</table>
	'

	Полный формат таблицы состоит из двух частей (головы и тела)
	'
	<table>
			<thead>
						...
			</thead>
			
			<tbody>
						...
			</tbody>
	</table>
	'

	В целом, формат будет выглядеть вот так:
	'
	<table>
			<thead>
						<tr>													Row (head)
								<th> ... </th>
								<th> ... </th>
								<th> ... </th>
								...
						</tr>
			</thead>
			
			<tbody>
						<tr>													Row-1 (body)
								<td> ... </td>
								<td> ... </td>
								<td> ... </td>
								...
						</tr>
						<tr>													Row-2 (body)
								<td> ... </td>
								<td> ... </td>
								<td> ... </td>
								...
						</tr>
						...
			</tbody>
	</table>
	'
	ВНИМАНИЕ!  Тэги строк в "голове" и в "теле" таблицы - это одинаковый тэг: <tr>
	А вот внутри них теги различабтся:
				Для "головы" это будет тэг <th>  - (table head) - заГоловок таблицы
				Для "тела"   это будет тэг <td>  - (table data) - Данное таблицы

	Вот так!

	Как проверить, есть ли в таблице конкретная запись.
	Можно сделать запрос, который отбкрёт все записи по условию.
	"SELECT * FROM Users WHERE usernsme='John'" 

	В нашем случае нужно создать метод, которому будет передаваться база банных в пере-
	менной 'bd' и имя элемента (который мы будем искать). Имя быдет передпно в 'name' 
	def is_barber_exist? db, name
		db.execute("SELECT * FROM Barbers WHERE name=?", [name]).lenght > 0 
	end

	Результатом этого запроса будет набор данных или ничего (nil) 
	Нужно превратить это набор в (false,true) - логическую переменную
	Свмое простое - это проверить длину результата запроса:

	Можно, конечно, всю запись разделить на несколько строк, но очень часто многие 
	преобразования сразу пишут в одной строке (чтобы получить сразу результат).

	Строчка выполняется за одну операцию.

	Длина этого запроса будет равна количеству записей, полученных в результате запроса

	Сделаем ещё один метод. Seed - устоявшееся слово в программированиее и означает оно
	- НАПОЛНИТЬ.  В нашем контексте - наполнить базу данных.

	def seed_db db, barbers
		barbers.each do |barber|
			if !is_barber_exist? db, barber
				db.execute "INSERT INTO Barbers ('name') VALUES (?)", [barber] 
			end
		end
	end
	Логика работы этого метода проста:
	Перебираем по очереди массив имён парикмахеров.
	Проверяем (если парикмахер НЕ есть в БД - то записываем данного парикмахера в БД) 
	Иначе, бкрйм следующего парикмахера по списку.
	Данное наполнение данными обычно происходит во время инициализации 
	в методе 
	configure do
		...
	end

BEFORE - в sinatra

	В sinatra есть особый синтаксис которым можно описать участок кода, который будет 
	выполнятся всегда беред любым методом 
	def something 
	end

	Пишем премер данного синтаксиса
	before do
		db = get_db
		@barbers =  db.execute 'SELECT * FROM Barbers'
	end
	Здесь переменная @barbers - будет доступна во всех view нашего приложения.

	Такой мехонизм часто используется для отображения данных о пользователе, данные о
	котором должны быть доступны на каждой страницы сайта.

	МЕХАНИЗМ НАПИСАНИЯ СЛОЖНОГО КОДА
	Нужно заменить это
 "<option <%= @barber == nil ? 'selected ' : ''%>>Open this select menu</option>
	<option <%= @barber == 'Katya' ? 'selected ' : ''%>value="Katya">Katya</option>
	<option <%= @barber == 'Lena' ? 'selected ' : ''%>value="Lena">Lena</option>
	<option <%= @barber == 'Masha' ? 'selected ' : ''%>value="Masha">Masha</option>"

	на использование данных из @barbers - списка парекмахеров.
	Т.е. жёстко просисанные парамерты в HTLM нужно заменить на данные, 
	которые будет приходить из БД. (данные могут быть динамичными)

	1. Закоментируем старый код

	2. Создадим цикл по списку парикмахеров и попробуем вывести только имя
	"<% @barbers.each do |item| %>
	   <option><%= item['name'] %></option>
 	 <% end %>"
			Для проверки - ЗАПУСТИМ ПРИЛОЖЕНИЕ
			Еси всё хорошо, - продолжаем работать ...
			
	3. Добавляем новые параметры в код
	"<% @barbers.each do |item| %>
	<option <%=  %> ><%= item['name'] %></option>
	<% end %>"
		Для динамического появления признака 'selected' добавляем Ruby-код
	"<% @barbers.each do |item| %>
	<option <%= @barber == item['name'] ? 'selected : '' %> ><%= item['name'] %></option>
	<% end %>"
		Для проверки - опять ЗАПУСТИМ ПРИЛОЖЕНИЕ
		Если 'selected' подставляется, - продолжаем работать дальше ... 

	4. Теперь нужно добавить значения для этого поля (в рамках используемой формы)
	'<% @barbers.each do |item| %>
	<option value=<%=item['name']%> <%= @barber == item['name'] ? 'selected':''%>>
	<%= item['name'] %></option>
	<% end %>'
			ОПЯТЬ Для проверки - ЗАПУСТИМ ПРИЛОЖЕНИЕ
			Если всё работает (и исходный код соответствует ожидаемому) - можно продолжать 
			работать дальше ...

	 5. Теперь можно удалить старый код и закоммитить новую версию.


	ВОТ ТАК, МАЛЕНЬКИМИ "ПЕРЕБЕЖКАМИ" МЫ ПОЛУЧАЕМ СЛОЖНЫЙ КОД, КОТОРЫЙ РАБОТАЕТ.

	Интересное замечание: Если к единственной строке в цикле притянуть '<% end %>'
	из следующей строки, то полученный код будет идти строка к строке, а не 
	через строку.
 
	Очень важно поддерживать актуальную структуру БД особенно при откатах на предыду-
	щие версии.

	У sinatra мы знакомы с двумя методами: 
																								congigure do
																								end

																								before do
																								end
	
	Первый метод запускается при конфигурации приложения (или перезапуске)
	Второй запускается перед каждым вызовом любого Url сайта (get, post)
	
	 
End of Lesson_27
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_28

  Сделаем урок - повторение.
  
  Создадим новое приложение (Сайт)
  
  1. Клонируем чистый шаблон sinatra-bootstrap из репозитория
			> git clone https://github.com/ro31337/sinatra-bootstrap-clean.git
  
  2. Создаём папку, которая называется так, как наш проект 'MySite'
  
  3. Далее копируем все файлы (за исключением .git) из склонированного шаблона (п.1)
  в нашу новую папку, созданную в п.2
  Дальше sinatra-bootstrap-clean нам уже не нужен.
  
  4. Теперь нужно инициализировать нашу новую папку (с файлами) в git
  Для этого в папке приложения запускаем 
  > ungit
  а в открывшемся окне браузера выбираем уоманду "Make 'Projecrs/MySite' a repository"
  
  5. Делаем первый коммит с именем 'init' в ungit в браузере 
  
  6. Теперь нужно залить его на сервер github.com
  для этого на сайте сервера https://github.com под свом аккаунтом создаём новый 
  репозиторий, имя ему даём токое-же как и у названии нашеё папки (см. п.2)
  
  Никаких файлов добавлять не нужно, просто создаём пустой репозиторий с именем.
  
  7. Далее нам нужно связать репозторий, который мы создали на своём компьютере 
  (там есть один коммит 'init') с пустым репозиторием, который на сайте.
  
  Это можно сделать через интерфйс на сайте, но можно и через команды в консоле:
  > git remote add origin https://github.com/ro31337/MySite.git
  > git push -u origin master
  
  Теперь на сервере есть копия наших файлов с локальной машины.
  
  Дальше можно работать в приложением. 
  
SUBLIME TEXT

  Чтобы убрать (или показать) боковую панельку нужно использовать комбинацию клавиш
  <Ctrl>+K, B  - ещё раз - обратный эффект.
  
	При создании страниц часто используют заглушку (файл с одной строкой)
	Такой коммит обычно называют "Add stub for /new" (stub - заглушка)
	
	В форму ввода данных можно ввести специальное поле с широким текстовым полем
	'
	<texarea class="form-control" rows="3"><?textarea>
	'
	3 - здесь, это количество строк в этом контроле.
	
	У каждой формы должны быть два обязательных атрибута, это:
	- action="" 
	- method=""
	Выглядит это так: 
	'
	<form action="/create" method="post" ... >
		...
		<button ...>Submit</button> 
	</form>
	'
	actilon -> указывает на имя процедуры, которая обрабатывает данные этой формы  
	method  -> это способ отправки данных, может быть или GET или POST 
							(в упрощённом варианте) 
	
	Существует ещё атрибут HTML 'placeholder=' - используется для выввода 
	в текстовое поле нашей формы специального текста-подсказки 
	причём, непосредственно в поле ввода данных формы. 
'
<textarea class="form-control" rows="6" placeholder="Type post text here"></textarea>
'
	При вооде данных в такое поле наше серое изображение исчезает и набарается текст.
	Это удобно для создании уточняющих подсказок для пользователей сайта. 
	Часто этот атрибут используется для обозначения формата вводимых данных или
	требаваний к ним.
	
	Для изменения ширины поля <textarea ...> нужно добавить ещё один атрибут 
	'
	style="widthy: 400px" 
	'
	
	Для принятия данных из формы нужно добавить метод, который мы указали в атрибуте
	... action="" ...
	
	В этом методе мы можем получить значения, которые были введены в поля ввода формы.
	Доступ к этим полям возможен через специальный (зарезирвированный) хэш 'params'
	с поледующим указанием имени того контрола, который нам нужен. 
	Обычно для этого испльзуют сивол (указание с двоеточием) :name
	ВАЖНО!!! - Каждое поле формы должно иметь своё уникальное имя.
	Это имя параметра в файле формы используется - без двоеточия, 
	а в методе, который обрабатывает данные этой формы - с двоеточием.
	
	def '/create' do
		content = params[:my_text]
		
		erb "You typed: #{contents}"
	end

	Для использования БД в нашем приложении нужно добавить gem sqlite3  по команде
	> gem install sqlite3
	и конечно установить саму базу данных с операционнцю систему. (это отдельное дело)
	
	Когда гем установлен нужно добавить его в основгую программу
	require 'sqlite3' 
	это требавать sqlite3
	
	Для работы с БД нам потребуется отдельная ГЛОБАЛЬНАЯ переменная, которая будет 
	существовать во всех методах обработки запросов И звать её будем @db (data base)
	
	Для её появлени будем использовать особый метод befor который будет автоматически
	вызываться перед каждым вызоыом процедур обработки GET или POST и в этом
	befor мы будем получать нашу ГЛОБАЛЬНУЮ перемнную.
	
	def init_db
		@db = SQLite3::Database.new 'Our_db_mane.db'
		@db.results_as_hash = true
	end
	
	before do
		init_db
	end
	
	Инициализация будет проходить с помощью обращения к пространству имён 'SQLite'
	в которов есть Класс 'Database' у которого (в свою очередь) есть метод 'new'
	
	Он принимает всего один параметр - имя файла нашей базы данных ('Out_db_name.db')
	
	Ещё здесь имеет место добавить ещё одну особую запись, 
	котрая будет позволять получать результат запросов как ХЭШ. (а не массив)
	Так будет удобно к ним обращатся (но это не обязательно)
	
	При запуске любого метода для обраблткт GET POST запроса будет предварительно 
	запущен метод before, который в сою очередь стартонёт метод init_db 
	А в последнем методе будет создан файл (если такого ещё нет) в корневой папке 
	приложения и это будет пустой файл 0kb для базы данных.
	
	Создадим специальный метод configure 
	который будет запускаться при каждом старте нашего приложения.
	Он нужен для создания таблиц (если они ещё не созданы).
	
	Чтобы создать таблицу в этом файле нужно выполнить команду для создания таблицы
	Для уточнения этой команды очень удобно использовать графическую программу для 
	работы с БД.
	
	Например для создания таблицы из трёх полей команда буде выглядеть так:
	'CREATE TABLE Posts ("id" INTERGER PRIMARY KEY AUTOINCREMENT, "create_data" DATE,
	"content" TEXT )'
	
	Вставляем эту коменду в метод 'congigure ... end'
	
	configure do
		init_db
		@db.execute 'CREATE TABLE IF NOT EXISTS Posts 
		(
			id INTERGER PRIMARY KEY AUTOINCREMENT, 
			create_data DATE,
			content TEXT 
		)'
	end
	Названия полей (столбиков) можно писать без кавычек.
	
	Ещё нужно добавить очень важную добавку, чтобы таблица не пересоздавалась вновь, 
	если она уже создана.
	
	ВАЖНО!!! При конфигурации (создании таблицы) мы уже должны иметь переменную @db
	но она появляется только при вызове before, который сейчас не может быть вызван
	Для решения этого вопроса нужно перед созданием таблицы вызвать процедуру 
	инициализации БД init_db
	
  Теперь при запуске приложения будет создана таблица. 
  
  И так, мы получаем введённый параметр из формы через POST запрос и присваиваем его 
  перемнной content с помощью хэша с зарезервированным названием params
  Но пользователь мог отправить пустую форму, а этого не должно быть.
  
  Сделаем проверку на пустоту. Т.е проверим, что введённое значение content должно 
  быть не пустым, другими словами (не должно равнятся 0 по длинне значения)
  
post '/new' do
  # получаем значение из POST-запроса
  content = params[:content]
    
  if content.length <=0  # делаем проверку на "пустое значение" параметра
    @error = 'Type text here'
    return erb :new
  end
  
  erb "You typed: #{content}"
end  

  Здесь, если срабатывает условие "пустое значение", то перемнной @error присваивается
  текст с сообщением о данной ошибке. 
  А дальше выполнение передаётся в представление erb :new
  
  Текст сообщения об ошибке выводится в специальном окне с подсветкой.
  
  Для выполнения записи в базу использем колманду sqlite
  
  sql> INSERT INTO Posts (content, create_date) values ('Something', datetime());
  
  Здесь:
  datetime() - это функция, которая берёт данные из сисемного врнмени компьютера.
  Время будет не месное, а по Гринвичу (GMT).
  для проверки (как записалось это в таблицу Posts в БД) можно ввести запрос к БД
  
  sql> SELECT * FROM Posts;
  1|2014-09-11 18:55:21|Something
  
  sql> .mode column
  sql> .header on
  
  Теперь вывод будет в более читабильной (humanly) форме
  sql> SELECT * FROM Posts;
  id         created_date         content
  ---------- -------------------  -----------
  1          2014-09-11 18:55:21  Something
  
  В нашем приложении мы будем использовать вышеописанный код:
  INSERT INTO Posts (content, create_date) values ('Something', datetime());
  но немного в другом виде
  
post '/new' do
  # получаем значение из POST-запроса
  content = params[:content]
    
  if content.length <=0  # делаем проверку на "пустое значение" параметра
    @error = 'Type text here'
    return erb :new
  end
  
  # сохранение данных в БД
  @db.execute 'INSERT INTO Posts 
    (
      content, 
      create_date
    ) 
      values 
    (
      ?, 
      datetime()
    )', [content] 
  
  erb "You typed: #{content}"
end  
  
  Вместо 'Something' мы ставим знак вопроса, а функцию datetime() - оставляем.
  
  Метод .execute принимает два параметра, второй параметр - это массив []
  В нашем случае массив имеет всего один элемент.
  
  Чтобы выбрать список постов из БД нужно создать запрос к БД
  Добавка 'order by id desc' - предписывает сортировать результат по id в обратном 
  порядке, т.е. сначала самые последние записи, а в конце самая первая.
  
get '/' do
  # выбираем список постов
  
  result = @db.execute 'SELECT * FROM Posts ORDER BY ID DESC'

  erb :index  
end
  
  А в файле представлении 'index.erb' мы делаем следующий код:
  '
  <h2>Latest posts</h2>
  
  <% @results.each do |post|
    <p>
      Bla-bla
    </p>
  <% end %>
  '
  
  Сначала попробуем, что этот код работает. В нашей таблице две записи, значит 
  'Bla-bla' должно вывестись на экран два раза. Так и происходит.
  
  Для вывода содержимого записей воспользуемся ' <%= %> ' 
  Поместив внутрь этой обёртки переменную post из блока 'do...end'
  post - это хэш, доступ к записям которого происходит с помощью строковых ключей
  Так это устроено в sqlite3. (Применять :символы здесь не получится, так устроено) 
  
  В результате получаем такой код нашего файла-представления 'index.erb':
  '
  <h2>Latest posts</h2>
  
  <% @results.each do |post|
    <p>
      <%= post['content'] %>
    </p>
  <% end %>
  ' 
  
  Для более ФОРМАТНОГО вывода можно использовать специальные тэги из HTML 
  '<hr />' - рисование горизонтальной линии
  '<br />' - переход на новую строку
  
  Добавляем эти улучшалки форматирования и получаем такой код:
  '
  <h2>Latest posts</h2>
  <br />
  <% @results.each do |post|
    <p>
      <%= post['content'] %>
      <br />
      <br />
      Added at <%= post['create_date'] %>
    </p>
    <hr />
  <% end %>
  '
  
  В данной ситуации будет более удобным перенаправлять пользователя на основную 
  страницу сайта после ввода очередного поста. Для этого заменяем последнюю стороку
  в контроллере post '/new'
  
post '/new' do
  # получаем значение из POST-запроса
  content = params[:content]
    
  if content.length <=0  # делаем проверку на "пустое значение" параметра
    @error = 'Type text here'
    return erb :new
  end
  
  # сохранение данных в БД
  @db.execute 'INSERT INTO Posts (content, create_date) values (?, datetime())', [content] 
  
  redirect to '/' # перенаправление вывода страницы
end    
  
  Очень удобно, когда доступ к конкретной записи (посту) можно получить через её номер
  '/details/1 ' - для первого поста
  '/details/2 ' - для второго поста
  '/details/3 ' - для третьего поста
  и т.д.
  
  Для этого добавляем в представление ещё код:
  '
  <br />
  <br />
  <a href="/details/<%= post['id'] %>">Comments</a>
  '
  
  Здесь используем формат реферальной ссылки:
  '
  <a href="/details/1">Comments</a>
  '
  а вместо 1 мы ставим наше выражение '<%= ... %>', которое подставим id для каждого 
  конкретного вывода поста. Для превого id=1, для второго id=2, и так далее...
  Точнее, фактически вы получаем на месте 1 значение из хэша post с ключём id
  post['id'] - номер записи. Это будут номера 1, 2, 3, ... 
  
  Вспомни это:
  sql> SELECT * FROM Posts;
  id         created_date         content
  ---------- -------------------  -----------
  1          2014-09-11 18:55:21  Something
  2          2014-09-11 19:07:34  Bla-bla-bla
  
  При переходе по полученным ссылкам мы должны попасть на обработчики по каждой ссылке
  Чтобы не создавать обработчик к каждой ссылке мы сделаем следующее:
  
# вывод информации о посте
get '/details/:post_id' do
  main_post_id = params[:post_id]
  
  erb "Displaind information for post with id #{post_id}"
end

  Так мы получили универсальный обработчик для всех постов, которые есть и будут.
  Значение :post_id будет заменятся значением из нашего хэша post
  
  ВАЖНО!!! Здесь мы получили параметр post_id из url, т.е. он получен из ссылки !!!
  
  Для получения конкретной записи из БД нужно сделать запрос с указанием этого id
  sql> SELECT * FROM Posts WHERE ID=2
  
  result = @bd.execute 'SELECT * FROM Posts WHERE id = ?', [post_id]
  @row = result[0]
  
  Видимо, результат .execute - есть массив записей. В нашем случае это массив, 
  состоящий из одного элемента, т.к. запрос был по id, а он уникальный.
  Другими словами в резельтате будет выбрана только одна запись и индекс у ней 
  будет равен 0
  Для получения этой записи мы берём из массива записей одну запись, которая имеет
  индекс = 0. Так мы получаем в переменной @row - хэщ с данными одной строки.
  
  Вот тут ... да. Это нужно уловить!
  
  В итоге будем иметь такие файлы:
  
filename: details.erb _________________________________________________ 
'
<h4>Post detales:</h4>
<br />
<p>
  <%= @row['content'] %>
  <br />
  <br />
  Addet at <%= @row['create_date'] %>
</p>
'

filename: index.erb ____________________________________________________ 
'
<h2>Latest posts</h2>
<br />
<% @results.each do |post|
  <p>
    <%= post['content'] %>
    <br />
    <br />
    Added at <%= post['create_date'] %>
    <br />
    <br />
    <a href="/details/<%= post['id'] %>">Comments</a>
  </p>
  <hr />
<% end %>
'

filename: app.rb _______________________________________________________
...
post '/new' do
  # получаем значение из POST-запроса
  content = params[:content]
    
  if content.length <=0  # делаем проверку на "пустое значение" параметра
    @error = 'Type text here'
    return erb :new
  end
  
  # сохранение данных в БД
  @db.execute 'INSERT INTO Posts (content, create_date) values (?, datetime())', [content] 
  
  redirect to '/' # перенаправление вывода страницы
end   

# вывод информации о посте
get '/details/:post_id' do
  main_post_id = params[:post_id]
  
  result = @bd.execute 'SELECT * FROM Posts WHERE id = ?', [post_id]
  @row = result[0]
  
  erb :details
end
...  

Дольше нам нужно добавить форму для ввода коментариев.
'
<h4>Comments:</h4>
<p>
  <form action="/details/4" method="POST" role="form">
    <textarrea name="content" class="form-control" rows="6" placeholder="Type comment text here"></textarea>
    <br />
    <button type="submit" class=btn btn-primary">Add comment</button>
  </form>
</p>
'
  Здесь 4 должна заменятся на номер id поста, который коментируется.
  Для этого добавляем значение из хэша в обёртке с =
'
  <form action="/details/<%= @row['id'] %>" method="POST" role="form">
'
  Так эта ссылка в action будет динамически менятся для любого выбранного поста.
  
  1.28:00 - Получить и Сохранить коментарий в БД
  
  Для получения параметров и их обработки (записив БД) нам нужен обработчик запроса,
  который (запрос) по методу POST переправить введённые в форму параметры на сервер,
  а вот уже на сервере и должен быть "обработчик" этого запроса POST
  Создаём его:
  
post '/details/:post_id' do
  # получаем значение перемнной из url-ссылки из POST-запроса
  post_id = params[:post_id]
  
  # получаем значение (которое ввели в поле с именем 'content') из POST-запроса
  content = params[:content]

  erb "You typed comment #{content} for post #{post_id}"
end

  Для проверки мы пока введём просто вывод а браузер сообщение о том что мы ввели 
  и к какому посту это введено.
  
  Чтобы создать ВТОРУЮ таблицу в БД можно просто скопировать блок кода создания ПЕРВОЙ
  таблицы в методе configure и вставить копию сразу за первой. Теперь останется только 
  переименовать название ВТОРОЙ таблицы и скорректировать поля для неё.
  
  Для контроля можно сразу перезапустить приложение и в sql> проверить её появление
  sql> .tables
  
  ВАЖНО !!! Добавим привязку новой таблицы "коментариев" в основной таблице "постов".
  
  И так, имеем две таблицы:
    ПЕРВАЯ: Posts
    ВТОРАЯ: Comments
    
  Во вторую таблицу добавляем дополнительное поле с именем post_id через которое будет
  настроена связь этой (ВТОРОЙ) таблицы с записями в таблице Posts (ПЕРВАЯ)

  ВАЖНО !!! Если просто добавить поле к имеющимся полям таблицы, то это будет ошбкой
  Система не позволит этого выполнить, пока сушествует эта таблица.
  Другими словами, нужно удалить таблицу и тогда при создании её вновь поля таблицы
  уже будут содержать наше новой (длбавленное) поле.
  
  Для удаления воспользуемся командой в терминале sqlite3:
  sql> drop table Comments;
  
  Таблица удалилась теперь она будет создана вновь, со всеми описанными полями.
  (в том числе post_id)

  Теперь осталось сохранить данные в БД.
  
  Копируем блок кода, где мы записывали данные в ПЕРВУЮ таблицу (см. post '/new')
  в наш обработчик и корректируем команду записи данных в БД под наши параметры
  
  # сохранение данных в БД _____________________________ БЫЛО ___________________
  @db.execute 'INSERT INTO Posts 
    (
      content, 
      create_date
    ) 
      values 
    (
      ?, 
      datetime()
    )', [content] 

post '/details/:post_id' do
  # получаем значение перемнной из url-ссылки из POST-запроса
  post_id = params[:post_id]
  
  # получаем значение (которое ввели в поле с именем 'content') из POST-запроса
  content = params[:content]

  # сохранение данных в БД ____________________________ СТАЛО _________________
  @db.execute 'INSERT INTO Comments
    (
      content, 
      create_date,
      post_id
    ) 
      values 
    (
      ?, 
      datetime(),
      ?
    )', [content, post_id] 
  # Обратите внимание, сколько знаков вопроса в блоке value, 
  #                    столько элементов в нашем массиве.
  
  erb "You typed comment #{content} for post #{post_id}"
end
    
  Осталось заменить последнюю строку в нашем обработчике на команду перенаправления 
  на ту страницу, в которой мы вводили комментарий.
  
  Меняем: 
  erb "You typed comment #{content} for post #{post_id}"
  
  на: 
  # перенаправление на страницу поста
  redirect to('/details/' + post_id) 
  
  Тепреь осталось вывести коментарии к нашему посту.
  
  Мы будем их получать с помощью запроса из БД. Результат запроса буде присвоен 
  переменной @comments
  
  Пишем код в обработчик get '/details/:post_id' т.к. здесь мы получает наш пост
  и здесь же нужно получить все комментарии к нему.
  
  # выбираем комментарии для нашего поста
  @comments = @db.execute 'SELECT * FROM Comments WHERE post_id = ? ORDER BY id', [post_id] 
  Полученная переменная - это массив, состоящий из хэшей.
  
  Теперь осталось дополнить представление дополнительным кодом для вывода коментариев
  
'
<h4>Comments:</h4>

<% @comments.each do |coment| %>
  <p>
    <%= comment['content'] %>
  </p>
  </ hr>
<% end %>
'  
  Вримательно. Мы перебираем по очереди все элементы массива @comments
  Каждый элемент - это один коментарий (в формате ХЭШ)
  
  В теле цыкла мы выводим значение (value) хэша по ключу (key), который есть
  имя поля таблицы. В данном случае это 'content' в таблице Comments.
  
'
  </ hr>  '- Для разделения одного коментария от другого'
'    
  
  Ещё для читабильности добавим код с датой добавления комментария
  
'
<span style="font-size: 75%; color: 999">Added at <%= comment['created_data'] %></span>
'  
  Этот код будет выводить рядом с каждым коментарием дату его создания
  Уменьшенным шрифтом "75%", и серым цветом "999" С надписью: "Added at "
  
  
End of Lesson_28
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_29

  > gem install sinatra-contrib
   Добавим в Gemfile строку с '
   gem "sinatra-contrib"
   '
  Файл станет иметь такой вид: 
source "https://rubygems.org"

gem "sinatra"
gem "sqlite3"
gem "sinatra-contrib"

  Далее запускаем команду догрузки недостающих ГЕМов
  > bundle instalk
Fetching gem metadata from https://rubygems.org/........
Resolving dependencies...
Using bundler 1.17.3
Using multi_json 1.15.0
Using ruby2_keywords 0.0.5
Using mustermann 1.1.1
Using rack 2.2.3.1
Using rack-protection 2.2.0
Using tilt 2.0.10
Using sinatra 2.2.0
Using sinatra-contrib 2.2.0
Using sqlite3 1.4.2
Bundle complete! 3 Gemfile dependencies, 10 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.

  Примерно такой будет вывод этой команды.
  
  Теперь будет работать " require 'sinatra/reloader' " на который раньше ругалось 
  наше приложение. Видимо не хватало gem 'sinayta-contrib' в нашей сборке.
  

ACTIVRECORD - ActivRecird - специальный гем облегчающий работу с БД

  1. Клонируем чистое приложение с sinatra и bootstrap
  2. Создадим новый репозиторий 
  3. Клонируем это пустой репозиторий себе на комп
  4. Перенесём туда файлы из клона (п.1)
  5. Зальём изменения в репозиторий
      (дальше первый клон больше пока не нужен, можно удалить с компа)

  Откроем Gemfile:  
source "https://rubygems.org"

gem "sinatra"
gem "sqlite3"
gem "activerecord"
gem "sinatra-activerecord"
gem "sinatra-contrib"   
  
group :development do
  gem "tux"
end

  Если мы зальём наше приложение на хостинг, для продакшен.
  (Этот хостинг должен поддерживать Ruby Rails Sinatra ...)
  то сервер закачает выше перечисленные гемы, но не будет закачивать гем "tux" т.к.
  он описывается в группе development - разработка. А это не продакшен. 
  
  После обновления (изменения) данных в 'Genfile' обязательно нужно ввести команду
  > bundle install
  
  После будет проведена докачка недостающих гемов и внесены соответствующие 
  изменения в соседний файл 'Gemfile.lock' 
  
  Этот файл создан для исключения конфликтов различных гемов.
  В него АВТОМАТИЧЕСКИ внеслись различные версии гемов.
  Так наше приложение теперь за-LOCK-чено под определённые версии гемов 
  (в этом егосмысл)
  
  Отвлечёмся на минуту ...
  Хорошая команда - покажет версию, испочник и место расположения того или иного гема
  > bundle info [gemname]
  Например
  > bundle info tux
    * tux (0.3.0)
           Summary: Sinatra dressed for interactive ruby - a sinatra shell
           Homepage: http://github.com/cldwalker/tux
           Path: /home/rubius/.rvm/gems/ruby-2.4.0/gems/tux-0.3.0
  Продолжим,
  
  Рядом есть ещё один файл 'config.ru' Этот файл будет учитываться хостингом при 
  развёртывании приложения (deploy)
  
  В этом файле:
require './app'
run Sinatra::Application

  где app - это стартовый файл нашего приложения.
  
  deploy  или  deployment - это развёртывание приложения на хостинге
  
  Исользование ActiveRecord происходит следующим способом:
  В главном файле например app.rb мы добавляем строку с требованием использовать для 
  приложение этого гема 
  require 'sinatra/activerecodr'
  
  Теперь написав строку 
  set :database, "sqlite3:barbershop.db"
  
  (++ Экскурс: про SQL
  Упоминание в строке выше 'sqlite3' - это означает, что мы будем использовать 
  базу данных SQLite3. В дальнейшем на этом месте может быть записана другая БД
  напрмер MySQL или PostGres 
  А дальше следует имя файла с этой базой данных.
  ++)
  
  Cоздаём сущность 'Клиент'
  class Client < ActiveRecord::Base
  end
  
  (++ Экскурс: про наследование свойств из класса в класс
  Здесь в строке выше: большие и маленькие буквы в описании класса - это ВАЖНО!
  
  Знак < означает наследование.
  
  class Cat < Animal
  end
  Класс Кот (Cat) наследует все методы из класса Животные (Animal)
  
  В нашем случае класс Клиент унаследует все методы из класса База, который находится
  в пространстве имён Активрекорд  

  Напишем ещё раз это ниже
  class Client < ActiveRecord::Base
  end
  ++)
  
  (++ Экскурс: про команду tux
  Теперь запустим tux на это будеи выведено следующее приглашение 
  >> 
  Если мы наберём команду
  >> Client.all
  то получим ошибку, но увидим как эта простая команда превратилась в запрос к БД
  SELECT "clients".* FROM "clients"
  с указаниес 'no such table' - не существует такой таблицы
  
  введём, чтобы выйти из tux
  >> exit
  
  Создавать таблицу будем с помощью специальной команды rake
  Для просмотра всех возможных параметров этой команды нужно ввести команду
  > rake -T
  Если будет ошибка, что не найден файл Rakefile (там много вариантов), то нужно его
  создать.
  ++)
  
  (++ Экскурс: про Rake в Ruby и Make в C/C++ 
  В языках программирования С или С++ там есть (так называемый) Makefile
  Make - сделать 
  
  В Ruby этот файл переименовали в Ruby Make file и получился Rakefile  
  
  В файле Makefile (в С/С++) были записаны команды, котрые можно было выполнить.
  
  Как в Линуксе, когда что-то собирается из исходников, то дат команды:
  1. make all     - собрать всё
  2. make install - установить 
  ++)
  
  Создадим Rakefile:
  require "./app.rb"     - требуем подключить наш основной файл с нашей программой
  require "sinatra/activerecord/rake"
  Всего две строки в файле.
  
  (++ Экскурс: про rake
  Теперь можно повторить команду: rake -T
  
  Команнд много, но мы будем сейчас использовать только три команды:
  > rake db:create_migration      - создать миграцию   (с описанием действий)
  > rake db:migrate               - исполнить минрацию (выполнить, применить)   
  > rake db:rollback              - откатить миграцию (возврат к предыдущей миграции)
  
  Миграции - это различные версии БД (по типу как наши коммиты в git)
  ++)
    
  Создадим простую миграцию:
  >rake db:create_migration NAME=create_clients
  db/migrate/20140916183508_create_clients.rb
                                                !!! ВАЖНО: clients с буквой s в конце
                                                Видимо тепреь (2022) уже не пишут
                                                Name=something, а пишут something
  (++ Экскурс: про структуру файлов миграций
  Появилась новая папка db
    в ней ещё одна папка migrate
      а уже в ней файл 20140916183508_create_clients.rb

  Имя файла специально сделано для отличия каждой миграции от соседней (+ сортировка)
  Если даже у миграций будут одинаковые имена, но имена файлов будут различны.
  У которого внутри:
  class CreateClients < ActiveRecord::Migration
    def change
    end
  end
                    Раньше в миграции использовали два метода:
                    def up
                    end
                    
                    def down
                    end
                    Эти методы можно встретить в миграциях в старых версиях программ
                    
                    сейчас их заменили на один
                    def change
                    end
  ++)
  
  Этот файл-миграция - пустой. Давайте создадим в нём МИГРАЦИЮ:
  class CreateClients < ActiveRecord::Migration
    def change
    end
  end

  Для миграции был созжан специальный класс и в него были переданы (унаследованы)
  определённые методы из класса Migration
  Один из таких методов - это:
  
  create_table :client do |t|
    t.text :name
    t.text :phone
    t.text :datestamp
    t.text :barber
    t.text :color
    
    t.timestamps
  end
  
  Этот блок создаёт таблицу в БД (если её нет)
  
  id - primary key - создаётся автоматически
  
  client - это название таблицы 
  Этот код говорит о том, что в таблице Client будут созданы столбцы с текстовыми
  форматами данных и именами в соответствии с указанными :символами
  
  t.timestamps - специальный метод для создания двух дополнительных столбцов
                                                        created_at
                                                        updated_at
  
  Сейчас у нас есть файл миграции. Чтобы запустить эту миграцию нужно дать команду:
  > rake db:migrate
  
  Миграция выполняется и выводит время выполнения в долях секунд.
  
  ORM - Object Relation Mapper (Mapping) 
  На данном этапе мы создали МАППИНГ:
    У нас есть СУЩЬНОСТЬ, в виде класса 
    и есть её свойства, описанные названиями столбцов.
    Это связка ООП с реляционными БД.
  
  Создадим ещё одну сущность: Person
  1. В основном файлк пишем новый класс (наследник из Base пространства ActiveRecord)
  
  class Person < ActiveRecord::Base
  end
  
  2. Создаём миграцию с помощью команды rake
  > rake db:create_migration create_persons
  В папке ./db/migrations/ появился новый файл. 
  
  3. Наполним его (файл) или её (миграцию) свойствами нашей сущности.
  class CreatePersons < ActiveRecord::Migration[5.2]
    def change
      create_table people do |t|
        t.text	:name
        t.text  :b_date
        t.text  :d_date
        t.text  :photo_link
        t.text  :discription

        t.timestamps
      end
    end  
  end
  
  4. Даём команду на выполнение этой миграции
  > rake db:migrate
  
  1.04:04 - заливаю изменения на сервер.
  
  Проверим минимальную функциональность с помощью команд консоли ActiveRecodr.
  У этой штуки есть своя консоль = tux
  > tux
  >> User.count
  '
  D, [2022-06-16T22:22:04.681693 #6163] DEBUG -- : (0.6ms) SELECT COUNT(*) FROM "user"
  '
  И ещё для другой таблицы
  >> Person.count
  '
  D, [2022-06-16T22:22:38.228313 #6163] DEBUG -- : (0.7ms) SELECT COUNT(*) FROM "people"
  '
  __ здесь User или Person - это имя таблицы жолжно совпадать с именем, которое указа-
  ли в методе change в строке create_table , но здесь оно должно быть с Большой буквы) 
  
  !!! Очень желательно после миграции проверять результат, хотябы на минмальную 
  функциональность. В том числе с помощью этой консоли tux.
    
  Есть два способа создания объекта:
  1. Person.create    - создаёт объект в БД
  2. b = Person.new   - создаёт объект в ПАМЯТИ и потом его нужно сохранить в БД:
     b.save  
  
  Попробуем создать объект в консоле.
  >> Person.create :name => 'Something' 
  
  Синтаксис команд в этой консоли - это синтаксис Ruby. Т.е. все эти команды можно 
  писать в нашей программе. 
  А теперь второй способ создания объекта.
  
  
  
  >> b = Person.new :name => 'Valera' 
  Обратите внимание, что на экран не выводится никаких обращений к БД (их ещё пока нет)
  
  >> b.new_record?
  true
  Если выйти из консоли на этом этапе, то эта запись исчезнет (она не в БД), но
  если дать команду к сохранению её
  
  >> b.save 
  будет выведена команда запроса к БД с записью данных в таблицу и результатом 
  операции => true
  Теперь наш объект сохранён в БД. И команда
  >> b.new_record?
  false 
  ... уже не новый.
  
  Ссылка на справку ActiveRecord:
  http://guides.rubyonrails.org/active_record_querying.html
  
  Если сравнивать коды программ с ActiveRecord и без него, то можно увидеть, что 
  размер кода с нии стал значительно короча. Мы перестали писать сложные команды
  для обращения к БД. Это его положительное свойство.
  
  А если код стал короче, значит и читать (понимать) его стало много проще.
  
ActiveRecord - методы и их действия

  Всякий метод применяется к созданному классу и чаще всего результатом метода явля-
  естся одна запись, организованная в виде хэша 
   или букет записей, организованный в виде массива таких же хешей.
   т.е. {...}  или  [{...}, {...}, ...]
   
  Для понимания создадим два класса User и Person   

 class User < ActiveRecord::Base 
end

class Person < ActiveRecord::Base 
end 

  Результат выполнения обычно присваивается переменной с префиксом @ 
  Переменные с таким префиксом будут доступны в файлах *.erb (для отображения )
    
  @a = Person.all  # Получаем все записи из таблицы persons из БД = [{...},{...},...]
  
  @b = Person.order "id DESC"  # То же самое, но отсортировано в обратном порядке.
  
  (++ Экскурс: В Hrome-development  (№ 29 = 1.40:00)
    ПКМ - inspect - consol  (смотрим все ошибки)
    Снизу потяните вверх поле - появится ещё одно окно.
    Можно искать слова в полученных браузеров файлах 
    (в тех файлах, которые отправил наш сервер на этот браузер)
  ++)

  
End of Lesson_29
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_30

  Пять шагов работы с БД с ActiveRecord:

1.  set :database, "sqlite3:barbershop.db"  - убедитесь что он у Вас работает
                                              появится такой файл (size=0)
2.  class Client < ActiveRecord::Base       - создаём модель
    end
3.  > rake db:create_migration name_of_migration  - создаём миграцию для Client.
                                                создаётся новый файл в /db/migration  
4.  Редактируем код созданной миграции:
    create_table :cliets do |t|              - создаём таблицу
      t.text :name                           - добавляем в неё столбики (тип, имя)
      t.text :phone
      ...
    end 
    В одной миграции можно создавать несколько таблиц и имя каждой таблицы нужно
    писать во множественном числе. Так надо!
    
5.  > rake bd:migrate  - выолняем миграцию.

  Для работы этих 5-ти  шагов нужно чтобы у Вас:
  1. Все gem-ы
  2. Rakefile
  
  Установить gem-ы можно или выполнив команду                > gem install ...., 
      или записав их в специальный файл Gemfile и выполнив   > bundle install
  
  ну а Rakefile создаётся руками и в этом нет ничего сложного.
  Rakefile создаётся руками и в этом нет ничего сложного.
  
...
'
<form action="/visit" method="POST" role="form">
  <div class="form-group">
    <label>Ваше имя</label>
    <input name="username" type="text" class="form-control" placeholder="Иванов Петя" value="<%=@user_name%>">
  </div>
  <div class="form-group">
    <label>Ваше телефон</label>
    <input name="phone" type="text" class="form-control" placeholder="+7 987-654-32-10" value="<%=@phone%>">
  </div>
  ...
  <input type="submit" class="btn btn-primary" />
</form>  
'
...  
  
  Для сохранения данных нужно переданные из формы данные (в виде ХЭШа) присвоить:
  
post '/visit' do
  @username = params[:username]  # Здесь и далее имя :username -- из поля формы erb
  @phone = params[:phone]        # , а @username -- мы сейчас сами придумали
  ...
  c = Client.new                 # Новый экземпляр класса
  c.name = @username             # Здесь и далее c.name -- из имени столбца таблицы 
  c.phone = @phone               # (см. create_table выше)
  ...
  c.save
  ... 
  erb "<h3>Готово!</h3>"  
end  
  Это лаймерский подход - (удобно для поиска ошибки), но есть способ проще.
  
post '/visit' do  
  c = Client.new params[:client_f]  # Имя :client_f -- мы придумали сами, оно же будет
  c.save                            # упоминаться в форме erb  (см. ниже)
  erb "<h3>Готово!</h3>"
end
  Это будет работать если вы изменим код в нашем представлении (имена в форме erb)
  
...
'
<form action="/visit" method="POST" role="form">
  <div class="form-group">
    <label>Ваше имя</label>
    <input name="client_f['name']" type="text" class="form-control" placeholder="Иванов Петя" value="">
  </div>
  <div class="form-group">
    <label>Ваше телефон</label>
    <input name="client_f['phone']" type="text" class="form-control" placeholder="+7 987-654-32-10" value="">
  </div>
  ...
  <input type="submit" class="btn btn-primary" />
</form>  
'
...  
  Здесь в тэгах input в имена name= вставлены значения из хэша clien_f 
  с ключами, которые соответствуют названиям столбцов
  в таблицу Clients в нашей БД.
  
  Надо представить в голове, чтобы это понять!  
  
  Выбор здесь clien_f сделан исключительно для наглядности соответствия имён в коде.

  
ВАЛИДАЦИЯ в ActiveRecord

  Метод .save по умолчанию выполняет валидацию данных и выводит false если валидация
  прошла с ошибкой (т.е. данные не соответствуют заявленным параметрам по полям)
  
  Введём эти парамертры для проверки.
  
  class Client < ActiveRecord::Base
    validates :name, { presence: true }
    # функция парам-1  парам-2 - это хэш произвольной длинны (скобки можно не писать)
    validates :phone, presence: true
    ...
  end
  
  В консоле tux можно смоделировать ситуацию с неполными данными и проверить валидацию
  > tux
  >> c = Client.new
  => # <Client id: nil, name: nil, ...>
  >> c.valid?
  ... 
  => false
  Ошибки хранятся в переменной errors
  Для вывода количества ошибок пишем:
  >> c.errors.count
  => 4
  Для вывода самих сообщений есть другой метод messages
  >> c.errors.messages
  => {:name=>["can't be blank"], :phone=>["can't be blank"], ...}
  
  !!! tux используя файл config.ru подключает нашн приложение и использует модели
  нашего приложения и другие параметры для лбработки команд, вводимых нами.
  
  Самый простой способ обработки ошибки при валидации такой:

post '/visit' do  
  c = Client.new params[:client_f]  
  if c.save                            # работает без знака '?'
    erb "<h3>Готово!</h3>"
  else
    erb "<h3>Ошибка</h3>"
  end  
end  
  
  Сделаем несложный вывод сообщения об ошибке.
  И если есть ошибка, то мы будем возвращать всё тот же вид с полями, + сообщения об
  ошибке.
  
post '/visit' do  
  c = Client.new params[:client_f]  
  if c.save                            # работает без знака '?'
    erb "<h3>Готово!</h3>"
  else
    @errors = c.errors.full_messages.first
    erb "<h3>Ошибка</h3>"
  end  
end    
  У нашей модели есть свойство .errors а у него есть .full_messages а у того есть
  свойство .first  = в результате получим одно сообщение об ошибке.
  
  Чтобы сделать так, чтобы форма помнила введённые значения 
  нужно нашу переменную сделать переменной класса @c и прописать её отдельное свойство
  в нужные поля в форме (в value= параметр тега <input ...>)

post '/visit' do  
  @c = Client.new params[:client_f]  
  if @c.save                            # работает без знака '?'
    erb "<h3>Готово!</h3>"
  else
    @errors = @c.errors.full_messages.first
    erb :visit
  end  
end 

...
'
<form action="/visit" method="POST" role="form">
  <div class="form-group">
    <label>Ваше имя</label>
    <input name="client_f[name]" type="text" class="form-control" placeholder="Иванов Петя" value="<%= @c.name %>">
  </div>
  <div class="form-group">
    <label>Ваше телефон</label>
    <input name="client_f[phone]" type="text" class="form-control" placeholder="+7 987-654-32-10" value="<%= @c.phone %>">
  </div>
  ...
  <input type="submit" class="btn btn-primary" />
</form>  
'
... 
  ВАЖНО!
  В обработчике get '/visit' так же должна появится переменная @c иначе форма не 
  сможет обработать введённый код в value наших полей. (Перемнная @c должна быть)

get '/visit' do
  @c = Client.new
  erb :visit
end

  Справка по валидации: 
  http://guides.rubyonrails.org/active_record_validations.html
  
  Для тренировки добавим ещё одну проверку в валидацию имени
  class Client < ActiveRecord::Base
    validates :name, presence: true, length: { minimum: 3 }
    # функция парам-1  парам-2 - это хэш произвольной длинны (скобки можно не писать)
    validates :phone, presence: true
    ...
  end
  
  Новая задача!  
                                                               1.12:00   
  Сделаем обработчик для отдельного экземляра 'barber'. 
  Ссылка на такую страницу должна иметь вид: '/barner/2' где 2 - это id barber
  Имеем обработчик для вывода списка всех барберов.
  
get '/barbers' do
  @all_barbers = Barbers.all
  erb :barbers
end  
  Имеем представление 'barbers.erb', в котором выводится список нескольких барберов.
'  
<h3>Barbers</h3>
  <% @all_barbers.each do |one_barber| %>
    <p>
      <a href="/barber/<%= one_barber.id %>"> <%= one_barber.name %> </a>
    </p>  
  <% end %>
'  
  В результате в браузер придёт такой html код
 '<a href="/barber/1"> Wolter </a>
  <a href="/barber/2"> Jessy </a>
  <a href="/barber/3"> Stive </a>'
  
  Пишем обработчик этих ссылок
  
get '/barber/:id' do
  @barber = Barber.find(params[id]) # .find() в параметр принимает только primary_key
  erb :barber                       # в нашем случае это id барбера      
end   
  Оно будет работать с такой вьюхой в файле 'barber.erb':
  
'
<h3>Barber page</h3>
<%= @barber.name %>
'
                                                              1.20:00
REST - стандарт проектирования

  Система создания ссылок.


End of Lesson_30
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_31

  КАК РАБОТАЕТ http
  
  1. Мы вводим в браузере какой-то адрес - это "Доменное имя"
     Доменное имя превращается в ip-адрес
     
     IP-адрес можно узнать через команду ping
     > ping ya.ru 
     [213.180.193.3]
     
  2. Далее происходит подключение на так называемый порт 
     Порт - это абстракция ОС или абстракция протокола. Реального порта - НЕТ.
     127.0.0.1:4567   (4567 - это порт)
     
     Без указания порта браузер подключается к порту 80
     127.0.0.1:80 
                  EQ 
     127.0.0.1 
                  EQ 
     localhost
     
     Это всё, если не задан SSL
 
     С SSL это будет уже не так. 
     https://ya.ru  - тогда происходит подключение через защищённый канал.
     
     80 - это когда мы вводим  http://ya.ru
     443 - это когда мы вводим https://ya.ru
     
   3. Далее посылается запрос к серверу (http://host/url/here?other=stuff&too)
   
   4. Получается ответ от сервера  
      
   5. Затем соединение закрывается.   
     
   Длы работы с сервером можно использовать telnet
   
   Сервер упаковывает свой ответ - сжатым ответ передаётся в браузер
   Затем браузер получив ответ распаковывает его и пытается определить
   что с ним делать (показать, сохранить или воспроизвести, ...)
   
   Обычно браузер после получения ответа - закрывает соединение.
   Но иногда он получает в качестве ответа РЕДИРЕКТ на другой адрес.
   Тогда происходит отправка нового запроса и получения нового ответа с 
   другого адреса (который указали в РЕДИРЕКте)
   
   Существует несколько способов определения пользователя, который залогинился.
   А соединение разорвалось.
   
   stateless - (состояния без) - HTTP - протокол без состояния 
   Другой протокол - IRC - Internet Nelay Chat - всегда поддерживает соединение.
   Если обратиться к серверу через IRC то соединение не будет разрываться и данные
   ходят по этому соединению (не разрывается)
   
   Сервер не видит разницы в запросах двух пользователей. Разницу улавливает приложение.
   
   Т.е. сам сервер просто принимает наши запросы и перенаправляет их в приложения,
   которые на нём установлены. А вот приложения проверяют что это Мы или не мы и
   каждое приложение готовит отвер и передаёт его в сервер для отправки нам в юраузер
   
   00.30:00 - Настройка fidlera
   
   url unescape oneline - это декодер в том числе меняет 
   %5B - на [  
   %5D - на ]
   Получается читабильная запись (скобки запрещено передавать в протоколе - это 
   исторически так сложилось и до сих пор осталось)
   
vanilla.js - фрейм ворк  http://vanilla-js.com - Это шуточный сайт с Джава скриптом
   
  jQuery 
  
  Будем делать интернет магазин по продаже пиццы.
  
  1.05:00 - JS and jQuery

  в Ruby функция вызывается через
                                            def something
                                              puts 'Hello!'
                                            end
  
  В js синтаксис другой
                                            function something()
                                            {
                                              alert('Hello!');
                                            } 
   
  "Толстый клиент" - это приложение в котором много js кода
  
  node.js  - приложение для написания кода js
  
  java script - грузится на сторону клиента и исполняется в браузере
  Если весь сайт написан на js, то серверная часть исполняется на сервере.
  
  METEOR JS - фрейм ворк на языке js
  
  Пока программа небольшая скорость написания кода отличатся на разных языках.
  Но когда приложение стало большим и сложным, то скорость разработки (внесения 
  новых функция и классов) в назных языках практически одинакова. 
  А Ruby в этих режимах опережает практически все языки.
  
  План создания нового Web-приложения ___________________________________ на SINATRA.
  1. Сoздаём пустой репозиторий на сайте gitnub
  2. > git clone - его себе на компьютер
  3. Copy - в него заготовку пустого сайта (взять их репозитория 'sinatra bootstrap')
  4. Переносим скрипты в layout.erb to <header> если они в подвале
  5. > git commit -a -m "Init app" - наше приложение
  6. Делаем проверку наличия зависимостией > bundle install
  7. Запускаем приложение > bundle exec ruby app.rb
  -- Всё работает - можно начинать делать web-приложение
  -- Появились ошибки - нужно исправить или всё стереть и повторить сначала.
  

КНОПКА _____________________________________________________________________________
  
  Для создания функции на js в нашем файле index.erb пишем такой код:
  '
  <script>
  
  function something()
  {
    alert('Hello!');
  }
  </script>
  '
  Если просто написать такой код в файле, то браузер не выполнит этот код.
  Для его выполнения нужно сделать его запуск.
  Эта функция запускается по какому-то событию (финдлеру) 
  '
  <button onclick="something()">Click me!</button>
  '
  здесь onclick - это как раз и есть то событие, по которому запустится наш скрипт.
  
  !!! Sublime Text при вводе 'on' сразу предлагает варианты солбытий, при которых
  может быть настроен6 запуск нашего скрипта. Это радует. !!!
  
  При нажатии на кнопку наш скрипт будет запущен, и он выполнится на сервере.
  Никакого обращения к серверу не будет происходить. С точки зрения Sinatra наш
  скрипт выглядит как какой-то текст и Sinatra никанкого отношения к нему не имеет.
  
  Чтобы одна функция была доступна из нескольких страниц сайта нужно:
  В папке public создать файл с нашим скриптом. Названия файла - не важно!
  Например 'app.js' 
  И в него запишем нашу функцию на java script  (тэг <script> - теперь не нужен)
  '
  function something()
  {
    alert('Hello!');
  }
  '
  Не забудем удалить этот скрипт из наших файлов .erb
  
  И подключим его в 'layout.erb' в блоке <header> точно так, как скрипт от bootstrat.
  Теперь наш файл со скриптом (скриптами) будет подгружаться ко всем страницам сайта
  и соответственно, на любой странице можно вызвать нужный скрипт из файла 'app.js'.
  
  !!! При переходе от странице к странице переменные в js НЕ СОХРАНЯЮТСЯ.
  Переменная всегда будет инициализироваться заново.
  
  Например у нас есть интернет магазин и в нём есть корзина. В корзине должно 
  сохраняться всё что в неё добавлено. Переход на новую страницу не должен обнулять
  содержимое корзины. Т.е. нам нужна переменная, которая будет сохранятся.
  
  Для этого будем использовать один из механихмов HTML-5
  
  '
  var x = 1;
  
  function something()
  {
    alert(x);
    x = x + 1;
  }
  '
  Х - должен накапливаться и сохраняться, даже при переходе на другую страницу или 
  при закрытии браузера и последующим открытии его (завтра).
    
End of Lesson_31
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_32

  'http://rubydev.ru/2010/12/ruby-private-protected-public-methods/' 
  - Различия между Public, Protected и Private методами (Хоббитыб комнаты и кольцо)
  
  Нужно сделать так, чтобы пременная сохранялась при переходе от страницы к странице
  и даже при закрытии браузера данные всё равно сохранялись.
  Всё это можно сделать с помощью разных механизмов. Мы воспользуемся одним из самых
  надёжных и самый простой.
  
  0.18:00
  
  Этот механизм из HTML-5.
  
  jQuery - фрамеворк, который расширяет возможности js, сразу как только мы его 
  подключили.
  
  Modernizr - (без e) не расширяет js, он делает работоспособными неработающие фишки 
  htnl-5 в разных браузнрах. Он модернизирует старые браузеры.  
  
  Плагин от "Журавля":
  https://github.com/ro31337/first-visit-js
  Этот плагин создан для того, чтобы выводить новому пользователю сообщение. При 
  повторном входе данное сообщение не будет выводится.

  Мы будем использовать такой объект html-5 как localStorage 
  
  Здесь есть команда для проверки наличия localStorage в браузере и если его нет, 
  то выводится сообщение о необходимости загрузить modernizr из github.
  
  Для более подробного знакомства с ним можно ввести в google: window.localStorage
  Откроется сайт www.w3schoola.com/html/html5_webstorage.asp
  
  localStorage - позволяет сохранять данные локально. Т.е. страница сайта будет
  записывать данные в специальное хнарилище в браузере.
  
  Наш скрипт будет обращатся к localStorage и сохранять данные в хранилище браузера.
  Место хранения будет привязано к адресу нашего сайта. 
  Например данные по 'localhost'  и по 'ruby-school.ru' будут иметь отдельные места 
  хранения. У каждого сайта - своё отдельное место с данными.
  
  Существует ограничение по размеру (до 5 мегабайт).
  
  Например, корзина с покупками будет хранится на строне пользователя.
  На сервере работа с корзиной будет только когда пользователь сделает спец опрецию.
  
  Все остальные манипуляции с корзиной пользователь будет делать в своём браузере
  и сервер не будет видеть эти манипуляции. Так будет очень удобно.
  
  0.31 - как разделяется разработка...
  
  app.rb - это серверная часть приложения.
           - здесь создаются сущности. 
           - проходят запросы к БД.
           - выполняются проверки данных.
           - это приём и обработка запросов
           - это отправка ответов на запросы (в браузер).
           
  aoo.js - это клиентская часть приложения.
           - это обработка событий в браузере
           - это вывод информации на экран клиента
           - это различные "украшательства"
           - это отправка запросов (на сервер)
           - это получение и отображение ответов от сервера.
           
  С точки зрения структуры данны, localStorage - это ХЭШ.
  
  Как это было-бы в Ruby: ____________________________________________
  
    hh['x'] = 1
  
    hh['x'] = hh['x'] + 1
  
    
  В JS это будет уже так: ____________________________________________
  
    function something()
    {
      var x = window.localStorege.getItem('aaa');
  
      window.localStorage.setItem('aaa', 555);
  
      alert(x);  
    }
    
    aaa - это ключ от хэша.
    Обратите внимание, что получение (get) значения (x) их хранилища записано выше,
    чем запись (set) значения (555) в localStorage. 
    Из-за этого при первом нажатии кнопки (обращении в этой функции) мы получим 'nil'
    а при втором обращении уже будет '555'. 
    
    Кнопка из примера выше. Вот он:
    '
    <button onclick="something()">Click me!</button>
    '
    Теперь при обновлении страницы данные в нашем ХЭШе не стираются.
    
    Теперьдавайте добавим увеличение на 1 нашего значения, которое хранится в браузере.

    function something()
    {
      var x = window.localStorege.getItem('aaa'); // Это как x = hh['aaa']

      x = x + 1;

      window.localStorage.setItem('aaa', x);  // Это обратная функция hh['aaa'] = x

      alert(x);  
    }
    Переменная x - это внутренняя перемнная, которая доступна только внутри функции.
    При каждом нажатии нашей кнопки, эта переменная инициализируется вновь.
    ... выполняет свои действия и исчезает при закрытии этой функции.
    Новое значение отправляется в ХЭШ localStorage.
    
    Чтобы увидеть изменения нужно перезагрузить страницу, чтобы подгрузился обновлённый
    текст скрипта.
    
    Здесь буде выведено: 555, 5551, 55511, 555111, 5551111, ...
    Дела в том, что в js значение 555 - это string, и если к стринг ротбавить 1 ,
    то js считает что '555' + '1' так получается '5551'.
    
    Можно это исправить. В js можно умножить число в string на 1 тогда получиться
    то же число но уже в integer.
    
    '555' * 1 = 555
    string * 1 = integer
    
    Исправляем в нашей функции:
    
    function something()
    {
      var x = window.localStorege.getItem('aaa'); 
      
      x = x * 1 + 1;
      
      window.localStorage.setItem('aaa', x);
      
      alert(x);  
    }
         
    Теперь всё работает так, как мы ожидали! 
    5551112, 5551113, 5551114, 5551115, ...
    Сохранённое значение осталось в браузере, поэтому начальное число = 5551111
    
    Можно для эксперимента изменить ключ хэша (было 'aaa', стало 'bbb')
    теперь всё началось с начала:
    1, 2, 3, 4, 5, ...
    
    '555' - мы ввели в начале разработки (для примера). И с этого числа началось 
    "увеличение на 1", а теперь в хранилище нет этого 555 и увеличение нового 
    значения началось с 0. 
    
    Старое значение не стёрлось, его можно получить по ключу 'aaa'
    А новое значение по ключу 'bbb' 
    
    'aaa' => 5551115, 'bbb' => 5
    
    Можно убедиться, что наша переменная увеличивается и при открытии новой страницы,
    и при открытии сайта заново, и при закрытии-открытии браузера, и даже при 
    перезагрузке всей системы (и выключении компьютера).
    
    Чтобы удалить запись из браузера пишем:
    window.localStorage.setItem('aaa', nil)
    
    1.00:00 - Пример: "Как искать справку по конкретной проблеме".
    
    Пишем в поиске Google: enumerate windiw.localStorage site:stackoverflow.com
    Как проитись по всем значениям в localStorage?
    
    for (var - = 0; i < localStorage.length; i++){
      $('body').append(localStorage.getItem(localStorage.key(i)));
    }
    
    
    1. Для работы нам понадобится подключить gem: 
    sinatra, activerecord, sinatra/activrecord, используя require
    
    2. Затем добавляем строку с подключением к файлу БД
set :database, "sqlite3:file_db.db"  # Имя файла может быть любым
    
    3. И наконец создаём новый класс "Продукт"
class Product < ActiveRecord::Base
end
    (пока без валидации validation)
    
    4. Ещё нам нуже будет rakefile. Его можно скопировать с другого приложения
require "./app"
require "sinatra/activerecord/rake"
    Здесь app - это имя стартового файла в приложении.
    Rakefile подключает наше приложение и второй строкой подключает пространство имён
    из "sinatra/activerecord/rake" 
    
    6. Добавляем в Gemfile используемые гемы и делаем:
    > bundle install 
    для их установки (если олни ещё не установлены)
    незабудем про установку гема tux
    
    7. Осталось только выполнить создание миграции для нашего класса Product: 
    > rake db:create_migration create_products
    # Ruby сделать БАЗАДАННЫХ:создать_миграцию с именем "создаём_продукты"
    
    !!! Здесь важно задать имя во множественном числе "...-продукты". 
    
    В результате создаётся новый файл: 20140925191057_create_products.rb с миграцией 
    в папке по адресу: /db/migrate/...
    
    8. Далее в этом файле (см. п.7.), в методе change нужно описать 
    создание таблицы и указать название полей и их типы.
      create_table :products do |t|
        t.string :title
        t.text :discription
        t.integer :price
        t.integer :size
        t.bolean :is_spicy
        t.bolean :is_veg
        t.bolean :is_best_offer
        t.string :path_to_image
        
        t.timestamps
      end
    поля: id, created_at, updated_at - будут добавлены автоматически.   
    
    Все типы полей можно посмотреть по адресу:
https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html
https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html 
    
    9. После описания таблицы делаем 
    > rake db:migrate
    
    Картинки нужно расположить в папке /public
    Мы их поместим в отдельную папку images
    
    !!! Если картинки уже помещены в нашу папку, 
    то мы можем обратиться к ним прямо из браузера: localhost:4567/images/hawaiian.jpg
    картинка откроется в браузере.
    
    10. Теперь давайте наполним нашу БД начальными значениями.
    seed - действие связанное с наполнением БД значениями
    seed database - наполнить базу данных
    
    > rake db:create_migration add_products
    Появился новый файл с миграцией.
  
    Для наполнения БД есть два метода: метод .create и метод .new
    .create - создаёт новую запись сразу в БД
    .new - создаёт экземляр класса в памяти компьютера
           и ему требуется .save для отправки данных в таблицу БД.
           
    Будем писать Product.create и передавать хэш с параметрами этого продукта.
    Всё это будем писать в файле нашей только-что созданной миграции (в change) 
    
class AddProdukts < ActiveRecord::Migration
  def change
    Product.create ({
      :title => 'Hawaiian', 
      :discription => 'This is Hawaiian pizza',
      :price => 350__00
      :size => 30
      :is_spicy => false
      :is_veg => false
      :is_best_offer => false
      :path_to_image => '/image/hawaiian.jpg' })
    
    Product.create ({
      :title => ...
      ...     })
      
    ...   
  end
end    

КАРТИНКИ

  <img src="..." />
  Здесь "..." - путь к файлу изображения.
  Он можнт быть двух видоа:
  1. ПОЛНЫЙ ПУТЬ - full path "http:// ..."
  2. ОТНОСИТЕЛЬНЫЙ - - "/ ..."
  
  Полный путь нужно корректировать при смене домена или при разворачивании приложения
  Относительный путь пишется один раз и не меняется.
  
SUBLIME TEXT 
  
  Если выбрать View -> WordWrap -> - то длинные строки будут переносится по словам.
  
HTML-5 - GRID - Сетка

  Сетка устроена следующим образом:
  
  Container       - контейнер, внутри него строки
    Row             - строка 1
      Col-...          - колонка 1
      Col-...          - колонка 2
      Col-...          - колонка 3
    Row             - строка 2
      Col-...          - колонка 1
      Col-...          - колонка 2
    Row             - строка 3
      Col-...          - колонка 1
      Col-...          - колонка 2
      Col-...          - колонка 3
      Col-...          - колонка 4
    ...
  
  В bootstrap есть специальные префиксы, которые обозначают ШИРИНУ СТОЛБЦА для
              различных устройств.

  xs - xsmoll - дополнительно маленький  ( ... )
  
  sm -  small - маленький __ (iphone)
  
  md - medium - средний __ (ipad, маленькие ноутбуки)
  
  lg -  large - большой _____ (компьютер)
  
  Сама ширина столбца задаётся цыфройб а всего столбцов 12.
  
  Нам удобнее всего будет использовать col-md-...
  
  
End of Lesson_32
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_33

  Весь экран разбивается на 12 частей. И мы можем творить с ними всё что захотим.
  "
  <div class="row">
    <div class="col-md-4">
      ...
    </div>
    <div class="col-md-8">
      ...
    </div
    ...
  </div>
  "
  Можно комбиниромать названия, настраивая поле под разные устройства.
  "
  <div class="col-md-3 col-xs-6"> ... </div>
  <div class="col-md-3 col-xs-6"> ... </div>
  <div class="col-md-6 col-xs-12"> ... </div>
  " 
  total       3+3+6=12 6+6+12=24   - (12 = Одна строка и 24 = Две строки)
  
  0.28:40 - на практике применяется редко.
  
  Если ввести в google: dynamic number of items bootstrap site:stackoverflow/com
  https://stackoverflow.com/guestions/19607851/use-bootstrap-grid-with-variable-number-of-cells
  https://stackoverflow.com/questions/19607851/use-bootstrap-grid-with-variable-number-of-cells
  
  Здесь спрашивается, как сделать так, чтобы расположение картинок было динамическим?
  Если экран не большой, то пусть отображается по две картинки в строке,
  Если экран средний, то пусть будет отображатся по три картинки,
  Ну а если экран очень большой, то пусть отобрадантся по 4 картинки на строке.
  Т.е. всё зп=ависит от размера экрана у устройства с браузером.
  
  Для отображения списка всех продуктов делаем следующий код:
  
def '/' do
  @products = Product.all
  erb :index
end
  
'
<h3>Welcome to Pizza Shop</h3>

<% @products.each do |p|
<p>
  product
</p>
<% end %>

<button class="" onclick="something()">Click me!</button>
'
  В резкльтате будет выведено три одинаковые записи:
product
product
product

  Так очень удобно работать: "Сделал какую-то функциональность, попробуй её 
  - получил минимальны результат (улучшение). Сделал ещё одну - получи новый
  результат. Так малыми шагами делается множество мелких добавок, а в результате
  получается значительный прирост в приложении" 
  
  > git commit -a -m "Display products, step 1" 
  
  Каждый маленький шаг, после получения маленького результата, желательно коммитить.
  
  
'
<h3>Welcome to Pizza Shop</h3>

<div class="row">

  <% @products.each do |p|
  
    <div class="col-md-3">
      <%= p.title %>
    </div>
  
  <% end %>

</div>

<button class="" onclick="something()">Click me!</button>
'  
  Опять делаем commit
  
'
<h3>Welcome to Pizza Shop</h3>
<div class="row">
  <% @products.each do |p|
    
    <div class="col-md-3">
      
      <div> <%= p.title %> </div>
      
      <div> <img src="<%= p.path_to_image %>" /> </div>
      
      <div> <%= p.discription %> </div>
      
      <div> <%= p.size %> Cm </div>
      
      <div> <%= p.price %> Rub </div>
      
    </div>
  
  <% end %>
</div>
<br/>
<br/>
<button class="" onclick="something()">Click me!</button>
'  

  Размер картинки можно регулировать с помощью width и heigth так:
'
<img src="" width="200" heigth="200" />
'
  Если картинка большая, то она не будет сжиматься на стороне Ruby. Большие картинки
  создают много лишнего трафика. Большие картинки лучше подгружать по отдельному
  запросу от пользователя.
  
  Diployment - выкладывание приложения на сервер (подготовка к продакшен)
  
  0.58:50 - сделаем commit.
  
  Создайм кнопку "Добавить в корзину" 
'
<div>
  <button type="button" class="btn btn-sm btn-success">Add to cart</button>
</div>
'
  Можно нажимать на эти кнопки, и ничего не будет происходить.
  Дальше нужно привязать к ним какой-тнибудь (anythink) тестовый код для того чтобы 
  проверить работает ли вызов теста при нажатии кнопки или нет.
  
  Обычно он проверяет это так, добавляем в код кнопки: onclick="alert('Hello!')" 
'
<div>
  <button type="button" class="btn btn-sm btn-success" onclick="alert('Hello!')">Add to cart</button>
</div>
'
  При клике по этой кнопке будет выполнятся такой JS код: alert('Hello!')
  
  ОТВЛЕЧЁМСЯ !!!
  Здесь вместо 'Hello' думаю, можно воткнуть любую отладочную информацию.
  
  Теперь нужно создать функцию для обработки данных событий. Эту фенкцию будем 
  создавать в подключенном файле со скриптами JS. Назовём её 'add_to_cart'
  Туда перенесём наш alert() а в событии укажем имя функции:
'
<div>
  <button type="button" class="btn btn-sm btn-success" onclick="add_to_cart()">Add to cart</button>
</div>
'
  Формат обычный:
function add_to_cart()
{
  alert('Hello from function!');
}
  Теперь по нажатию кнопки должна вызываться наша функция и появляться окно с надписью
  'Hello from function!'
  вместо старого 'hello!'
  
  Теперь нужно сделать передачу параметра в нашу функцию, чтобы было понятно какую 
  пиццу выбрал клиент. Добавим в функцию id пиццы.

function add_to_cart(id)
{
  alert('You added pizza with id: ' + id);
}  
  Этого id у нас пока нет. '... with id: undefined' Его нужно задать.
  Этот id задаётся в строке с кнопкой, там где указан вызов JS функции. (в скобках)
'
<div>
  <button type="button" class="btn btn-sm btn-success" onclick="add_to_cart(<%= p.id %>)">Add to cart</button>
</div>
'
  !!! Можно передавать несколько параметров, но нам здесь это пока не нужно.
  
  "Bad programmers worry about the code.
  Good programmers worry abouy data structurees and their relationships"
  
  Плохие программисты беспокоятся о коде. 
  Хорошие программисты беспокоятся о структурах данных и их взаимодействии
                                                                      Линус Торвальд
                                                                      
  Нам на этом этапе нужно чётко понимать какой будет стркурура данных нашей корзины.
  Предлагается в качестве структуры использовать ХЭШ
  
  key => value
  
  key - это будет id продукта
  value - это будет количество заказанных штук
  
  key  |  value
  -----+---------
    1  |    5
    2  |    4
    3  |    1
    
   id  |  кол-во 
   
  Для этого нам нужно реализовать увеличение количества при нажатии любой кнопки.
  Причём, так, чтобв добавалялось к нужной пицце.
  
  Напишем прототип этой функции используя Ruby, а потом перепишем её в JS
  
hh = {}

loop do
  print "Enter produt id: "
  id = gets.chomp

  print "Enter the quantity (how many item you want to order): "
  n  = gets.chomp.to_i

  x = hh[id].to_i  # read hash value (0 if it's don't exist)
  x = x + n        # increase by n
  hh[id] = x       # set hash value 

  puts hh.inspect
  puts "="*15

end

  Работает. Теперь напише то же самое, но на java script
  n у нас всегда будет = 1
  id мы уже имеем. 
  осталось реализовать чтение value из localStorage, увеличение его, и запись нового
  значения value обратно в localStorage.
  
function add_to_cart(id)
{
  var x = window.localStorage.getItem('produсt_' + id);
  x = x * 1 +1;
  window.localStorage.setItem('produсt_' + id, x);
}   
  Названия ключей решенол изменть. Вместо просто id (номера) будем использовать:
  product_1, product_2, и т.д.  
  Это нужно, чтобы различать, к чему относятся данные записи в localStorage.
  
  localStorag - всегда один. Поэтому ключи общие для всех переменных. С такими 
  ключами мы легко поймём что это за переменные.
  
  Для проверки работоспособности нашей функции НУЖНО открыть инспектор в браузере
  перейти в консоль и попробовать понажимать на кнопку.
  Если в консоле ничего не появляется, значит ошибок нет.
  Иначе там появится сообщение об ошибке и указание на строку файла в которой она
  появилась.
  
  Для контроля НУЖНО здесь же в консоле набрвть B> locaStorage
  И в консоле будет показан всё содержимое localStorage этого сайта. ПРИКОЛЬНО! 
  
  1.33.33 - localStorage - выглядит вот так. 
  
  Для очистки localStorage в косоле браузера набираем слудубщий метод 
  B> localStorage.clear()
  
  Проверьте, что всё стёрлось
  B> localStorage
  Storage {length: 0}
  
  Так можно проверить, что в localStorage записываются значения при нажатии кнопки
  и соответственно запускается функция, которая вносит в localStorage новые значения.
  
  А посмотреть их можно в консоле. по команде B> B> localStorage
  
  СДЕЛАЕМ РЕФАКТОРИНГ нашей функции. Там значение ключа вычмсляется в двух местах.
  Сделаем, чтобы было одно вычисление для обоих случаев.

function add_to_cart(id)
{
  var key= 'product_' + id
  var x = window.localStorage.getItem(key);
  x = x * 1 +1;
  window.localStorage.setItem(key, x);
}     
  
  extract variable - извлечение переменной - такой способ РЕФАКТОРИНГА.
  У каждого способа есть плюсы и минусы 
  (+ код стал короче и легче читается,имя ключа формируется в обном месте)
  (- добавилась переменная в память компьютера)
  
  Сделаем счётчик товаров в корзине.
  Для вычисления добавленных в корзину продуктов нужно пройтись по хэшу и
  посчитать общее количество элеентов в корзине.
  Сделаем этот счётчик в Ruby (для начала)
  
  
hh = {}

loop do
  print "Enter produt id: "
  id = gets.chomp

  print "Enter the quantity (how many item you want to order): "
  n  = gets.chomp.to_i

  x = hh[id].to_i  # read hash value (0 if it's don't exist)
  x = x + n        # increase by n
  hh[id] = x       # set hash value 

  puts hh.inspect
  
  # calculate total number of items in cart
  total = 0
  hh.each do |key, value|
    total = total + value
  end
  
  # puts total variable
  puts "Total items in cart: #{total}"  

  puts "="*15

end  
   
End of Lesson_33
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_34

  Из прототипа выше (на Ruby) сделаем оригинал (на JS)
  
function get_number_products()
{
  var total = 0;
  
  for (var i = 0; i < window.localStorage.length; i++)
  {
    var key = window.localStorage.key(i);
    
    if (key.search("prod")>=0)
    {
      total = total + window.localStorage[key]*1;
    }
  }
  document.getElementById("basket").innerHTML = "Your basket contains " + total + " items";
}  

}}''
  В JS есть такая функция .indexOf('something') - она возвращает номер позиции с которой начинается something 
  
  В нашем случае будет 
  B> key.indexOf('product_')
  => 0  
  то есть если 0 то в key искомое слово начинается с 0-вой позиции (сначала)  
  
  Если сделать 
  B> key.indexOf('_')
  => 7 
  с позиции №7 - восьмая по счёту (т.к. первая = 0) 
  
  А чтобы превратить номер позиции в true или false добавим ещё и условие:
  B> key.indexOf('product_') == 0
  => 0
  
  Для удобства можно добавить в конец функции add_to_kart() строку с вызовом
  всплывающего окна с общим количеством пицц. 
  Т.е. жмёшь "добавить" и сразу видишь сколько получилось пицц в корзине.
  
function add_to_cart(id)
{
  var key= 'product_' + id
  var x = window.localStorage.getItem(key);
  x = x * 1 +1;
  window.localStorage.setItem(key, x);
  alert('Items in Your cart: ' + get_number_products() );
}    
  
  Теперь всё стало очень наглядно.
  
  Сделаем кнопку в название которой напишем 'Cart (6)' 6 - это количество питц.
  Кнопку нужно сделать в нави-баре. Так она будет всегда видна при пролистывании
  страницы - если продуктов много.
  '
  <ul class="nav navbar-nav navbar-right" >
    <li><a href="#">Cart (0) </a></li>
  </ul>
  '
  Этот код нужно добавить в навибар в файл layout.erb
  
  Сейчас это некий прототип, потом мы превратим его в кнопку, и в её надписи 
  будет присутствовать параметр - количестов заказанных питц.
  
  0.42:30 - commit
  
  Чтобы сделать кнопку мы можем использовать разные способы:
  '
  <a class="btn ...
  <button class="btn ...
  <input type="submit" ...
  '
  
  Тэг <a> - означает anchor - якорь
  
  ИНТЕРЕСНО!  
  <a> - ссылка просто отправляет нас на другую страницу...
  <button> - выполняет определённую функцию, она не умеет сабмитить форму ...
  <input type="submit" - это как раз то, что нужно.
                         Мы сделаем форму, у которой не будет видно явных полей для 
                         ввода (точнее будет один параметр, но он будет скрыт)
'
<form action="/cart" method="post">
  <input type="submit" class="btn btn-primery btn-lg" value="Корзина (...)"/>
</form>
'                      
  Многие html-валидаторы ругаются на какой-либо синтаксис. Типа нельзя писать форму
  внкутри тега <li>. Но лучший валидатор - это браузер.
  
  Пробуем нажать на кнопку и если запрос пошёл на нужный адрес, то пишем код дальше.
  
  Кнопка отправляет элементы формы. В качестве элемента для начала возьмём обычное 
  текстовое поле формы.
'
  <input type="text" name="order" />
'  
  Пишем эту строку перед кнопкой. Обновляем, - появилось пустое поле.
  
  Далее нам нужно сделать так, чтобы в этом поле автоматически формировался список 
  заказанныз питц с количеством. Примерно вот так:
  "product_1=2,product_2=5,produkt_3=2"
  
  Эта запись болдна формироваться на стороне клиента 
  (потому что, информация о корзине находится в браузере, а сервер о ней не знает)
  Для этого будем использовать JS. пишем новую функцию.
  
function get_cart_orders()  // получить количество питц
{
  var orders = ''

  for(var i = 0; i < window.localStorage.length; i++)
  {
    var key = window.localStorage.key(i);          // получаем ключ (по порядку)
    var value = windows.localStorage.getItrm(key); // получаем значение через ключ
    
    if(key.indexOf('product_') == 0)
    {
      orders = orders + key + '=' + value + ',';
    }
  }
} 

  Пробуем работу нашей функции.
  
  !!! ВАЖНО ДЛЯ ПРОВЕРКИ ФУНКЦИИ НА JS:
  
  Заходим в консоль браузера и там набираем название найшей функции
  B> get_cart_orders()
  -> "product_1=2,product_2=5,produkt_3=2" 
  браузер вывел построенную функцией строку. Данные взяты из localStorage
  т.е. там должны быть заказанныепитцы. Надо по-заказывать из перед этим тестом.
   
  Теперь осталось вставить эту строчку в наше текстовое поле <input type="text"
  Чтобы по кнопке "Корзина (...)" type="submit"  эта строка из поля отправлялась на
  сервер.
  
  Наполнение строкки должно происходить в двух случаях: 
  - если мы вновь открываем сайт, то в корзине должно отображатся всё что было
  положено при прошлом визите на сервер (если такое было)
  - если мы делаем новую покупку (точнее добавляем ещё питцу в корзину)
  
  Для этого опять пишем функцию. Смотри ниже.
  Здесь пригодится информация про селекторы, через которые можно обращатся к разным
  элементам на странице. 
  Для этого добавим к каждому элементу формы (поле и кнопка) соответствующие id=""
  id="orders_input"
  id="orders_button"
  
  Теперь через атрибут id мы можем обратиться к нужному месту на странице.
  
function update_orders_input()     // Вносим готовую строку в поле
{
  var orders = cart_get_orders();  // получть строку с заказанными питцами просто
  $('#orders_input').val(orders);  // устанавливаем значение в .. с id="order_input"
      // здесь используем # 
      // т.к. это указывает, что мы обращаемся по id=
      // если использовать точку . - то значит мы обращаемся по атрибуту 'class='
      // .val() - это синтаксит jQuery
}  
  Обращение к этой функции нужно сделать в двух местах (из двух мест)
  - в завершении функции add_to_cart()
  - и при загрузке страницы.
  
  Первое сделать легко, пишем в конце функции update_orders_input() 
  
  Попробуем работу нашей функции. Жмём кнопку добавить и смотрим на поле заполнения
  
  Для теста опять можно воспользоваться консолью браузера
  B> $('#orders_input')
  Если что-то не работает можно проверить в браузере страничку исходного текста
  
  Второе сделаем 
  
  В конец файла index.erb добавим участок кода на JS
'
<script>
$(function() {

  update_orders_input();

});
</script>
'  
  Для проверки работоспособности нужно обновить страницу магазина. Строка должна появиться в поле.
  
  Тепенрь осталось скрыть это поле.
  
  Для этого нужно поменять type="text" на type-"hiden" - это работает только для 
  поля с тегом <input ...>

  Добавим теперь значение в скобки у кнопки.
  
  Напишем функцию 

function update_orders_button()  // получить надпись на кнопку
{
  var text = 'Cart (' + cart_get_number_of_items() + ')'; // получвет надпись кнопки
  $('#orders_button').val(text);
}

  Добавляем вызов этой функции на:
  - "Добавление товара в корзину"
  - в index.erb - в наш участок JS кода в нём.  (для получения надпись на кнопке при старте программы, переходе на главную страницу или обновлении страницы)
  
  Для опробования делаем в браузере 
  B> window.localStorage.clear();
  затем обновить страницу - и выводитяс (0)
  теперь набираем питцы в корзину - число увеличивается. Всё работает.
  
  jQuery - это селекторы, установка значений, 
   
RAILS - установка.

  > gem install rails
  
  Rails запускается в трёх различных окружениях:
    - development
    - test
    - production
  
  development - медленно, но решает многие задачи для программиста  
  test - вместо своей БД будет использоваться ТЕСТОВАЯ БД или ещё что-то  
  production - самый крутой тюнинг - ничего лишнего
  
  ДЛЯ СОЗДАНИЯ НОВОГО ПРИЛОЖЕНИЯ ЗАПУСКАЕМ КОМАНДУ
  
  > rails new blog
  
  Получаем новую папку с проектом 'blog'
  которая содержит 38 папок и 55 файлов (по умолчанию)
  
  1.30:00
    
End of Lesson_34
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_35

!

End of Lesson_35
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_36

!

End of Lesson_36
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_37

!

End of Lesson_37
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_38

!

End of Lesson_38
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_39

!

End of Lesson_39
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_40

!

End of Lesson_40
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_41

!

End of Lesson_41
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_42

!

End of Lesson_42
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_43

!

End of Lesson_44
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_45

!

End of Lesson_45
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_46

!

End of Lesson_46
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_47

!

End of Lesson_47
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_48

!

End of Lesson_48
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_49

!

End of Lesson_49
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_50

!

End of Lesson_50 - УРА!

! # -------------------------------------------------------------------------------
	# =============================================================== B E G I N =====
	# =================================================================== E N D =====

GIT Standart comands
  > git config --global user.name “Scott Chacon” 
  > git config --global user.email “schacon@gmail.com”
  > git init
  
  > git status
  > git add -A
  > git commit -m "Somethong..."
  
  > git log                  (выводит последние несколько коммитов (выход Q)) 
  > git log --pretty=oneline 
  > git commit -a -m "И все файлы и меседж - одной командой"   (круто!)
  
  > git checkout -b dev-01   (Создать новую ветку и переключиться на неё)
  > git checkout master      (переключение) 
  > git checkout dev-01      (переключение)

  

GIT MERGE - Слияние

								-= Шаблон Разведчика (Scout pattern) =-

  Мы не знаем, что там впереди, и мы создаёт клона (bot) и пускаем его на слияние.
  Если всё хорошо, то мы присоединяемся к результату,
  Если что-то пошло не так, то мы разрушаем клона и с ним неудачный результат слияния

1.Убедитесь, что вы находитесь на правильной ветке и 
						  что у вас чистое рабочее состояние.

    Какой бы визуализатор вы ни использовали, выясните, как он показывает вам, 
    где находится ваша текущая ветвь. 
    Или в командной строке введите, 
    ____> git status
    и вы должны увидеть что-то вроде этого:
    # On branch master
    nothing to commit (working directory clean)

2.Создайте новую ветку и переключитесь на нее.

    ____> git checkout -b test_merge. 
    Теперь, если вы наберете > git status еще раз, вы должны увидеть сообщение о том, 
    что вы находитесь в ветке test_merge .

3.Сделайте слияние.

    ____> git merge new_code
    Если вам повезет, не будет конфликтов слияния, которые вы не сможете разрешить.
    Если вы хотите прервать слияние на этом этапе, введите ____> git reset --hard.

4.Переключитесь на свой визуализатор и предскажите, как изменится его вид, 
    когда вы его обновите.

		Например:
				После слияния вы должны увидеть новый коммит.
				Новый коммит должен иметь сообщение типа 
				«Объединить ветку new_code в test_merge».
				Ваша метка ветки test_merge должна была переместиться в этот новый коммит, 
				в то время как метки ветки master и new_code 
				должны оставаться на том же месте.

5.Обновите свой визуализатор и посмотрите, был ли ваш прогноз верным.
		Вы довольны результатом?

		Если ДА: переместите основную ветку вперёд туда, 
			где находится ветка test_merge с:
			____> git checkout master
			____> git merge test_merge

    Если НЕТ: удалите ветку test_merge с помощью:
			____> git checkout master
			____> git branch -D test_merge


							-= Шаблон Точки сохраниения (savepoint pattern) =-
  
  Создаём точку восстановления
  Делаем слияние.
  Если всё хорошо - точка восстановления больше не нужна.
  Если что-то пошло не так возвращаемся на точку восстановления (разрушая слияние)
  
Вы находитесь в ветке master и хотите, чтобы изменения из ветки new_feature 
были включены в master. Вы достаточно уверены, что захотите сохранить изменения, 
но хотите иметь возможность отменить их, если, например, эта функция 
имеет непреднамеренные побочные эффекты.

1.Убедитесь, что вы находитесь на правильной ветке и что у вас чистое рабочее 
состояние.
    Какой бы визуализатор вы ни использовали, выясните, как он показывает вам, 
    где находится ваша текущая ветвь. Или в командной строке введите, 
    ====> git status и вы должны увидеть что-то вроде этого:
    # On branch master
    nothing to commit (working directory clean)

2.Создайте новую ветку для использования в качестве точки сохранения, 
    но не переключайтесь на нее.
    ====> git branch savepoint 
    Теперь, если вы наберете > git status еще раз, вы все еще должны увидеть 
    сообщение о том, что вы находитесь в основной ветке.
    
3.Сделайте слияние.
    ====> git merge new_feature 
    Если вам повезет, не будет конфликтов слияния, которые вы не сможете разрешить.
    Если вы хотите прервать слияние на этом этапе, просто введите 
                                 ====> git reset --hard.

4.Переключитесь на свой визуализатор и предскажите, как изменится его вид, 
    когда вы его обновите.
        Например:
            После слияния вы должны увидеть новый коммит.
            Новый коммит должен иметь сообщение типа 
            «Объединить ветку new_feature с мастером».
            Метка вашей главной ветки должна быть перемещена в этот новый коммит, 
            а метка ветки new_feature должна оставаться на том же месте.

5.Обновите свой визуализатор и посмотрите, был ли ваш прогноз верным.
    Вы довольны результатом?
    
				Если ДА: удалите точку сохранения.
				====> git branch -d savepoint

				Если НЕТ: сбросьте вашу ветку до точки сохранения.
				====> git reset --hard savepoint

		Если вы хотите очиститься, теперь вы можете удалить точку сохранения 
		с помощью ====> git branch -d savepoint

/* 
Здесь можно и не создавать эту точку восстановления т.к. в случае необходимости
откатится на предыдущий коммит нужно только найти его ХЭШ, а точнее начало хэша
Остальное git допишет сам. Например
====> git reset --hard 77a39
Откат прошёл, но убил ещё и коммит с new-code т.к. я ветку уже удалил,
а коммиты без ветки не живут.  (!)
*/


FAR - manager for Linux

	Для установки нужно подключить репозиторий

		sudo add-apt-repository ppa:far2l-team/ppa
		sudo apt-get update

	Зайти в sinaptic
	В поиске набрать 'far2l'
	И поставить все три пакета (отметить для установки и выполнить установку)
	Так появится программа. Far2l

	Подробнее читай здесь: https://launchpad.net/~far2l-team/+archive/ubuntu/ppa
	(там есть возможность выбора версии OS - Linux в техническом описании)

End.


СОБЕСЕДОВАНИЕ - СОБЕСЕДОВАНИЕ - СОБЕСЕДОВАНИЕ - СОБЕСЕДОВАНИЕ - СОБЕСЕДОВАНИЕ 

https://gist.github.com/ryansobol/5252653

Lessom 32
Что такое 'class' - класс это шаблон, который содержит данные,
                          имеет методы, которые взаимодействуют с этими данными
                        и используются чтобы создавать объекты на основе этих классов
                        
Что такое 'object' - это экземпляр класса.
                   - это коренной класс Ruby
  
Что такое 'modules' - это NameSpace (Пространство имён) 

                    module MyModule
                    
                      class Myclass1
                        def mymethod1
                          ...
                        end
                        def mymethod2
                          ...
                        end
                        ...
                      end
                      
                      class Myclass2
                        def mymethod1
                          ...
                        end
                        def mymethod2
                          ...
                        end
                        ...
                      end
                      ...
                    end
                    
        Вызывается следующим способом
        MyModule::Myclass1.method2
        
        MyModule::Myclass2.method2        

        ActiveRecord::Base
        
        Модули предоставляют множественное наследование с помощью 'mix-ins'.
        Mix-in служит для расширения классов:
        module AMixIn
          def who_am_i?
           puts "An existentiolist, thst's who."
          end
        end
        
        class DeepString < String
          extend AMixIn
        end   
        Так новый класс унаследовал все свойства от родительского класса String
        и ещё он расширен (extend) методами модуля AMixIn
        
        Это способ расширения класса.
        
Три уровня доступа для модулей и классов (что они означают)?    

    Public    - всё по-умолчанию есть public 
              - все методы имеют доступ извне p = Animal.run - работает
    Privat    - эти методы будут недоступны извне, но доступны изнутри 
    Protected - (защищённые) могут быть доступны только для дугих объектов того же 
                самого класса.
                
В РЕЗЮМЕ - должна быть "драмма". - Почему я решил стать программистом.
                Готов работать в выходные, работать с переработкой 
                (Готов пройти лишнюю милю для компании)
                
    РАБОТУ ПОЛУЧАЕТ ТОТ, КТО МОЖЕТ СЕБЯ ХОРОШО ПРОДАТЬ!
    На работе преуспивает тот, кто может хорошо продать свои навыки!
    
Lesson 33

ТРИ СПОСОБА ВЫЗВАТЬ МЕТОД RUBY

  Первый способ: 
                  animal = Animal.new
                  animal.run               - вызываем метод.
                  
  Второй способ:
                  animal.send(run)         - вызываем метод.
                  
  Третий способ:
                  animal.method(:run).call - вызываем метод. 

ЧТО ОБОЗНАЧАЕТ ЭТА КОНСТРУКЦИЯ: a ||= b

  .
  
ЧТО ОЗНАЧАЕТ Self

    Класс - это тоже объект в Ruby
    class WhatIsSelf
      
      def test
        puts "At the instance level, self is #{self}"
      end
      
      def self.test
        puts "At the class level, self is #{self}"
      end
      
    end
    
    WhatIsSelf.test
    #=> At the class level, self is WhatIsSelf                     (на уровне класса)
    
    WhatIsSelf.new.test
    #=> At the instance level, self is #<WhatIsSelf:0x28190>   (на уровне экземпляра)
    
    Второй иметод в классе - это статический метод в java, c#, ... 
    Кода мы вызываем '.test' но не создаём оюбъект, то вызывается именно он.
    Этот метод может работать без создания объекта.
    
    Первый метод вызывается когда создаётся объект (экземпляр класса)
    0x28190 - это место в памяти (где хранится этот экземпляр)
    
    self всегда указывает на текущий объек.
   
   
ЧТО ТАКОЕ Proc

    Это процедуры, их существует три типа:
    
    1. Ананимные методы. Nameless function - (функция без имени)
    anonymous = Proc.new { puts "I'm a Proc for sure." }
    Вызывается просто anonymous.call
    Этот наш метод можно передать как параметр в другой метод и вызвать его оттуда.
    
    2. Лямбда-функция. Очень похожа на на предыдущую.
    nameless = lambda { puts "But what abbout it?" }
    Мы можем её использовать как перемнную и поместить её в хэш.
    Используя этот хэш можно вызывать её (см. Однорукий бандит) Далее фрагмент:
    
    add_10 = lambda { |x| x+10 }
    add_20 = lambda { |x| x+20 }
    hh = { 1 => add_10, 2 => add_20 }
    s = 100
    loop do
      a = rand(0..10)
      if hh[a]
        puts "Комбинация #{a}"
        s = hh[a].call s
      else
        s = s - 1
      end
      puts "Баланс = #{s}"
      gets
    end
    
    3. Функция типа блок "do .. end"
    Тоже моржет быть передана в параметрах и вызывается с помощью yield
    def three_way(proc, lambda, &block)
      proc.call
      lambda.call
      yield # как block.call
    end
    
    anonymous = Proc.new { puts "I'm a Proc for sure." }
    nameless = lambda { puts "But what abbout it?" }
    
    tree_way (anonymous, nameless) do
      puts "I'm a block, but could it be???"
    end
     #=> I'm a Proc for sure.
     #=> But what abbout it?
     #=> I'm a block, but could it be???
     
КОГДА НУЖНО ДЕЛАТЬ РЕФАКТОРИНГ КОДА?

    ВСЕГДА!
    Сложность программы постоянно умкличивается. Поэтому РЕФАКТОРИНГ нужно делать
    постоянно. Упрощение часто ведёт к улучшению читабильности кода.  
     
Lesson 34

    X ||= Y    - что это означает?
    
    X op = Y 
    
    X += 1    X = X + 1
    
    Наше выражение это X = X || Y 
    Как оно выполняется 
      сначала выполняется X || Y
      а потом результат присваивается X
      
      X || Y   - это OR - догическое "или" 
    
    Поэкспериментируем в консоле > irb  
    irb> nil || 4
    => 4
    
    irb> false || 2
    => 2
    
    Ruby если видит что первый параметр не подходит, то берёт второй параметр,
    а если первый параметр подходит, то второй параметр даже не рассматривает!    

    irb> 123 || 2
    => 123

    Это свойство используется для установки значения по-умолчанию в Ruby.
    Например при вызове функции
      если какое-то значение не определено, то используется значение по-умолчанию.
      но а если оно есть, то используется то, которое есть.
      
Lesson 35

    .      
======================== МОИ СКАКУНЫ ========================
В подвал layout.erb нужно поместить специальный код, который позволит выводить
любую переменную (в виде хэша key => value ) в целях тестирования. 
Назвать её можно 
$bebugs = 
[ 
  { 'a'=>'s', 'b'=>'d2', 'c'=>45, ...}, 
  {...},
   ...
]
-------------------------------------------------------------   
