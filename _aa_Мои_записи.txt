1234567890123456789012345678901234567890123456789012345678901234567890123456789012345
         1         2         3         4         5         6         7         8  
Lesson_02 ---------------------------------------------------------------------------

ОПЕРАТОР puts.

	puts "Hello"

	puts - это put string (положить строку)


ЗАПУСК ПРОГРАММЫ. 
	В терминале, в папке с программой набираем
	следующую команду: 
	# ruby app1.rb
	(где app1.rb - это сама программа на Ruby)


СООБЩЕНИЕ ОБ ОШИБКЕ.
	Может появиться в терминале, следующего вида:
	app1.rb:3:in `main': undefined local variable or method `....
	Это говорит, что на третьей строке встретился оператор 	или перемнная, 
	которую Ruby не может обработать.


СОЗДАНИЕ КОМЕНТАРИЯ.

	Для создания коментария используется знак # 
	Всё, что после этого знака - это коментарий 
	Новая строка уже не будет кометарием.


ОПEРАТОР gets

	gets - написанный в конце программы остановливает программу и ждут ввода данных 
		   с клавиатуры (или просто Enter)
	

ОПЕРАТОР print
	
	опрератор print не переводит строку, в отличии от puts
	
	Удобнее использовать оба оператора:
	print "Enter your name: "
	my_name = gets
	puts "Hello " + my_name	
	
	
СПЕЦИАЛЬНЫЕ СИМВОЛЫ.

	\n - (new line) - новая линия
	
	
МЕТОД .chomp

	my_name = gets 		- здесь Имя и Enter
	my_name = gets.chomp	- здесь Имя (а Enter - удалился)
	(см.пример: app6.rb)
	
	Этот метод удаляет только символы переноса в конце строки.
	Второй раз применять данный метод не имеет смысла т.к. символов переноса строки 
	уже не бeдет.


End of Lesson_02
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_03

irb - 
	Выход из него по команде exit или quit 
	Ctrl + C - прерывает выполнение irb при зависании или зацикливании.
	Если запустить irb в терминале, то можно попробовать как работает та, 
	или другая команда.

	В этой оболочке:
	> + 2 * 2 
	=> 6

	> puts 2 + 2 * 2
	6
	=> nil
 
	здесь nil - это нулевой объект.

	Чтобы определить тип данных нудно в irb сделать:
	> 1.class
	=> Fixnum

	> "asdasdasd".class
	=> String

	> 2.14.class
	=> Float


ТИПЫ
	String	"aa" "2"
	Fixnum	2 22 100000 2^30
	Bignum	2^30+1 ... и более
	Fload   3.14 29.5
	Array	[...]
	Hash	{...}
	
	Fixnum + Bignum = Integer

	
МЕТОД .to_i 

	to Integer
	Преобразование к целому числу, обычно используется к тексту, что бы результат 
	был пригоден для вычислений.
	(см.пример: app7.rb)
	
	> 'gdhjkduhekufh'.to_i 	# => 0


МЕТОД .to_f 

	to Float
	Преобразование к типу с плавающей точкой.
	(см.пример: app8.rb)

	
МЕТОД .to_s 

	to String
	Преобразование к типу строка 	


End of Lesson_03
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_04


	Существует множество вариантов написания кода, например:
 
	x = gets 	# если ожидаем строку (или символ)
	y = gets	# если ожидаем целое число
	z = gets	# если ожидаем вещественное число

	x = x.chomp
	y = y.to_i
	z = z.to_f

	... аналогичное решение можно записать следующий вариант:

	x = gets.chomp
	y = gets.to_i
	z = gets.to_f


ИНТЕРПОЛЯЦИЯ СТРОК.

	Применяется для вывода строки на экран, позволяя не задумываться о типе выводимой
	перемнной. Выглядит это так  "#{ ... }"

	В программе будет выглядеть так:

	x = 5
	puts "x = #{x}"

	На экран будет выведено: х = 5


КОДИРОВКА ЛИСТИНГА.

	Ruby по-умолчанию использует кодировка UTF-8
	Но под Windows использование русского шрифта в RUBY приводит к различным ошибкам.
	В Linux и Mac таких проблем нет. 
	
	Чтобы в Windows переключить ruby на русский шрифт нужно вначале файла написать 
	такую строку:

	# encoding: cp866

	cp - это 'code page' - кодовая страница
	866 - это номер кодовой страницы, используемой в консоли Windows
		  по-умолчанию в рускоязычной версии Windows.
		  
	Все символы этой специальной строки должны быть записаны в Ваш файл.


МЕТОД .chomp

	Есть ещё один способ обрезать символ переноса курсора на новую строку \n  
	Он заключается в следующем. Раньше мы писали так:
	
	str = str.chomp

	а можно писать короче и понятнее:
	
	str.chomp!

	здесь ! указывает, что действи выполняется над самой переменной.
	Так запись выглядит нагляднее и короче.
	

МЕТОД .methods

	Выводит список всех операций, которые мы можем сделать с данной пременной 
	(объектом). Этот список разный для разных переменных и типов.
	Это очень полезно, если Вы хотите вспомнить какой-то метод, но не 
	помните как он пишется. Например метод .size
	
	Запоминать их все не нужно. О них можно прочитать в документации по адресу: 
	WEB http://www.ruby-doc.org/core-2.1.1/String.html	
	
МЕТОД . size
	
	Выводит длину данной переменной. Для разных переменных будут получены разные 
	значения.
	
	x = "aaabbb555"
	puts x.size

	выведет длину данной строковой переменной, т.е. 9

	то же в irb
	
	> x = "aaabbb"
	"aaabbb"

	> y.size
	6

	
МЕТОД .empty?

	Вывводит результат проверки на пустоту. Знак ? говорит, что здесь возможно только
	два варианта резкльтата:
								true - Истина
								fals - Ложь
	
	y = ""
	puts y.emty?

	напишет true - Верно.
	
	то же в irb

	> y = ""
	nil

	> y.empty?
	true

WEB http://www.ruby-doc.org/core-2.1.1/String.html
	адрес, где можно прочитать документацию по String
	
!!! Очень хорошо, если брать пример из этой документации и попробоватm выполнить эти 
	примеры в irb. Можно поменять что-то в этих примерах и посмотреть как работают 
	методы для String перемнной.
	

МЕТОД * integer
	метод позволяет повторить строку "ааа" заданное количество раз. 
	Типа "ааа" * 3 получиться "ааааааааа" т.е. три раза "ааа".
	
	Обратная запись типа 3 * "ааа" - это работать не будет, т.к. операция * 
	применяется к String и затем должен быть Integer
	
	Overloading - перегрузка 	

	
WEB http://www.ruby-doc.org/core-2.1.1/Integer.html	
	адрес, где можно прочитать документацию по Intager

	
МЕТОД .even? 
	
	Возвращает true если число чётное.

	
МЕТОД .odd?

	Обратный метод, методу .even? 

	
МЕТОД .next

	метод возвращает следующее число, например 50.next выводит 51


МЕТОД .pred

	метод возвращает предыдущее число, например 50.pred выводит 49


WEB https://www.kickstarter.com/ 
	Ресурс для сбора денег на новый проект. Вы описываете свою идею, а люди со всего 
	мира собирают сумму для его реализации. Если, конечно, вы их убедили своими 
	аргументами!	


МЕТОД .times
	
	метод повторяет указанное число раз блок, который указан в фигурных скобках, 
	есть два способа использовать его (с параметром или без)
	
	ПЕРВЫЙ ВАРИАНТ - (без параметра)
	формат записи 10.times { puts "Hello" }
 	пример работы этого метода можно посмотреть в irb
 	этот пример выведет на экран 10 раз слово "Hello"
 	
 	s = "aaa-s"
	n = 5
	n.times { print s }	
	
	"aaa-saaa-saaa-saaa-saaa-s"
	
	ВТОРОЙ ВАРИАНТ - (с параметром)
	использования ментода .times (с параметром)
	формат записи 10.times { |i| puts i.to_s }
	пример нужно попробовать в irb
	этот пример выведет на экрае числа от 0 до 9 (включ)
	всего 10 чисел, всегда начинается с 0 (zero)
	
	> 100.times { |i| puts "i = #{i} " }
	
	i = 0
	i = 1
	...
	i = 99
	
	Вертикальные строки - это труба (pip), в которой пишется переменная параметра для
	данного блока { ... } 
	
	За пределами данного блока параметр i уже не существует.
	Он живёт только внутри этого блока.
	
	> 51.times { |i| puts "i = #{i}, even: #{i.even?} " }
	выводит:
	i = 0, even: true
	i = 1, even: false
	i = 2, even: true
	...
	i = 50, even: true
	
End of Lesson_04
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_05	
	
МЕТОД .upto  

	Метод "вверх до" перебирает числа от 5 до 15 ВВЕРХ (возрастание)
	В варианте 10.times выводит от 0 до 9 (всегда от 0)
	
	> 5.upto(15) { |x| puts x }
	выводит:
	5
	6
	....
	14
	15
	
!!! В программировании обычно принято использовать: 
	i и j - для обозначения итератора (повторителя) или индекс. 
	n и m - как натуральное число.
	
МЕТОД .downto

	Метод "вниз до" перебирает числа от 15 до 5 ВНИЗ (убывание)
	Например:
	
	> 15.downto(5) { |x| puts x }
	выводит:
	15
	14
	13
	...
	6
	5
	
	
МЕТОД .capitalize

	Метод делает большой первую букву и делает маленькими все остальные.
	
	
ТРАНС: workaround - существует метод обход этой проблеммы.		

	
МЕТОД .strip
	
	метод обрезает все пробелы, табуряция, конец строки и ... 
	всё это есть = whitespase (белое пространство)
			

СИМВОЛЫ СПЕЦИАЛЬНЫЕ

	\n	# На новую строку (new)  
	\t	# Табуляция (tab) e.g.: > pust "\tВася"
	\r	# Перевод коретки в начало текущей строки (return) 
	\\	# Выод на экран символа \
	Эти симыолы работают только в " ", и не работают с ' '.
	
	\n - Line feed (LF)
	\r - Carriage Return (CR)
	
	Часто пишется \r\n  или  cr lf
	
	С помощью \n символа можно вывести две строки одной командой:
	> puts "Line-1 \nLine-2" 
	
	Чтобы вывести сам этот спец символ нужно использовать двойной:
	> puts "\\n" # => \n
	> puts "\\r" # => \r

	
End of Lesson_05
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_06		

МЕТОД .sleep 1

	Ждёт 1 секунду. 
	> sleep 0.05
	
		
БЛОКИ - бывают разные:
	
	1. Бок фигурные скобки { .. }
	Используется если пишется один оператор и в одну строку.
	10.times { puts 'aa' }
	10.times { |i| puts i }
	
	2. Блок do .. end 
	Используется если нужно написать несколько операторов.
	10.times do
	  puts ...
	  print ...
	  gets ...
	end
	
	10.times do |i|
	  puts i
	end    
	
	БЛОКИ МОЖНО ВКЛАДЫВАТЬ ДРУЗ В ДРУГА
	10.times do |i|
		print "Hello"
		
		x.times do
			print "!"
		end
		
		puts
	end
	
	Или то же самое сильно короче но (менее понятно):
	
	10.times { |i| puts "Helo#{'!'*i}" }
	
	(1..10).each { |x| puts x }	

МЕТОД rand(5)

	rand 5 Выдаёт целые числа 0,1,2,3,4	
	rand 1000 выдаёт целые числа от 0 до 999
	rand (10..20) выдаёт целые числа от 9 до 19
	rand (11..21) выдаёт целые числа от 10 до 20
	rand (0.03..0.09) выдаёт действительные числа из диапазона
	
	
End of Lesson_06
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_07

!!! Переменная, объявленная внутри блока (в пайпах) будет действовать только внутри 
	своего блока. После выхода из блока она уничтожается.
	
!!! Sublime Text 3

	Изменение переменной среды:
	<Win> + <Print Screen>	- 
	или
	Мой комп 
		- Свойства 
			- Изменить параметры 
				- Перемнные среды 
					- PATH 
						- Изменить
						и вводим в поле
	PATH = 'c:\tools\sublime3'
	Note: если там уже что-то есть, то ставим ; и пишем наш путь
	
	Пкреименовали 'sublime.exe' to 's.exe'
	Теперь для открытия достаточно набрать 's app2.rb' и наш файл откроется в новом 
	редакторе SubLime.

ОПЕРАТОРЫ СРАВНЕНИЯ

	== - равно
	!= - НЕ равно
	<= - меньше или равно
	>= - больше или равно
	<	- меньше
	>	- больше
	=== - строгое сравнение
	
METHOD if - (Если)	

	if a == 4
		puts a
	end
	
	if а == 4
		puts 4
	else
		puts '-'
	end			

	if a == 4
		puts 4
	elsif f == 5
		puts 5
	elsif a == 7
		puts 7
	else
		puts '-'
	end				

	if a == 4 && b == 8		# Если (первое условие) и (второе условие) 
		puts a*b
	end	

	if a == 4 || b == 8		# Если (первое условие) или (второе условие) 
		puts 'Ok'
	end

METHOD exit - (выход)

	Этот метод останавливает выполнение программы.
	
		
!!! Программу пишут не для того чтобы компьютер её лучше понимал, а для того, 
	чтобы програмист эту программу легко мог читать, и конечно поняв её смог вносить 
	в неё изменения.


End of Lesson_07
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_08

	x = 1_000_000_000
	y = 43_568.67


!!! Эффективность программиста = 15 строк в день. Очень часто ты что-то пишешь, 
	потом что-то удаляешь, потом ещё что-то пишешь, опять удаляешь, тестируешь, 
	исправляешь, удаляешь и добавляешь и в итоге программист в среднем пишет 
	15 строк в день.	
	
	
КАЛЬКУЛЯТОР

	print 'Enter A: '
	a = gets.to_f
	
	print 'Enter B: '
	b = gets.to_f
	
	print 'Enter Your action ( + - * / ): '
	op = gets.strip
	
	if op == '/' && b ==0
		puts "It's Error. Divisy by zero!"
	end	

	if op == '+' 
		rezult = a + b
	
	elsif op == '-'
		rezult = a - b
	
	elsif op == '*'		
		rezult = a * b
		
	elsif op == '/'
		rezult = a / b
	
	else
		puts 'Bad action'
		exit
	end

	puts "#{a} #{op} #{b} = #{rezult}"

	
METHOD breack

	Позволяет выйти из текущего блока.
	
	if  a == 4
		puts
		print
		
		breack # Выйти из if-блока
		
		puts # не выполнится 

	end
	puts # Сюда переходит управление после breack
	
	
METHOD while 

	while a == b 
		puts
		puts
	end	
	
	Пока условие a == b есть true  блок будет выполнятся постоянно.
	Как только это условие станет false то программа выйдет из блока.


METHOD .reverse

	перевернуть строку (в обратном порядке)
	

METHOD .each - (каждый)
	
	Перебирать каждый элемент
	
	
RANGES

	(1..10).each { |x| puts x }
	1..5 	1 2 3 4 5
	1...5	1 2 3 4	
	
	('a'..'s').each { |x| puts x }
	('aa'..'bs').each { |x| puts x }

	('10a'..'20s').each { |x| puts x }


!!! Ruby Shoes - GUI framework - для написания программ с графической оболочкой. 
	Искать лучше на stackoverflow.com 
	
	Запрос: ruby linux gui frameworck site:ctackoverflow.com
	
	shoesrb.com
		
End of Lesson_08
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_09

- ЛЯМБДА ВЫРАЖЕНИЯ или ДЕЛЕГАТЫ

	Это указатель на функцию. 
	
	
- ХЕШ - это структура данных.	


ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ

	@bbb - глобальная переменная, т.е. она будет доступна везде, и в основной 
	программе, и в процедурах, и в функциях ...
		   

ФУНКЦМЯ - МЕТОД - ПРОЦЕДУРА - ПОДПРОГРАММА - это всё одно и то же.

	Как ОПРЕДЕЛИТЬ метод?
	
	def get_password
	end
		
	# def - это define - (определить)
	# Процедуры пишутся для многократных запусков Reuseble.
	
	e.g.:
	
	def get_password
		print "Type password: " # Введите пароль
		return gets.chomp
	end
	
	xx = get_password
	
	puts "Был введён пароль: #{xx}"	
	
	# по оператору return возвращается значение из этого метода и прерывание 
	# выполнения процедуры (возврат).
	# по-умолчанию Ruby возвращает результат последнего выражения т.е. в нашей 
	# процедуре можно удалить слово return получится вот так: 
	 
	def get_password
		print "Type password: " # Введите пароль
		gets.chomp
	end
	# чаще всего return не пишут (опускают)
	# return - говорит: что нужно вернуть из функции.
	
	# в качестве последнего выражения может быть использовано:
	2 * 2
	gets.chomp * 3
	
	# В процедуру можно передать параметры
	# Параметр пишется после имени процедуры
	# Значение этого параметра указывается в строке вызова процедуры
	
	def print_greting name
		puts "Hello, #{name}"
	end
	
	print_greting "Roman"
	 
	# Внутри метода все переменные определяются заново, т.е. они не связаны с 
	# переменными в основной программе. 
	#                                    (кроме переменных переданых как параметр)
	
	# Другой способ передать перемнную в процедуру - это определить переменную как 
	# глобальную. У глобальной перемнной вначале есть специальный символ @
	

ОБЪЕКТЫ = ЭКЗЕМПЛЯРЫ КЛАССА = instance - (экземпляр)	   	
	
	HEAP MEMORY - (куча памяти)


SYMBOL
	
	1000.times
		"aaa"
	end	
	
	# Программа создаст 1000 "aaa" в памяти, и это займёт 1000 мест  
	# (когда программа закончится, то эта память освободится)
	#
	# Однако:
	# Если создать symbol то он займёт всего одно место в памяти.	 
	
	1000.times
		:aaa
	end	
	
	# symbol - используется для ускорения и оптимизации.
	# это очень обосновано, если используются повторения ...
	# при повторении не используется новые места в памяти.
	
	С символами можно работать как с обычными строками-константами
	a = :abba
	b = :music
	puts a
	
	> 'aaa'.object_id 	# => 288293290
	> 'aaa'.object_id 	# => 288390023
	# одна строка - два разных объекта
	
	> :aaa.object_id 	# => 703688
	> :aaa.object_id 	# => 703688
	# один символ - один объект
 
 	
METHOD .equal?

	Сравнивает объекты.
	> "aaa".equal? "aaa" 	# false
	> :aaa.equal? :aaa 		# true	
	
	
МАССИВ - Array - набор объектов	(Начало)
	
	http://www.ruby-doc.org/core-3.  /Array.html
	Массивы - гомиаморфны (числа + строки + ...)
	14, 22, 31, 5, "Вася", 44, 88, 
	
	определяем массив следующей командой:
	arr = []			 - пустой массив	
	arr = [14, 22, 31]   - три элемента в массиве
	
	e.g.:
	arr = [1, 22, 38]
	puts arr
	arr << 17		# добавление элемента в массив
	arr << 'food'	# ещё добавим элемент
	puts arr
	puts arr.size	# размер = 5 элементов
	
	
METHOD .uniq

	Отобрать уникальные (исключить повторение значений)
	
	
End of Lesson_09
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_10

МАССИВ - Array - набор объектов	(продолжение)
	
	Способы инициализации массива
	
	arr = []
	arr = ["Roma", 32]
	arr << "Mike"
	arr = %w[Roman 32 Mike]
	arr = [:left, :right, ...]
	arr = Array.new
	
	Элементы в массиве имеют индекс. Индекс начинается с 0
	
	Получить доступ к конкретному элементу массива можно получить через
	его индекс (полядковый номер в массиве).
	
	a = arr[0] 	   # возвращает первый элемент массива
	b = arr[-1]    # возвращает последний элемент массива
	c = arr[-2]    # возвращает второй элемент с конца массива
	d = arr[1..3]  # возвращает 2,3,4 элементы
	e = arr[1...3] # возвращает 2,3 элементы
	
	Между следующими далее двумя способами задания массива есть разница
	arr = ["bot", "tom", "cat", 22]
	arr = %w[bot tom cat 22]
	элемент 22 во втором случае - есть строка "22", а не число. 
	
	# Способ вывода элементов через блок (позволит обработать элементы)
	arr = ["bot", "tom", "cat", 22]
	x = 0
	arr.each do |item|
		puts "#{x} #{item}"
		x = x + 1
	end
	
	# .each - это каждый	
	
	arr = ["bot", "tom", "cat", 22]
	puts arr[1..3][0]
	#
	# ["tom", "cat", 22] - получили новый массив [1..3]
	# ["tom"]			 - получение новый массив [0]
	# 
	
	# Удаление элементов в массиве
	# item   0      1      2     3    
	arr = ["bot", "tom", "cat", 22]
	arr.delete_at 0  # удалится "bot"
	arr.delete 22    # удалится 22
	
	# Многомерный массив
	#
	arr = ["bot", "tom", "cat", 22]
	arr1 << arr
	arr = ["boy", "man", "boss"]
	arr1 << arr
	#
	# [["bot", "tom", "cat",   22], ["boy", "man", "boss"]]
	#                                     				
	#   |_0_|, |_1_|, |_2_|, |_3_|	 |_0_|, |_1_|, |__2__|   - 2 level
	#
	#  |_____________0___________|, |_________1__________|   - 1 level	
	#

	# ПРОГРАММА "Имя - Возраст"
	#
	arr = []

	loop do

		arr0 = []
		
		print "Введите имя: "
		name = gets.strip
		
		break if name == ""
		
		print "Введите возраст: "
		age = gets.strip
		
		arr0 << name
		arr0 << age
		
		arr << arr0
		
	end

	x=0

	arr.each do |item|
		x = x + 1
		puts "#{x} #{item[0]} #{item[1]}"
	end
	#
	# конец программы "Имя - Возраст"

METHOD .each_with_index

	перебирает элементы массива используя его элемент и его индекс

	Из 11 урока:
	
	arr = ["bot", "tom", "cat", 22]
	
	arr.each_with_index do |item, i|
		puts "#{i+1} - #{item}"
	end
	

End of Lesson_10
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_11

СОБЕСЕДОВАНИЕ

	Есть a=50 b=20 поменять значение перемнных    (без использования третьей)
											
	В Ruby есть такой синтаксис a, b = b, a
	- это для любых объектов
	
	или
	
	a = a + b
	b = a - b
	a = a - b
	- это для действительных чисел и целых в том числе


METHOD break 

	Метод позволяет выйти из цикла.
	
	loop do
		...
		break if a == 5 
		...
	end


ХЕШИ - Hash - Key value storage - (Ключ-значение Хранилище)

	Структура данных. Чэш это не фишка Ruby. 
	Ещё называют как: 
		Dictionary или 
		Hashtable или
		Ассоциаливные массивы
		NOSQL - No only SQL

	Хэш определяется следующим образом:

	hh = {}    - это хеш
	arr = []   - это массив
	
	Как ввести данные в Хэш:
	
	hh = {'Mike' => '35373', 'Jessie' => '31380'}
	#      key       value     key        value

	hh = {:left => 1234567}
	#      key      value
	
	=> - hash rocket - (хеш-ракета)

	Хеши часто используются как параметры:
	options = {:font_size => 10, :font_family => 'Arial', arr => [1,2]}

	Чтобы получить какое-либо значение из хэша нужно указать ключ:
	#
	x = options[:font_size]  
	puts x 						# = 10
	
	Как добавить значение в хеш? 
	#
	hh [ key ] = value
	#
	hh[:Mike] = '353747'
	#
	hh['boss'] = 'Sergey Evstifeev'
	hh['boss_phome'] = 9278154329
	hh[aaa] = bbb
	
	     !!! ключ в хэше должен быть уникальным. !!!	
	
	Для перебора хэша в целях обработки или вывода на экран
	#
	hh.each do |key, value|
		puts "#{key} - #{value}"
	end	
	# в хеше нет гарантии, что элементы будут выведены по порядку.


End of Lesson_11
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_12

ХЕШИ - Hash - Key value storage - (продолжение)

	Тип  key  в хэше - может быть любым
	Тип value в хэше - может быть любым	
	
	k = hh.keys		# массив ключей
	v = hh.value	# массив значений

	hh.each do |key, value|
		...
	end
		
	# Можно пройтись по всем ключам или по всем зачениям:
	hh.each_key do |key|		# - перебираем ключи
		...
	end
			
	hh.each_value do |value|	# - перебираем значения
		...
	end

METHOD .has_key?
		
	Чтобы проверить, есть ли такой КЛЮЧ в хэше:
	hh = {'cat' => 'кошка'}
	hh.has_key? 'cat'  # => true / false
			
	# используется в условиях.
	if hh.has_key? 'cat'				# результат = bolean
		puts 'В словаре есть кошка'
	end
	
	if hh['cat'] 						# результат = bolean
		puts 'В словаре есть кошка !!'
	end 
	
	puts 'никогда не сработает' if nil 	
	# nil преобразуется в false
	
	
METHOD .has_value?

	Чтобы проверить, есть ли такое ЗНАЧЕНИЕ в хэше:
	hh = {'cat' => 'кошка'}
	hh.has_value? 'cat'  # => true / false

	
ФУНКЦМЯ - МЕТОД - ПРОЦЕДУРА - ПОДПРОГРАММА - (продолжение)
	
	# В процедуру передаются параметры используюя хэш:
	#
	def print_details details
		puts details[:name] if details[:name]
		puts details[:age] if details[:age]
		puts details[:address] if details[:address]
	end
	
	hh = {:name => 'Mike', :age => '42', :address => '123 West Street'}	
	
	print_details hh
	# 
	# Здесь теперь, если даже в хэше будут указаны не все парамертры, то не возникнет
	# ошибки, т.к. в процедуре обработка происходит по условию существования данных в
	# хэше.
	

End of Lesson_12
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_13

ПЕТЛИ - ЦИКЛЫ и выходы из них

	# Петля (бесконечный цикл) и выход по условию
	loop do
		...
		break if ...
		...
	end
	
	# Петля (бесконечный цикл) и выход по условию
	while true
		...
		break if ...
		...
	end
	
	# Процедура и нестандартный возврат по return с результатом ...1
	def name
		...
		return ...1
		...
	end
	
	# Завершение выполнения программы. Из любой точки.
	exit
	#
	
СОЗДАНИЕ ХЭШЕЙ и МАССИВОВ              (в тетрадь)

	hh = {}		или hh = Hash.new
	
	arr = []	или arr = Array.new
	
	# Способы наполнения массива:
		arr = ["bot", "tom", "cat", 22]
		arr << 'bag'
		
	
	# Способы наполнения хэша:
		hh['Mike'] = 65
		hh['Jessie'] = 25
	# или
		hh = {'Mike' => 65, 'Jessie' => 25}
	#
	
ВЫВОД ХЭШЕЙ

	puts hh
	#
	puts hh.inspect
	#
	hh.each do |k, v|
		puts "#{k} - #{v}"
	end

	# Вывод ключей хеша
	puts hh.keys
	puts hh.keys.inspect

	# Вывод значений хеша
	puts hh.values
	puts hh.values.inspect

	# работа с ключами, через ключи
	hh.keys.each do |key|
		value = hh[key]
	end	
	
	# работа со значениями 
	hh.value.each do |value|
		...
	end

ОЧИСТКА ХЭША

	hh.clear
	
ПРОВЕРКА НА НАЛИЧИЕ ключа В ХЭШЕ	

	# 
	if hh.has_key? 'Mike'
		puts hh['Mike']
	end
	
	# то же, но более короткий синтаксис
	if hh.key? 'Mike'			# сокращённый синтаксис
		puts hh['Mike']
	end		

	# ещё способ проверить наличие ключа
	if hh['Mike']
		...
	end
	
	# самый короткий способ проверить наличие записи с ключём в хэше
	... if hh['Mike']


ПРОВЕРКА НА НАЛИЧИЕ значения В ХЭШЕ	

	# 
	if hh.has_value? '64'
		...
	end
	
	# то же, но более короткий синтаксис
	if hh.value? 65				# сокращённый синтаксис
		...
	end		


УДАЛЕНИЕ ЗАПИСИ из ХЭША

	# Удалить их хэша можно только целитком всю пару.
	# отдельно key или value не получится, можно только заменить 
	# она так и называется: key-value pair
	# 
	hh.delete 'Mike'


ОПРЕДЕЛЕНИЕ ПРОЦЕДУРЫ

	# app18.rb - листинг программы для запуска
	@hh = {}
	def add_person name, age
	# добавляет пару в хэш
		puts 'Already exsist!' if @hh[name]
		@hh[name] = age
	end
	
	def show_hash 
	# выводит полностью весь хэш
		@hh.each do |key, value|
			puts "#{key} - #{value}"
		end
	end
	
	loop do
	# 
		print 'Enter name: '
		name = gets.chomp.capitalize
		
		break if name = ''
		
		print 'Enter age: '
		age = gets.to_i
		
		add_person name, age
		
		show_hash 
		
	end 	

!!! Если всё плохо получается, то это значит, что есть прогресс.
	Если всё быстро получается, значит это слишкои просто для Вас и значит 
	нет прогресса.

ПЕРЕДАТЬ ПАРАМЕТВЫ В ПРОЦЕДУРУ. с помощью ХЭША!
	
!!!	Передавать параметры в процедуру удобнее с помощью хэша, 
	в котором количество параметров может быть разным,
	т.е. можно будет "опустить" часть параметров.
	
	При этом, во время обработки этих входных параметров внутри процедуры нужно будет
	проверять наличие каждого конкретного параметра.
	
	Выигрыш в том, что при вызове процедуры указывается только имя хэша options 
	например, а в него заводятся те, параметры, которы нужны для обработки.
	
	Теперь уже не так важен порядок передаваемых данных.
	Это создаёт дополнительную гибкость.
	
	# В данной  ситуации в качестве ключей нужно использовать символы	Например, 
	# формируем данные в хэш для передачи их в процедуру:
	hash_opt = { :name => 'Igor', :age => 45, :phone => '234-654-45-90'}
	
	# вызываем процедуру:
	save_person hash_opt
		
	# процедура будет выглядеть следующим образом:
	def save_person options
		@hh_phone[options[:name]] = options[:phone] if options[:phone]
		@hh_age[options[:name]] = options[:age] if options[:age]
	end
	 
	предыдуший пример программы в файле app18.rb  был переработан и
	пример использования смотри в файле app18+.rb

	# сформировать хэш можно и непосредственно при вызове процедуры:
	save_person ({:name=> 'Igor', :age=> 45, :phone=> '234-654-45-90'})
	# здесь дополнительные круглые скобки - обязательны!
	
	# или ещё
	save_person :name => 'Igor', :age => 45, :phone=> '234-654-45-90'
	# порядок параметров - не важен.  Важно только значение символов.
	# в качестве параметра может быть переменная :name => k
	
	Если передаются переменные и хэш, то хеш всегда ставится в конец 
	списка передаваемых параметров.
	
	
METHOD .merge

	# смотри её в файле: app19.rb
	def show_book book
		# выводит на экран записную книгу
		puts '='*12
		book.keys.each do |key|
			age = book[key]
			puts "Name: #{key}, age: #{age}"
		end
		puts '='*12
	end
	
	book1 = { 'Mike' => 45, 'Gus' => 36, 'Linda' => 48}
	show_book book1
	
	book2 = { 'Walt' => 50, 'Jessie' => 25 }
	show_book book2
	
	для того, чтобы объединить два ХЭША используется метод .merge
	book3 = book1.merge book2
	
	или наоборот, что то же самое:
	book3 = book2.merge book1
	
	После объединения появился НОВЫЙ ХЭШ, 
	исходные хэши остались без изменения, но
	если написать: 
	book1.merge! book2 		# book2 добавится к book1
	
	book2.merge! book1 		# book1 добавится к book2
	
ПЕРЕНАПРАВЛЕНИЕ ВЫВОДА в файл     (в тетрадь)
	
	ruby app1.rb > file.txt		# переписать файл
	ruby app1.rb >> file.txt	# дописать в файл
	
	Никто не спросит разрешения для перезаписи файла. 
	Нужно быть очень внимательным с этими операциями.
	
	Перенаправить файл можно и в file.html
	ruby app1.rb > file.html
	
	
HTML - формат					(в тетрадь)

	<body>			- указывает на начало html кода
	... (html-код)
	</body>			- указывает на конец html кода
		
	<br/>  			- переводит на новую строку.
	
	<b> ... </b>  	- bold (жирный)
	
	<i> ... </i>	- зона курсив 
	
	heading - заголовки в текстах:
	
	<h1> ... </h1> - самый КРУПНЫЙ шрифт заголовка
	<h2> ... </h2>
	<h3> ... </h3>
	<h4> ... </h4>
	<h5> ... </h5> - самый мелкий шрифт заголовка
	
	/
	
			
End of Lesson_13
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_14

ООП - Объектно ориентированной программирование.

	КЛАСС - это чертёж какой-то детали 
		  - это шаблон или pattern
	
	ОБЪЕКТ - это как раз эта деталь 
		   - экземпляр класса - 'class instance'
		   - детаей можно сделать сколько угодно, а чертёж ОДИН 

СОЗДАНИЕ КЛАССА

	class Animal		# Создаём шаблон (Класс)
		def run
			@name  = 'Dog'
			puts 'Уже бегу ...'
		end
		...
	end

	aa = Animal.new 	# Создаём новый объект - животное aa
	aa.run

	x = Animal.new		# Другое животное x
	x.run
	
	Переменная @name (см. выше) - будет доступна во всём классе, т.к. она глобальная 
	(со знаком @), но Если переменная будет без этого знака, то она будет доступна 
	только внутри своего метода. 
	
	В другом методе переменная с таким же именем будет совсем другим объектом, т.е. 
	это разные переменные.
	
	Открой программу "Записная книжка" из файлв app20 - book.rb
					
# НАЧАЛО ПРОГРАММЫ                          (в тетрадь)
# coding: utf-8
#
def me_line
	puts "="*30				# Линия из 30 знаков '='
end
	
class Book

    def initialize              	# При создании элемента класса Book ...
        @hh = Hash.new                  # создаётся хеш @hh
        @last_person = String.new       # создаётся строковая переменная
    end
    
    def add_person opt     			# Добавление элемента в хеш и запоминание персоны
        @last_person = opt[:name]
        @hh[opt[:name]] = opt[:age] 
    end

    def show_all                        # Вывод на экран содержимое хеша
        me_line
        @hh.each do |nam, vol|
            puts "|| Name: #{nam}     Age: #{vol}  ||"
        end    
        me_line
    end
    
    def hash                        # Метод возвращает хеш из объекта
        @hh
    end
    
    def last_person             	# Метод возвращает имя последней персоны
        @last_person
    end
    
end

book1 = Book.new
    
book1.add_person :name => 'Dimon', :age => 28 # Передаём в параметр opt
book1.add_person :name => 'Roman', :age => 32
book1.add_person :name => 'Sasha', :age => 47

book1.show_all

puts book1.hash 		# обратится к хэшу можно через отдельный метод
						# в нашем случае это метод hash (см.выше)

me_line
puts "Last person: #{book1.last_person}"
# КОНЕЦ ПРОГРАММЫ

	Здесь:
	метод initialize - не вызывается. Он исполняется когда создаётся 
	новый объект (экземпляр класса).
	
	Приимущества использования КЛАССОВ:
	- доступ к хэшу имеют только методы, описанные в данном классе
		(иначе доступ к хэшу имеет любой метод в программе)
		
	- приимущество "масштабирования": если нам захочется создать ещё одну записную 
		книгу, то это делается одной командой. 
		(иначе нам придётся создавать новый хэш с новым именем, добавлять процедуры 
		для обраблотки нового хэша, или изменить их.)
		
		Так очень легко запутаться и внести изменения не в ту книгу, т.к. будет 
		не понятно, какой метод для с какой глобальной переменной работает.
	
	Имя переменной и имя метода могут совпадать. Они не мешаю друг другу
	
	
АТРИБУТЫ КЛАССА 

	Писать методы для каждой перенной класса очень неудобная вещь, и разработчики Ruby
	придумали как это облегчить. Были введены атрибуты класса:
	
	class Book
	
		attr_reader :last_person 	# разрешено только читать извне
		attr_writer :secret_code	# разрешено только писать извне
		attr_accessor :name_book	# можно и читать, и писать извне
		
		def ...
		...
		end
		
		...
	end	

	при записи внутри класса attr_reader :last_person создаётся дополнительный метод,
	ползволяющий извне прочитать значение last_person
	
	при записи attr_accessor :name_book создаётся два дополнительных метода, 
	позволяющие и прочитать значение name_book, так и изменить его значение. 
	accessor = reader + writer
	
	Для каждого экземпляра класса (каждого объекта) эти атрибуты свои и будут иметь 
	свои значения. Но в каждом объекте они точно будут.
	
	
Открой программу "Самолёты" из файлв app21 - Airplane.rb	
	
	Там больше кода с классами, и они завязаны друг за друга: 
	экземпляры класса САМОЛЁТ принадлежат к экхемпляру класса АЭРОПОРТ
		
	
End of Lesson_14
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_15

КЛАСС - в общем случае выглядит так:    (в тетрадь)
	
	class Airplane
	
		attr_reader :a		# R    - читать
		attr_writer :b		#  W   - писать
		attr_accessor :c	# RW   - читать и писать
		
		def initialize par1, par2, ...
			@a = par1
			@b = par2
			...
		end
		
		def fly
		...
		end
			
	end
	
	plane.a = 1 	# W записываем в переменную класса a значение 1
	puts plane.a 	# R считываем из переменной класса её значение
	# в случае attr_accessor - можно выполнить и запись (W) и чтение (R)
	Это всё уровни доступа к отдельным свойствам объекта.

	Местоположение attr_... в классе - произвольное.
	
	def initialize  # - это конструктор объекта
	end

	переменные, доступные внутри класса - называются свойствами объекта
	
	class Song
		attr_accessor :name, :duration
		def initialize nme, duration
			@name = name
			@duration = duratiun
		end
	end
	song1 = Song.new 'The show must go on', 6
	puts song1.name
	puts song1.duration
	
	Свойства объекта можно перечислить через запятую, но это не так наглядно, 
	как запись в столбик.
	
	Глобальные переменные класса желательно определить в конструкторе т.е. когда мы 
	пишем .new Это позволяет исключить ошибки когда мы обращаемся к массиву через 
	метод-2, а этот массив инициируется в методе-1 вместо initialize а метод-1 мы ещё
	не вызвали.
	
	Смотри программу app22 - '(class-class-class)_.rb'
	
	Здесь три класса Самолёт-Аэропорт-Страна и несколько методов, позволяющих 
	добавлять самолёты на аэродромы и прикреплять аэродромы к стране


НАСЛЕДОВАНИЕ В КЛАССАХ  (в тетрадь)

	Смотри программу в файле: app23 - (Animal-Dog-Cat)_.rb
	# -------------------------------------------------------------------------------
	class Animal
	
	  def initialize name
	    @name = name
	  end	
	  
	  def run
        puts "#{@name} is runing ..."
	  end
	  
	  def jump
	    puts "#{@name} is jumping ..."
	  end
	
	end
	# -------------------------------------------------------------------------------
	class Dog < Animal
	  def initialize
	    super 'dog'
	  end  
	  def say
	    puts 'dog say: Woof-woof!'
	  end
	end	
	# -------------------------------------------------------------------------------
	class Cat < Animal
	  def initialize
	    super 'cat'
	  end
	  def say
	    puts 'cat say: Meeeoooow!'
	  end 
	end
	# =============================================================== B E G I N =====
	cat = Cat.new
	cat.jump
	cat.run
	cat.say
				puts
	dog = Dog.new
	dog.jump
	dog.run
	dog.say
	# =================================================================== E N D =====
	
	Jumping ...
	Running ....
	Meeeoooow!
	
	Jumping ...
	Running ....
	Woof-woof!
	
	Здесь класс Dog и класс Cat наследуют все свойства и методы из класса Animal 
	В то же время они имеют собственные методы .say у каждого свой метод, хотя имена 
	у них одинаковые.
	
	При инициализации объекта cat параметр 'cat' по слову super передаётся в 
	супер-класс т.е. в класс Animal (в его initialize)
	
	http://phrogz.net/programmingruby/tut_classes.html

	
End of Lesson_15
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_16

КОНСТРУКТОР в КЛАССЕ - в общем случае выглядит так:    (в тетрадь)
	
	# -------------------------------------------------------------------------------
	class Animal
		def initialize par1, par2
			@a = par1
			@b = par2
			@arr = [ ... ]
			@hh = { ... }
		end		
	end	
	# =============================================================== B E G I N =====
	animal = Animal.new 5, 'abc'
	# =================================================================== E N D =====

НАСЛЕДОВАНИЕ свойств КЛАССОВ                          (в тетрадь)    

	# -------------------------------------------------------------------------------
	class Animal	# Класс "родитель" - super класс
		.... 		# и все его свойства будут ... 
	end
	# -------------------------------------------------------------------------------
	class Dog < Animal	# ... будут переданы классу Dog (классу "наследнику")
		....
	end
	# -------------------------------------------------------------------------------

!!! Naming conventions - (соглашение об именах)
	JessiePinkman
	Jessie_Pinkman
	
	В разных командах приняты разные соглашения об именах.
	
УКАЗАНИЕ ПАРАМЕТРОВ ДОСТУПА к определённым МЕТОДАМ

	Это фишка ООП: 
					public		- открытый, доступный
					protected	- ???
					private		- скрытый (приватный) часный
	# -------------------------------------------------------------------------------
	class Animal
		def initialize name
			@name = name
		end
		# _____ по-умолчанию доступен открытый (public) блок с методами
		ger run
			puts "#{@nme} is runing..."
		end
		def jump
			eat								# -здесь вызываем из privet
			puts "#{@nme} is jumping..."	
			sleep							# - и ещё здесь
		end
		private	# ___________ начало частного (private) блока с методами
		def eat
			puts "I am eating..."
		end
		def sleep
			puts "I am sleeping..."
		end
		public # ____________ начало ещё одного открытого (public) блока
		def hi
			puts '............Ooops!'
		end
	end
	# -------------------------------------------------------------------------------
	class Dog < Animal
		def initialize
			super 'dog'
		end
		def bark
			puts 'Wouf-wouf!'
			sleep
		end
	end		
	# =============================================================== B E G I N =====
	animal = Animal.new 'cat'
	animal.jump
	# animal.sleep		# -	работать не будут т.к. они в блоке privat 
	# animal.eat		# .. т.е. могут работать только при вызове их
						# .. из любого метода своего класса.
	animal.hi
	
	dog = Dog.new		# !!! Имя здесь не указываем, т.к. оно уже ука-
						# зано в initialize и передаётся в super класс
	dog.jump	# для этого, нового объекта будет работать функционал
				# от кошки. Мало того, все унаследованные в том числе
	dog.bark	# private методы могут быть исполльзованы в Dog классе	
	# =================================================================== E N D =====	
	Вывод программы:
						I am eating...
						cat is jumping...
						I am sleeping...
						............Ooops!
						I am eating...
						dog is jumping...
						I am sleeping...
						Wouf-wouf!
						I am sleeping...
	
	Методы, описанные в private блоке не могут быть вызваны извне.
	Их можно вызвать только через другие методы этого класса. 

(!)	private - ограничивает доступ к методам только непосредственно из этого класса. 
			  
	Как это применяется: Например программист пишет метод приготовления
	яичницы. Метод "Делать_яичницу" - делится на более мелкие методы:
		Поставить сковороду на плиту - 
		Включить плиту - 
		Разбить яйцо -
		Посолить - 
		Убавить огонь - 
		Ждать 5 минут - 
		Выключить плиту - 
		Переложить в тарелку ...
	Все эти методы будут private т.к. они по отдельности не должны вызываться, 
	их вызывает наш главный public метод "Делать_яичницу".
	 
	Если этого не сделать, то объект будет способен на безумие, 
			например - Разбить яйцо (без сковороды).
			Это есть - нарушение поведения класса (!!!) 
	
	А так, каждая операция в процедуре "Делать_яичницу" имеет свой блок кода, 
	отделённый от соседних операций. Это удобно.
	В том числе при поиске ошибки - "если яичница подгорела". 
	
	Вторым неоспоримым удобством является возможность использовать эти элементарные 
	операции в создании других методов, напрмер: 
											  "Приготовить_борщ" или "Сварить_яйцо".
	
	Совокупность открытых методов для класса часто называют:
	API - Application Program Interface.
	
	
СТАТИЧЕСКИЕ МЕТОДЫ								(в тетрадь)

	# -------------------------------------------------------------------------------
	class Man
		def self.say_hi		# staric - статический метод
			puts 'Hi!'
		end
		def self.say_bye	# staric - статический метод
			puts 'Bye!'
		end
	end
	# =============================================================== B E G I N =====
	Man.say_hi 
	Man.say_bye 
	# =================================================================== E N D =====
	
	важное слово здесь: self
	
	Другой пример программы:
	# -------------------------------------------------------------------------------
	class RandomEngine															# Машина случайных чисел
		def self.get_random_value
			rand(100..999)
		end
	end
	# -------------------------------------------------------------------------------
	class GameEngine
		def self.play
			a = RandomEngine.get_random-value       
		end	
	end
	# =============================================================== B E G I N =====
	GameEngine.play
	# =================================================================== E N D =====
	
	Здесь программа разделилась на два блока: 
				- отвечает зп получение случайного числа
				- отвечает за саму игру
	Каждому программисту можно поручить отдельный класс. И в случае если с программой
	работают несколько программистов, то разделение на классы позволяет ограничить 
	влияние друг на друга.
	
	
yield - КЛЮЧЕВОЕ СЛОВО

	# -------------------------------------------------------------------------------
	class run_5_times
		5.times do
			yield
		end		
	end
	# =============================================================== B E G I N =====
	run_5_times { puts 'Something' }
	# =================================================================== E N D =====				

	Ключевое слово yield возвращает выполнение в блок { ... } вызывающего 
	метода run_5_times
	
	При вызове не передаётся никакого параметра, 

	# -------------------------------------------------------------------------------
	class run_5_times 		# это аналог 5.times
		x = 0
		while x < 5
			yield xб 55	 	# возвращает x в блок вызвавшей процедуры { |i, v| ... }
			x += 1			# здесь это x = x + 1
		end		
	end
	# =============================================================== B E G I N =====
	run_5_times { |i, v| puts "Something, index: #{i}, Val = #{v}" }
	# =================================================================== E N D =====


Lambda - указатель на функцию

	# -------------------------------------------------------------------------------
	x = lambda { |a| ... }
	# -------------------------------------------------------------------------------
	y = lambda do |a|
		...
	end	
	# =============================================================== B E G I N =====
	x.call 55					# вызов с параметром
	# =================================================================== E N D =====
		
	Иногда очень удобно переменным присваивать указатели на функций.
	Например удобно иметь массив указателей на функции.
	
  1.Пример программы с использованием массива:
	# -------------------------------------------------------------------------------
	say_hi = lambda {puts 'Hi'}
	say_bye = lambda {puts 'Bye'}
	# =============================================================== B E G I N =====
	week = [ say_hi, say_hi, say_hi, say_hi, say_hi, say_bye, say_bye ]
	week.each do |day|
		day.call
	end
	# =================================================================== E N D =====
	Вывод на дисплей:
						Hi
						Hi
						Hi
						Hi
						Hi
						Bye
						Bye
	

  2.Ещё пример использования:
	# -------------------------------------------------------------------------------
	sub_10 = lambda do |x|
		return x - 10
	end
	# -------------------------------------------------------------------------------
	sub_20 = lambda { |x| return x - 20 }
	# -------------------------------------------------------------------------------
	add_40 = lambda { |x| x + 40 }
	# =============================================================== B E G I N =====
	a = 1000
	a = sub_10.call a
	puts a
	a = sub_20.call a
	puts a
	a = add_40.call a
	puts a
	# =================================================================== E N D =====
	Вывод на дисплей: 
						990
						970
						1010
	
  3.Третий пример использования lambda с хэшем.
	Надо:
	    до 300 - плюс 10
	    до 600 - плюс 20
	больше 600 - минус 5
	# -------------------------------------------------------------------------------
	add_10 = lambda { |x| x + 10 }
	# -------------------------------------------------------------------------------
	add_20 = lambda { |x| x + 20 }
	# -------------------------------------------------------------------------------
	sub_5 = lambda { |x| x - 40 }
	# =============================================================== B E G I N =====
	balance = 1000
	hh = {  111 => add_10, 222 => add_10, 333 => add_20, 
			444 => add_20, 555 => add_20, 666 => sub_5, 
			777 => sub_5,  888 => sub_5,  999 => sub_5 }
	loop do
		x = rand(100..999)
		puts "Combination: #{x}"
		if hh[x]
			f = hh[x]
			balance = f.call balance
			puts 'Lambda called'
		esle
			balance = sub_5 balance
		end
		puts "Balance: #{balance}"
		puts 'Press Enter to continue ...'
		gets
	end
	# =================================================================== E N D =====
	
	
МОДУЛИ - Module - NameSpace (Пространство имён) 	
	
	http://www/tutorialspoint.com/ruby/ruby_modules.html
	Позволяют сделать множественное наследование.
	
	Mixin - перемешивать
	
	Модуль содержит несколько классов,
			Класс содержит несколько методов.
			
	Модули и Классы - это абстракция, которая должна облегчать жизнь программиста.		
	
	# -------------------------------------------------------------------------------
	module A
		def a1
		end
		def a2
		end
	end
	# -------------------------------------------------------------------------------
	module B
		def b1
		end
		def b2
		end
	end	
	# -------------------------------------------------------------------------------
	class Sample
	include A
	include B
		def s1
		end
	end
	# =============================================================== B E G I N =====
	samp = Sample.new
	samp.a1
	samp.a2
	samp.b1
	samp.b2
	samps1
	# =================================================================== E N D =====	
	
	
	Пример модулей:
	# -------------------------------------------------------------------------------
	module Numans
		class Manager
			Puts 'Hi'
		end
		class Hipster
			puts 'Hiiii, yo!'
		end
		class Jessie_Pinkman
			puts 'Hi, Bitch!'
		end
	end
	# -------------------------------------------------------------------------------
	module Animals 
		class Dog
		end
		class Cat
		end
	end
	# =============================================================== B E G I N =====
	hipdter = Humans::Hipster.new
	hipster.say_hi
	dog = Animals::Dog.new
	# =================================================================== E N D =====
	
	
ПОДКЛЮЧЕНИЕ другого ФАЙЛА

	require './file1.rb'
	
	require - (требовать)
	
	./ - озгачает текущую директорию
	Обычно требует полный путь, но можно и так. (Зависит от ОС).

	Пример с подключением другого файла:
	# ----------------------------------------------------- файл app24-1.rb ---------
	require './app24-2.rb'
	BB.say_hi

	# ----------------------------------------------------- файл app24-2.rb ---------	
	module BB
		def self.say_hi
			puts 'hi'
		end
	end
	# -------------------------------------------------------------------------------
	     Запускаем: ruby app24-1.rb
	Выводит: hi из файла app24-2.rb

	Здесь не используется класс, просто есть модуль BB который содержит один 
	СТАТИЧЕСКИЙ метод. (self - перед методом)
	
	Если сделать классы, то можно будет не использовать статические методы, а 
	обращатся через объекты этого класса.
	
	Разбиение на файлы удобно тем, что каждый программист работает над отдельным 
	файлом и они друг другу не мешают. Каждый пишет свой модуль, это очень удобно.


ТИПЫ ПЕРЕМЕННЫХ

	1. Глобальная переменная. Доступна в любом месте программы
		$global_var = "I'm global and live everywhere"
	
	2. Локальная переменная. Доступна только в том блоке где определена
		lacal_var = 'I only live in code blocks'
	
	3. Переменная экземляра. Доступна внутри этого экземпляра
		@instance_var = 'There is one of me per class instance'
	
	4. Переменная классаю Доступна всем экземплярам этого класса
		@@class_var = 'There is one of me per class'

	5. Константа. Не может быть изменена
		CONSTANT = 'I NEVER CHANGE! AARRRGGGGHHHH!!!!'
	
	
	Описание переменных и их места в программе
	# -------------------------------------------------------------------------------
	class App
		CONSTANT = 'I NEVER CHANGE! AARRRGGGGHHHH!!!!'
		@@class_var = 'There is one of me per class'

		def print_variables
			@instance_var = 'There is one of me per class instance'
			lacal_var = 'I only live in code blocks'
			
			puts $global_var
			puts CONSTANT
			puts @@class_var
			puts @instance_var
			puts local_var
		end
	end
	# =============================================================== B E G I N =====
	$global_var = "I'm global and live everywhere"
	App.new.print_variables
	# =================================================================== E N D =====
	
	Книга скачать: "Roman's Kindle for PC - The Rapid Rubyist"
	
	Пример использования переменной класса
	# -------------------------------------------------------------------------------
	class Song
		@@times = 0
		def play
			@@times += 1
		end
		def total_times
			@@times
		end
	end
	# =============================================================== B E G I N =====
	song_1 = Song.new
	song_2 = Song.new
	song_3 = Song.new
	
	song_1.play
	song_2.play
	
	puts song_3.total_times
	# =================================================================== E N D =====
 	Выводит: 2
 	
 	Здесь мы дважды обратились в play методу, 
 	а прочитали переменгнцю класса через третий объект, через который play не 
 	вызывалась.
 	
 	Эта переменная доступна всем экземплярам данного класса. Она общая для них всех.
 	
 	
End of Lesson_16
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_17

МЕТАПРОГРАММИРОВАНИЕ 

METHOD send 

  1.Вызов функции с помощью символа
	# -------------------------------------------------------------------------------
	def mm
		puts 'Hi'
	end
	# =============================================================== B E G I N =====
	send :mm
	# =================================================================== E N D =====
	Выводит: Hi
	
	
  2.Вызов функции с помощью символа и передачей параметра
	# -------------------------------------------------------------------------------
	def mm args
		puts args
	end
	# =============================================================== B E G I N =====
	send :mm, 555 					# - meta-programming
	# =================================================================== E N D =====
	Выводит: 555
	
  3.Вызов функции с помощью символа и передачей параметра в виде ХЭША
	# -------------------------------------------------------------------------------
	def mm hach
		puts hash.inspect
	end
	# =============================================================== B E G I N =====
	send :mm, :x => 1, :y => 2  
	send "mm", :x => 1, :y => 2 
	# =================================================================== E N D =====
	Выводит: 555
	
	
  4.Создание объекта - (использование функции send() )
	# -------------------------------------------------------------------------------
	class Something
		attr_accessor :name			# Без accessor присвоение ниже работать не будет
		def initialize
			# @name = "aaa"			# Это же действие делает следующая строка
			send("name=", "Mike")	# .. это присвоение
		end
	end	
	# =============================================================== B E G I N =====
	s = Something.new
	puts s.inspect
	
	#puts s.name
	# =================================================================== E N D =====
	Выводит все параметры объекта s
	
	
  5.Создание объекта - (использование ХЭШ с функцией send)
	# -------------------------------------------------------------------------------
	class Something
		attr_accessor :x, :y, :z		# перечислим все переменные экземпляра
		def initialize hash				# при создании сюда передаётся Хэш параметров 
			hash.each do |key, value|	# перебираем все пары хеша и 
				send "#{key}=", value	# создаём поочереди переменные экземпляра
			end
		end
		# Это эквивалентно следующему коду:
		# def initialize x, y, x
		# 	@x = x
		# 	@y = y
		#	@z = z
		# end
		# Чем больше будет параметров, тем больше станет программа (длиннее код)
		# В предыдущем варианте длина кода не зависит от количества параметров (!)
	end	
	# =============================================================== B E G I N =====
	s = Something.new :x => 1, :y => 2
	puts s.x
	# =================================================================== E N D =====
	Выводит.


METHOD method_missing	
	
  1.Использование метода "method_missing" для отсутствующих методов класса
	# -------------------------------------------------------------------------------
	class Something
		...
		def method_missing name
			puts "Calling unknown method #{name}"
			...
		end
		...
	end	
	# =============================================================== B E G I N =====
	s = Something.new 
	s.asdblabla1234				# такого метода нет
	# =================================================================== E N D =====
	# Здесь при вызове метода, которого нет в данном классе - будет вызван метод
	# method_missing - как "заглушка" от ошибки вызова отсутствующего метода	
	 
	method_missing - (отсутствие метода)
	Это специальное зарезервированное слово, как initialize
	
	
  2.Использование метода "method_missing" для обработки других методов (через Хэш)
	# -------------------------------------------------------------------------------
	class Albuquerque
		def initialize actions
			@actions = actions
		end 
		...
		def method_missing name
			value = @actions[name]
			value = 'no number' if value = ''
			puts "If you want to #{name}, you must be call #{value}"
		end
	end	
	# =============================================================== B E G I N =====
	a = Albuquerque.new :cook => "Walt", :take_a_ride => "Jessie", :die => "Gus"
	a.cook
	a.take_a_ride
	a.die 
	a.bala-bla-bla
	# =================================================================== E N D =====
	# Здесь при вызове метода, которого нет в данном классе - будет напечатано
	# значение из хэша, соответствующее этому ключу, а если такого ключа нет, то 
	# фраза-заглушка "no number"	
	Выводит:
	If you want to cook, you must be call Walt
	If you want to take_a_ride, you must be call Jessie
	If you want to die, you must be call Gus
	If you want to bla-bla-bla, you must be call no number
	
	Приимущество в том, что Нам не нужно определять кучу разных методов 

	3.Использование метода "method_missing" без создания класса
	# =============================================================== B E G I N =====
	def method_missing name
			puts "Calling unknown method #{name}"
	end
	
	asdrfrhguru
	# =================================================================== E N D =====
	
	
METHOD define_method
	
	1.Использование метода "define_method" для определения методов
	# -------------------------------------------------------------------------------
	send :define_method, "aaa" do
		puts "Hello, I'm new method"
	end
	# это эквивалентно следующей записи:
	def aaa 
		puts "Hello, I'm new method"
	end
	# =============================================================== B E G I N =====
	aaa
	# =================================================================== E N D =====
	# Эта запись определяет метод. Аналогично обычной записи. 

	# During runtime (Во время выполнения программы) имеется возможность определить
	# свой метод с именем, заданныв переменной (вместо "aaa") и использовать его
	# для последующих операций
	# send :define_method, "aaa" - Это определение метода по имени. 
	
	
	2.Использование метода "define_method" для определения метода через консоль
	# =============================================================== B E G I N =====
	print "Name of method to define: "
	method_name = gets.strip
	
	send :define_method, mathod_name do
		puts "Hello, I'm new method"
	end
	
	send mathod_name
	# =================================================================== E N D =====
	# Здесь название метода задаёт пользователь и программа хнаеит его в переменной 
	# method_name 
	# Вызов этого метода происходит через send
	
	В метапрограммировании есть много особенностей и возможностей.
	Подробности нужно смотреть в документации ...
		
	
	3.Использование метода "define_method" в простейше варианте (есть два метода)
	# -------------------------------------------------------------------------------
	def left
		puts "Robot goes left" 		# Превый метод
	end
	# -------------------------------------------------------------------------------
	def rigth
		puts "Robot goes right"		# Второй метод
	end
	# =============================================================== B E G I N =====
	print "Where to go (left/right): "
	a = gets.strip
	
	send a 
	# =================================================================== E N D =====
	# Здесь пользователь сам вводит имя нужного метода для выполнения
	# например в играх, где вводятся команды: lefr, right

ЗАКОНЧИЛИ МЕТАПРОГРАММИРОВАНИЕ
	
	
(!)	При передачи параметров сначала пишут переменные, а в конце хэш
		ХЭШ всегда на последнем месте:
		
		a.rows "something", :x => 1, :y => 2, :z => '34'
		

METHOD .split

	Разделить (расщепить). Есть сепаратор
	s = 'January, 10, 55, 81'
	arr = s.split
	

ПОИСК ИНФОРМАЦИИ НА САЙТЕ stackoverflow.com

	Пишем в посковике на английском:
	
	google: ruby read file site:stackoverflow.com
	руби читать файл сайт: токой-то
	
	google: ruby write to docx site:stackoverflow.com
	
	Так легко найти ответы на многие вопрос и не толко по руби.

	
РАБОТА С ФАЙЛАМИ					

METHOD .open
METHOD .close

	input = File.open("test.txt", "r") 
	output = File.open("output.txt", "w")
	# Здесь скобки можно не писать
	Если не указан полный путь, то файл читается (или пишется) в текущей директории.
	
	"r" - режим чтения (read)
	"w" - режим записи (write)
	
	"r+" - read + Write
	"w+" - write + read
	Последние два - аналогичные за исключением различных блокировок.
	
	"a" - append (добавить) - открыть файл с "w" и передвинуть курсор в конец файла.
				типа - дописать.
	# -------------------------------------------------------------------------------
	# =============================================================== B E G I N =====
	# =================================================================== E N D =====
	
	# Файл для записи
	# =============================================================== B E G I N =====
	output = File.open "test.txt", "w"
	output.write "Something \n"
	output.close
	# =================================================================== E N D =====

	# Файл для чтения
	# =============================================================== B E G I N =====
	input = File.open "test.txt", "r"
	while (line = input.gets)
		puts line
	end
	input.close
	# =================================================================== E N D ===== 

	Пример использования.
	# -------------------------------------------------------------------------------
	# file: "app25 - test.txt"
					Январь, 100, 6
					Февраль, 30, 7
					Март, 60, 0
					Апрель, 90, 3
					Май, 110, 6
					Июнь, 80, 3
					Июль, 30, 6 
					Август, 70, 8
					Сентябрь, 50, 2
					Октябрь,110, 5
					Ноябрь, 75, 3
					Декабрь, 95, 2
	# =============================================================== B E G I N =====
	input = File.open "app25 - test.txt", "r"
	total_summ_1 = 0
	total_summ_2 = 0
	while (line = input.gets)
		arr = line.split(',')
		item_1 = arr[1].strip.to_i
		item_2 = arr[2].strip.to_r
		total_summ_1 += item_1
		total_summ_2 += item_2
	end
	puts "Total_summ = #{total_summ_1}"
	puts "Small_summ = #{total_summ_2}"
	input.close
	# =================================================================== E N D =====
	
METHOD .rename

	File.rename file_name_1, fole_name_2
	# здесь всё просто


АТРИБУТЫ ДОСТУПА К ФАЙЛАМ

METHOD .chmod

	In Linux 
	
	chmod 777 file1.rb
	
	r - Read
	w - Write
	x - eXecute	
	
	r  w  x  |  8
	---------+-----
	0  0  0  |  0
	0  0  1  |  1
	0  1  0  |  2
	0  1  1  |  3
	1  0  0  |  4
	1  0  1  |  5
	1  1  0  |  6
	1  1  1  |  7
	
	 
	7 7 7 
	| | + - все остальные (other)
	| + - - для группы  (group)
	+ ----- для хозяина (owner)

	Наиболее часто применяемые комбинации:
	      own  grou oter
	755 = rwx  r-x  r-x
	666 = rw-  rw-  rw-
	644 = rw-  r--  r--
	
	Изменить права можно с помощью команды File.chmod 
	
	
METHOD .pwd

	> puts Dir.pwd   # выводит рабочую директорию (print working directory)	
	
	> Dir.chdir	'..' # сменить рабочую директорию
	
	> Dir.entries "C:/projects"
	=> [".", "..", "bak", "Lesson13", "Lessom14", "Lesson15", "Lesson16", "Lesson17"] 	
	# возвращает массив всех элементов в указаной директории
	
	stop
		
End of Lesson_17
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_18

	http://rubyschool.us/files/Lesson18/password.txt
	Файл с паролями.
	
	# =============================================================== B E G I N =====
					input = File.open "password.txt", "r"
					while (line = input.gets)
						puts line if line.strip.size == 6
					end
	# =================================================================== E N D =====	
	# Открываем файл и читаем построчно в переменную line
	# Для вывода результата в файл пишем > ruby app26.rd > password-6.txt
	
	
	Ещё программа которая анализирует введённый пароль.
	# =============================================================== B E G I N =====
					input = File.open "password.txt", "r"
					print "Enter your password: "
					your_pass = gets.strip

					i = 0
					while (line = input.gets)
						line.strip!
						i += 1
						if your_pass == line
							puts
							puts "Your password #{your_pass} is weak!"
							exit
						end
						print ". #{i} - Working: #{line} "+" "*15+"\r"
						sleep 0.005                
					end
					puts
					puts "Your password #{your_pass} is NOT weak!"
	# =================================================================== E N D =====
	
	
	# app26-2.rb
	# -------------------------------------------------------------------------------
					def is_your_password_weak? pass
						input = File.open "password.txt", "r"
						while (line = input.gets)
							line.strip!
							if pass == line
								return true
							end
						end
						return false
					end
	# =============================================================== B E G I N =====
					print "Enter your password: "
					your_pass = gets.strip

					if is_your_password_weak? your_pass
						puts "Your password #{your_pass} is weak!"
					else
						puts "Your password #{your_pass} is NOT weak!"
					end
  # =================================================================== E N D =====
	Если мы пишем функцию, которая возвращает true или false то нужно писать знак ?
	

WEB ТЕХНОЛОГИИ 

	На собеседовании часто спрашиваю: 
	"Знаете ли Вы что происходт когда пользователь вводит адрес в строку браузера"?
	
	Или ещё: "Что такое GET и POST запросы, в чём разница"?
	
	Когда пользоваптель вводит что-то в адресную строку Браузер отправляе GET-запрос.
	GET - переводится как "ПОЛУЧИТЬ" т.е. браузер хочет получить что-то.
	
	POST - переводится "ОТПРАВИТЬ" какие либо параметры (и получить ответ сервера).
	
	Когда мы вводм Login и Password браузер сразу не отправляет эти данные на сервер.
	Он отправит эти данные когда мы нажмём специальную кнопку, например "Send".
	Внутри запроса видно, что используется POST-запрос и после всей служебной информации
	идёт специальная запись: login=admin&password=123456
	
	И на GET-запрос, и на POST-запрос сервер отправляет определённую страничку с сайта
	Эта страничка - последовательность символов и кодов, из которых браузер формирует
	отображение сайта в свойм окне.
		С этой текстовой информацией мы можем поработать. Можем её проанализировать. 
	
	Server - serv - (обслуживать)  Сервер сам ничего не отправляет.
	
	Есть удобная (бесплатная) программа для Windows:
	FIDLER - программа (прокси-сервер) который показывает все запросы и их параметры
			ROW - (сырой) сырой пакет - видно, что браузер отправляет на сервер.
			Там много различных данных к каждому запросу.
			Программа "вклинивается" между программой (браузером) и сетью интернет и пере-
			хватывает все запросы, пропуская их через себя. Это позволяет увидеть какие
			запросы куда направлены, какие ответы получены, что они содержат.
			Кроме браузеров в Fidler видны запросы всех прогдамм на компьютере.
			
	Думаю должна быть такая программа и для Linux. Для Mac - точно есть, но платная.
			
	Если посмотреть исходный код страницы входа на наш РОУТЕР, то можно увидеть там
	участок кода с тегами: 
	...
	<input ... name=login, ... />
	...
	<input ... name=password, ... />
	... 
	это и есть имена наших данных, который будет обрабатывать сервер.
	А вот их значения беруться браузерером из поля, в которое Вы его вводили. 
	Так формируется POST-запрос		
	
	Сервер говорит "Ок" или "Не Ок". Вариантов ответов сервера множество.
	
	См. документацию по rfc http (набрать в google). Там есть коды "удач" и " неудач". 
	https://www.opennet.ru/docs/RUS/http11/ - по русски.
	
	Std-lib - (стандартная библиотека) это то, что входит в сам Ruby.
						библиотека, имеет большой набор функций. См. документацию.
	
	Gems - это то, что пишут разработчики.
				 информация по конкретному gem нужно смотреть в документации к этому gem. 	
	
	Net::HTTP - это из Std-lib.
	
	И так,
	Используем прямое указание для метода get (GET-запрос)
	# =============================================================== B E G I N =====
			require 'net/http'    # Требовать класс http из модуля (пространства имён) net
			response = Net::HTTP.get 'rubyschool.us', '/router'
																# .get использует два параметра: домен и путь 
																# здесь написано для: http://rubyschool.us/router
			puts response           	# вывести текстовы код страницы в терминал
	# =================================================================== E N D =====
	Если запускать файл с дополнительной командой | grep div то вместо большого
	текста на экран будет выведены только те строки, в которых есть этот текст div
	> ruby app.rb | grep dev
	
	
	Не всегда удобно явно прописывать в две переменные адреса страницы сайта
	Чаще и удобнее использовать ссылку целиком.
	Это будет выглядеть так:
	# =============================================================== B E G I N =====
				require 'net/http'        # Требовать класс http из модуля net
				require 'uri'
				
				uri_var = URI.parse 'http://rubyschool.us/router' # Создаётся новый объект
				response = Net::HTTP.get uri_var									# Отправляем GET-запрос 
				puts response    # вывести (ответ сервера) текстовы код страницы в терминал
	# =================================================================== E N D =====
	URI — унифицированный идентификатор ресурса.    (Uniform Resource Identifier)
	По-русски иногда говорят [у́ри]. 
	URI — последовательность символов, 
															     идентифицирующая абстрактный или физический ресурс. 
	Ранее назывался Universal Resource Identifier — универсальный идентификатор ресурса.
	
	Результатом выполнения программы выше - будет текстовая информация с сервера.
	
	Если мы хотим подключится к своему роутеру, то нужно отправить POST-запрос с 
	параметрами login=admin&password=123456 Эти данные мы уже разбирали выше 
	см. упоминание тега <input .../>
	
	Для отправки POST-запроса роутеру нам понадобится метод .post_form 
	Этому методу мы передаём uri и хэш с параметрами.
	
	res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
	
	В нашем случае это будут: login=admin&password=123456
	Отправляем POST-запрос с параметрами на адрес в uri
	# =============================================================== B E G I N =====
				require 'net/http'      
				require 'uri'
				
				uri_var = URI.parse 'http://rubyschool.us/router'  # Создаём новый объект
				
				response = Net::HTTP.post_form(uri_var, :login => 'admin', 
																						 :password => '123456')
																										 
				puts response  
	# вывести (ответ сервера на POST) текстовы код страницы в терминал
	# =================================================================== E N D =====
	Ключи в хэше можно писать символами :login или строкой "login" 
	Значения всегда стока "ku-ku" или '234'	
	При правильном запросе нам возвращается объект и выводится id_объекта:
	=> Net::HTTPOK:0x000000305bdf8
	
	response - это объект с кодом страницы сайта
	В дальнейшем можно с ним работать:
		- искать вхождения
		- анализировать содержимое
		- проверять доступность ссылок и т.п.
	
	# Скобки в post_form можно не писать	
			response = Net::HTTP.post_form uri_var, :login => 'admin', :password => '123456' 	 
	
	Давайте проагализируем ответ с сервера.
	В нашем случае (в друго случае может быть подругому) если login или password были
	ошибочными, сервер присылает страницу, в которой есть фраза 'Access deniet'
	"Дотуп запрещён".
	
	Чтобы определить вошли мы или нет, нужно просто выяснить: содержится ли в ответе
	фраза 'Access deniet' или вообще 'denied'
	
			puts response.include? 'denied'
	
	Пишем программу
	# =============================================================== B E G I N =====
			require 'net/http'      
			require 'uri'
			
			def is_it_wrong_password? pass
				uri_ = URI.parse 'http://192.168.0.1/' 
				response = Net::HTTP.post_form(uri_, :login => 'admin', :password => pass).body
				return response.include? 'denied'  
			end	
			puts is_it_wrong_password? '1231213'
	# 
	# =================================================================== E N D =====
	
	
	Программа подбирает пароли к Вашему роутеру, перебирая варианты их файла.
	(У меня тормознул на 2770 - примерно, причина не выяснена)
	# file: app27-router.rb
	# -------------------------------------------------------------------------------
			require 'net/http'      
			require 'uri'
			def is_it_wrong_password? pass
				uri_ = URI.parse 'http://192.168.0.1/' 
				response = Net::HTTP.post_form(uri_, :login => 'admin', :password => pass).body
				return response.include? 'bad_auth'  
			end	
	# =============================================================== B E G I N =====
			input = File.open "password.txt", "r"
			i = 0
			while (line = input.gets)
				line.strip!
				i += 1
				if is_it_wrong_password? line
					puts "I am found! Your password is: #{line}"
					input.close
					exit
				end
				print ". № #{i} - Trying: #{line} "+" "*15+"\r"
			end
			puts "I don't found your password. Sorry..."
			puts "Because your password is very good"
			input.close
	# =================================================================== E N D =====	
	
End of Lesson_18
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_19

УСТАНОВКА RUBY НА WINDOWS.

	http://teamviewer.com
	
	dem install hipchat
	
'http://putshello.wordpress.com/2014/08/03/installing-ruby-for-windiws-the-right-way'
 
	http://rubyinsyaller.org/downloads/
	
	Other Useful Downloads - Другие полезные скачки
	
	Development Kit 

GEM - Sinatra

	gem install sinatra
		
	Браузер использует get чтобы отправить запрос на сервер
		
			#
			require sinatra
			#
			get '/' do
				'Hi'
			end
		
	запускаем в териминале
	>_ riby app1.rb
		
	далее будет выведена специальная информация и программа не будет завершена
	Это запустилась sinatra на нашем компьютере.
		
	Для просмотра нужно в браузере набрать адрес  
	link: localhost:4567			- ССЫЛКА ДЛЯ GEM SINATRA
		
	Это наш первый сайт! :-) 
	                                 Поздравляю!
	                                 
	Здесь мы обратились к серверу, который установлен на нашем компьютере.
	И соевер вывел Hi
		
	view - (вид, представление)
			
	В вакансиях программистов есть разделение (frontend - backend)
	Обычно задачи для программиста или frontend или backend   
	
	frontend - использует view - это отображение в браузере. Обычно это html-страница
						 но часто она записана в особом формате.
						 
	backend - это тот код, который расоположен на сервере и не виден пользователю.
	          обычно это набор контроллеров (отдельных методов) которые обеспечивают
	          обработку приходящих на сервер запросов. И конечно отправляют необходимые
	          данные назад в браузер. 
			
	MVC
	M - Model 			- модель
	V - View 				- представление
	C - Controller 	- контроллер

	# file: app.rb __________________________________________________________________
			system('clear') # Linux
			require 'sinatra'
	# =============================================================== B E G I N =====
			get '/' do
				erb :index	# index - это имя файла с представлением
			end
	# =================================================================== E N D =====
				
	
	# file: view/index.erb __________________________________________________________
			<h1>Hi</h1> 																	
			<-- Это пишу для исправления кривой зелёной расцветки / --> 
			
	erb - это 'template engine' - шаблона движок - Механизм получения html-файла
	
	Все варианты движков шаблона можно посмотреть на github по адресу:
	https://github.com/sinatra/sinatra
	Ищи в содержании раздел: 'Available Temlate Languages'	
		    
	
	Расширим возможности нашего сайта.
	Пусть сайт спрашивает логин и пароль.
	Если логин или пароль введены неправильно, то он выводит эти значения и просит 
	повторить ввод.
	А если логин и пароль (admin secret) то он выводит страничку приветствия welcome
	и напишет слова приветствия.	
	# filename: app.rb ______________________________________________________________
					system('clear') # Linux

					require 'sinatra'

	# =============================================================== B E G I N =====
					get '/' do
						erb :index	# index - это имя файла с представлением
					end

					post '/' do
						@login = params[:aaa]
						@password = params[:bbb]
						
						if @login == 'admin' && @password == 'secret'
							erb :welcome
						else  
							erb :index	# index - это имя файла с представлением
						end  
					end
	# =================================================================== E N D =====
	
	
	# filename: views/index.erb _____________________________________________________
					<h1>Hi</h1>

					<p>You typed: <%= @login %></p>
					<p>Your password: <%= @password %></p>


					<form action="/" method="POST">

						<input type="text" name="aaa" />
						<input type="password" name="bbb" />
						<input type="submit"/>

					</form> 
					
					
	<-- Это пишу для исправления кривой зелёной расцветки / --> 
	# filename: views/welcome.erb ___________________________________________________
					<h1>Congratulation!</h1>
					<h3>You are logged in!</h3>
	<-- Это пишу для исправления кривой зелёной расцветки / --> 
	
	scraping - "паучёк", который ходит по сайту и переходит по ссылкам, получает 
							страницы и анализирует эту информацию.
							
							Например кому-то нужно на сайте амазон проити по категории bestsellers
							по товару книги и собрать информацию о каких-то параметрах этих книг
							интересует первая сотня товаров.
							
							Эту программу можно написать на руби, и это не должно быть сложным,
							но эта программа позволит заработать какие-то деньги.
	
End of Lesson_19
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_20

	Есть такая "фишка".
	Когда нужно создать нескольно страниц сайта, то можно воспользоваться одним 
	представлением. Например создаём несколько методов:
	
					get '/contacts' do
						@title = 'Contacts'
						@message = 'Phone number: +7 958-842-85-42'
						erb :message
					end

					get '/faq' do
						@title = 'FAQ'
						@message = 'Under construction'
						erb :message
					end

					get '/something' do
						@title = 'Something'
						@message = 'Bla-Bla-Bla ...'
						erb :message
					end

	А представление должно выгдядеть так:
	
					<h1><%= @title %></h1>

					<p>
						<%= @message %>
					</p>
	
	Здесь важно отметить, что здесь в представление отправляются две глобальные 
	переменные @title и @message а значения у них в каждом варианте свои.
	
	(!!!) - Дополнительно можно использовать отдельный метод, который будет 
	формировать переменные для одинакового вывода представления
	
					def undre_construction options
						@title = ' Under construction'
						@message = 'This page is under construction'
						@title = options[:title] if options[:title]
						@message = options[:message] if options[:message]
						erb :message
					end
					
					get '/contacts' do
						under_construction :title => 'Contacts', :message => 'Phone: 123'
					end

					get '/faq' do
						under_construction :title => 'FAQ'
					end

					get '/something' do
						under_construction
					end
					
	Так можно 				
	
	______________________      G ____ I ___ T    ________________________
	
GIT - специальное приложение, которой позволяет вести контроль версий

	Установка GIT на Windows смотри с: 00:21:00 - 

		там внутри показали(37:00) как запускать node.js - оболочка для программирования
		на ДЖАВА-СКРИПТ - (говорит, что это типа RoR но для JS)

	Ставим ungit
	ungit - это пакет под node.js
		
	Чтобы проверить, что ungit установился и работает нужно создать пустую паку,
	перейти в неё и в этой папке через консоль стартовать ungit
	В результате он должен открыть страничку в браузере и показать, что в нашей папке
	нет репозитория.

	Здесь он сразу предлогает сделать в текущей папке репозиторий (хранилище версий)
	или предлогает склонировать репозиторий из указанного места.
	
	РЕПОЗИТОРИЙ (репо исходного кода) - отдельный каталог '.git'
	В этот каталок программа будет особым образом складывать версии файлов, упаковывает
	добавляет различную информация (для себя).
	
	Программа ungit при выполнении всегда обращается к программе git и выполняет все
	свои действия с помощию пакета git
	
	Нажатие на кнопку 'Make C:/Project/test a repository' фактически это выполнение 
	команды 'git init .' в терминале (в этой папке)
	
	Т.е. при работе в ungit фактически в БЭКГРАУНДЕ (за ценой) выполняются команды
	пакета git 
	
	COMMIT - (вклад) - смысл в том, что это вклад в репозиторий от Вас (программиста) 
 
	У каждого commit - есть автор, тот кто вложил эти изменения.
	
	Надпись master означает - где мы сейчас находимся. Это как стрелочка (указатель)
	
	Всё, что "закоммичено" - это уже неизменяемая история, её можно модефицировать, 
	создать отдельную ветку, и в ней можно внести отдельные изменения и это будет видно
	всегда. ПРи работк с сервером.
	Это очень удобно!
	
	Программа sinatra_20_3 - вариант записи на стрижку в парикмахерскую с возможностью
	записи введённой информации в отдельный файл. Файл будет в режиме 'a' - append 
	т.е. режим добавления информации (дописывания)
	
	(!!!) Файл  .gitognor обычно добавляют в commit чтобы при его модернизации 
	оставалась история.
	
 
End of Lesson_20
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_21

GIT - продолжение
	
	В WINDOWS чтобы запустить ungit (и чтобы остался доступным far) 
	нужно набрать в FAR-comandetre команду start ungit
	
	Команда 'Discard all' - отменить все изменений (внесённые после последнего commit)
	
	У каждого commit есть его ключ - это восемь знаков '9726aa5d' 
	
	Если ввести в терминале (открытом в папке, где есть папка .git) такую команду:
	git checkout 9726aa5d
	то он (git) перенесёт указатель (master) на commit с этим ключём и восстановит
	состояние всех файлов, какими они были на момен даного commit.
	Некое подобие "Машины времени". 
	Аналочично можно вернуться к любому commit
	(последние не-commit-енные изменения могут быть утеряны - Да! ЭТО ФАКТ )
	
	По ссылке можно понять логику Git - Преводится "Думай как GIT"
	https://think-like-a-git.net/
	Это хорошая обучалка.
	
	Ссылки в Git делают commits доступными.
	Сыллки - это: тэги или бранчи локальные или отдалённые. Здессь ТЭГ - это метка.
	
	Checkout теперь можно сделать на эту метку (ТЭГ) в web-интерфейсе в ungit
	
	Branch - ветвь.

	
SINATRA - продолжение

	Если в корневой папке создать папку public 
	то файлы в этой папке будут доступны из web 
	
	Наш файл из барбершопа (список записавшихся) нужно переместить в public
	тогда этот файл можно будет выгрузить с сервера через web
	дополнительно нужно изменить данные в программе (там где указан путь к файлу)
	
	http://localhost:4567/users.txt
	

HTML - формат

	Обычно html должен иметь такую структуру:
	
	'
					<html>
						<hed>
									... - Здесь дополнительная инфори=мация о странице и настройки
						</hed>
						
						<body>
									... - здесь большой код для отображения элементов на странице
						</body>	
					</html>
	'
	
	css - каскадная таблица стилей,
			- служит, чтобы придать сайту оформление
			
	упоминаение о файл css нужно положить в <hed>  
	<link href="/styles.css" rel="stylesheet" media="all" />
	
	В браузере (открыв исходный код страницы) можно по ссылке перейти на этот файл и
	убедится, что он есть.
	
	/* Hello */  - так указывается коментарий в файлах *.css
	
	Если создать в public дополнительную папку css/, то файл в ней будет доступен 
	по ссылке: 	<link href="/css/styles.css" rel="stylesheet" media="all" />
	
	Рассмотрим пример файла css:
	
/* It's remark */

body {														Когда браузер встретит тэг: body 
		font-family: Arial;						он применит этот																
}																	формат (в данном случае это ШРИФТ

/* bootstrap - tweeter ... */

h1 {															Аналогично с тэгом: h1
		background: Yellow;
		color: Blue;
}

h2 {
		background: lightblue;
		color: Red;
}

.somephing {										 .
		color: Green;
}

#slogan {													.
		color: Brown;
}


	Примеры файлов css можно посмтреть на любом сайте через 'исходный код' и клик по 
	ссылке в <hed>
	
	Перед ключевым словом можно ничего не ставит, ставить точку '.' или знак '#'
	
	'пусто' - правила применяются к ТЭГу
	
	
	'.' - правило применяется к тегу по атрибуту _class="" 
				например правило в css-файле:
				.somephing {										
						color: Green;
				}
				применится ко всем тегам, в html-файле, имеющим в признаке _class="something"
				'
				<p class="something" ...> ... </p>
				'
				и не важно сколько будет в файле таких мест, и как они будут обозначены.
				
			- применяется ко множеству элементов.	
				
	'#' - применяется по атрибуту id 
				id - должен быть уникальный в html-файле
	
	ВАЖНО!
	'.' '#' - ставятся только в css-файле, в html - они не ставятся
	
	
	
BOOTSTRAP - twitter bootstrap - набор стилей - css framework	(там есть и JS)

	Включает в себя шрифты, кнопки, таблицы, меню, компонеры (значки), картинки, рамки,
	всплывающие окна, блоки ввода, панели, media объекты, и т.д. и т.п.
	
	Информацию и примеры кода нужносмотреть на сайте: getbootstrap.com
		- там есть способ установки - (getting-started)
		- там есть коды (классы) для каждого элемента или шрифта
		
	Нужно просто копировать код из окон и переносить в свой файл.
	
	Хорошая статья по интеграции Bootstrap в наш сайт чмтай по адресу:
http://ningbit.github.io/blog/2013/06/28/how-to-integrate-bootstrap-css-into-your-sinatra-site/
	Руклводство длинное, но очень хороший результат.
	Но есть вариант проще:
	
	https://github.com/bootstrap-ruby/sinatra-bootstrap
	Получаем с github данные с адреса выше (делаем себе клон)
	
	> git clone <Ctrl>+V
	
	Затем, по руководству, нужно зайти в эту папку и в ней (в терминале) запустить 
	команду: > bundle install			# budle - эта команда загружает (проверяет, если есть)
																# все необходимые зависимости связанные dependency
	
	bundle exec ruby app.rb				# ruby запустится с теми gem, которы указал автор
																# а не стеми, что у нас могут быть установлены.
																# очень часто в ruby может не быть обратной 
																# совместимости	и если у нас скачена последняя версия
																# sinstra, а этому клону нужна более старая, то 
																# команда bundle exec как раз запустит программу со
																# старыми (родными) версиями gem-ов, а не с новыми.
																
	# Нужные версии gem-ов указаны в специальном файле: Gemfile.lock
	
	Then open: http://localhost:4567/
	 
	Удобнее всего копировать с сайта код (таблицу) и вставлять в свой	сайт,
	а затем удалить из него всё лишнее и добавить свои данные.
	Так будет быстрее происходить процесс программирования. 
	
	Copy as HTML    -->    Paste to Your Site-code.
	
			
End of Lesson_21
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_22

GIT CLONE работает в SSH если настроен github и у нас есть регистрация с ключами
	
	Если этого нет, то нужно переключить фориат вывода ссылки с SSH на HTTPS
	Тогда коменда git clone будет работать и без ключа.
	

СОЗДАНИЕ РЕПОЗИТОРИЯ на GITHUB.com

	-	Repository 
	-	New
	-	Вводим имя репозитория (должно быть уникальным в пределаз нашего аккаунта)
	-	Discription (не обязательно) Но с ним удобнее - это короткое описание
	- Public or Private - (скрытые только за деньги)	
			Есть друго сайл https://bitbucket.org/ 	- там бесплатно
	-	Хотим ли мы добавить файл Readme в наш репозиторий
	- Добавить ли файл .gitignore (можно добавить и потом)
	-	Добавить лицензию (обычно MIT - доступно для всех)
	Create Repository 
		Всё! Репозиторий создан.
		
		Забираем ссылку с нашего нового репозотория и клонируем приложение себе в комп
		git clone ....
		(сначала нужно зайти в папку, где лежат проекты - там появится новая папка)

	Запустим ungit 
		Теперь в браузере мы увидим уже два указателя:
		- master - это указательна копию программы на нашев компьютере (папка с клоном)			
		- origin/master - это указательна копию, которая на сайте github.com
		
	При очередном commit происходит создание новой точки и указатель master (локальный)
	перемещается на неё, а вот oridginal/master осталась на старой точке, т.е. на сайте
	осталась старая версия. 
			Чтобы её обновить нужно выполнить команду PUSH для этого нужно встать на master
	и нажать на кнопку PUSH справа от master (там будет стрелка - подсказка) 
		Так внесённые изменения (на нашейм компьютере) будут отправлены на сайт и теперь
	они станут доступны для всех, кто имеет доступ к этому репозиторию на сайте.
	
		Для принятия кем-то наших изменений нужно "затянуть" изменения с сервера 
	по команде git pull 
		Команду нужно вводить в той папке, гдк есть .git - папка
	
	layour - это шаблон страницы сайта. Он выводится всегда. Это как рамка для страниц
					 сайта. В нём (в layout) естьместо обозначенное словом '<% yield %>' 
					 вмето которого и вставляются все наши view, которые мы пишем
	view - это информация, которая вставляется в рамку (шаблон) нашего сайта. А вся 
				 рамка описывается именно в layout - файле.
				 
				 В нём же подключаются и bootstrap и другие вещи, а в наших view уже не нужно
	прописывать стили и всякие медиа.
	
				В layout обычно органиховано меню сайта, система навигации по сайту и право-
	вая информация о сайте (всё в одном файле)
	
	Чистый sinatra-bootstrap-clean - можно скачать (клонировать) с реползитория:
	https://github.com/rubyschool-us/sinatra-bootstrap-clean	
	
	Чтобы не перезавускать sinatra при изменени кода сайта нужно использовать отдельный
	gem sinatra-reloader Поставим его командой gem install sinatra-reloader (с sudo)
	в результате поставились 3 gem	
	
	Осталось добавить одну строку в файл app.rb
	require 'sinatra/reloader'
	
	Для создания формы нужно скопировать код формы из bootstrap (выбирай любую)
	Лишние поля можно удалить или можно добавить недостающие поля и формы.
	
	Важно! 
	У каждого тега <input ...> должно быть имя. Вот так <input name="nik" ...>
	По этому имени сервер будет понимать какая информация пришла.
	Запятых нет.
	
	У каждой формы (тег <form ...>) должны быть указаны два параметра.
	<form action="/visit", method="POST" ... >
	Эти параметры необходимы серверу для выбора обработчика информации.
	В данном случае это будет:
	
	post '/visit' do
		@nik_value = params[:nik]
		...
		erb :list_data 					# Указатель на view которы откроется после этого post.
	end

	в головном файле приложения (app.rb)
	
	Аналогично можно добавить другие параметры. Например "телефон" и "время"
	В этом случае нужно дважды скопировать блок с nik в ту же форму и изменить nik на
	telephon и time Ещё нужно заменить текстовые названия на "Телефон" и "Время"
	
	И конечно, в другом файле, где метод post тоже нужно добавить обращение к данным:
	
	post '/visit' do
		@nik_value = params[:nik]
		@tel_value = params[:telephon]
		@time_value = params[:time]
		...
		erb :list_data
	end 
	
	Обычно, полученные данные записываются в файл. 
	Все результаты может получить администратор (по паролю)
	
	Но это уже совсем другая история...
	
			
End of Lesson_22
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_23

	В bootstrap в разделе Forms есть подраздел Supported controls а в нём есть selects 
	который позволяет пользователю сделать выбор нужного (например парикмахера).
	
	Для этого так же берём код из bootstrap и вставляем себе в форму.
	
	25:00 - добавляем парикмахеров в форму (для записи на стрижку)
	
	29:00 - получение параметров из формы
	
	В sinatra существует специальный хэш с именем params
	Через него происходит передача всех данных из формы (браузер) в сервер для оработки
	
	Для отладки очень удобно использовать такой вывод из метода post
	
	post '/visit' do
		@nik_value = params[:nik]
		...
		erb "Your name is #{@nik_value}" 					# и так же с другими переменными
	end	
	
	Скрипты js обычно вомещают в <hed> блок страницы. В начало страницы пишут скрипты
	чтобы быстрее загрузилась страничка, а потом уже грузились "тяжёлые " скрипты.
	
	У 'css' (СТИЛИ) есть удобная библиотека = 'bootstrap'
	У 'javascript' (ЯЗЫК_НА_ФРОНТЕНД) тоже есть библиотека = 'jQuery'
	
	
	Для работы с 'CSS' и 'JavaScript' ничего подключать не надо.
	
	А для работы с их библиотеками 'bootstrap' и 'jQuery' нужно писать подключение.
	
	Библиотека 'jQuery' расширяет возможности скрипта 'JavaScript'
	Раньше вместо ней использовалась библиотека 'mootools'
	
	Обратите внимание, что подключение стилей и подключение скриптов разлючаются.
	<link href="/bootstrap.css" rel="stylesheet" media="all" />
	<script src="bootstrap-5.1.3/bootstrap.min.js"></script>
	/ Смотри на количество используемых тегов

	Мы можем прикрепть (написать) свой js в отдельную страницу и тогда он будет работать
	только, когда будет выводится именно эта страница. Вот примет для visit.erb
	
	<script>
		alert('Hello from visit page!');
	</script>
	/
	

jQuery - библиотека для js (Расширенная база)	

	Мы уже знаем о трёх серлекторах: nill, '.', '#'
	
	Любой код в jQ начинается со специального кода: $
	$('#aaa').css('background-color','yellow');
	
	Здесь:
	$ - говорит о том, что будет вызван расшиненный пакет javascript а именно jQuery
	  	  
	() - в скобках указывается параметр,
	
	'' - в кавычках пишется т.н. селектор:

					#aaa - если используется #, то в элементе мы указываем id="aaa"
					       (id используется только для одного элемента)
					       
					.bbb - если используем точку, то bbb мы должны поместить в _class=""
								 ( в случае с точкой правило можно применить к нескольким элементам )

		Или так: '<input id="aaa" name=...>'		- для префикса решётка $('#aaa').css
		Или так: '<div class="bbb ..." ...>'		- для префикса точка 	 $('.bbb').css
		
		Скрипт jQ для выбора цвета:
		https://github.com/tkrotoff/jquery-simplecolorpicker
		
		Для работы нужно подключить несколько файлов сос скриптами и CSS
		
		Далее нам нужно добавить код из раздела How to Use - (Как пользоваться)
		
		ВНИМАНИЕ! код этого нового плагина должен загрузится в начале, т.е. указание
		на подключение плагина нудно писать в голове <hed>
		При подключении скрипта в подвале - система не срабатыает. 
		См commits: #14971a0f и #409ec1db
		
		У этого плагина есть ещё ряд настроек, пока с ними не разбирался.
		
		Вызов плагина происходит сразу, как только браузер загрузил строки с вызовом.
		Если select (с цветами) ещё не загружен и первым грузится строки с вызовом
		плагина, сто плагин запустится, но не отработает свою задачу, т.к. у него не 
		будет данныз (select с цветами)
		Поэтому нужно сначала загрузить список цветов (select), а заткм строки с вызовом 
		плагина.
		
		Есть вариант переделать строки вызова следующим образом и тогда эти строки можно
		написать в любом месте нашего файла.
		<script type="text/javascript">
		$(function() {
			$('#color').simplecolorpicker();
		})
		</script>
		/
		
		Полдробности на странице сайта: https://api.jquery.com/ready/
	
End of Lesson_23
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_24

!

End of Lesson_24
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_25

!

End of Lesson_25
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_26

!

End of Lesson_26
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_27

!

End of Lesson_27
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_28

!

End of Lesson_28
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_29

!

End of Lesson_29
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_30

!

End of Lesson_30
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_31

!

End of Lesson_31
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_32

!

End of Lesson_32
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_33

!

End of Lesson_33
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_34

!

End of Lesson_34
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_35

!

End of Lesson_35
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_36

!

End of Lesson_36
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_37

!

End of Lesson_37
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_38

!

End of Lesson_38
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_39

!

End of Lesson_39
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_40

!

End of Lesson_40
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_41

!

End of Lesson_41
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_42

!

End of Lesson_42
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_43

!

End of Lesson_44
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_45

!

End of Lesson_45
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_46

!

End of Lesson_46
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_47

!

End of Lesson_47
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_48

!

End of Lesson_48
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_49

!

End of Lesson_49
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Start  Lesson_50

!

End of Lesson_50 - УРА!

! # -------------------------------------------------------------------------------
	# =============================================================== B E G I N =====
	# =================================================================== E N D =====

GIT MERGE - Слияние

  Шаблон Разведчика (Scout pattern) 
  Мы не знаем, что там впереди, и мы создаёт клона (bot) и пускаем его на слияние.
  Если всё хорошо, то мы присоединяемся к результату,
  Если что-то пошло не так, то мы разрушаем клона и с ним неудачный результат слияния

1.Убедитесь, что вы находитесь на правильной ветке и 
						  что у вас чистое рабочее состояние.

    Какой бы визуализатор вы ни использовали, выясните, как он показывает вам, 
    где находится ваша текущая ветвь. 
    Или в командной строке введите, git status
    и вы должны увидеть что-то вроде этого:
    # On branch master
    nothing to commit (working directory clean)

2.Создайте новую ветку и переключитесь на нее.

    > git checkout -b test_merge. 
    Теперь, если вы наберете > git status еще раз, вы должны увидеть сообщение о том, 
    что вы находитесь в ветке test_merge .

3.Сделайте слияние.

    > git merge new_code
    Если вам повезет, не будет конфликтов слияния, которые вы не сможете разрешить.
    Если вы хотите прервать слияние на этом этапе, введите > git reset --hard.

4.Переключитесь на свой визуализатор и предскажите, как изменится его вид, 
    когда вы его обновите.

    Например:
        После слияния вы должны увидеть новый коммит.
        Новый коммит должен иметь сообщение типа 
	      «Объединить ветку new_code в test_merge».
        Ваша метка ветки test_merge должна была переместиться в этот новый коммит, 
	      в то время как метки ветки master и new_code 
	      должны оставаться на том же месте.

5.Обновите свой визуализатор и посмотрите, был ли ваш прогноз верным.
    Вы довольны результатом?
    
    
    Если ДА: переместите основную ветку вперед туда, 
	где находится ветка test_merge с:
    
	      git checkout master
	      git merge test_merge
	      
    Если НЕТ: удалите ветку test_merge с помощью:
    
	      git checkout master
	      git branch -D test_merge


  Шаблон Точки сохраниения (savepoint pattern)
  Создаём точку восстановления
  Делаем слияние.
  Если всё хорошо - точка восстановления больше не нужна.
  Если что-то пошло не так возвращаемся на точку восстановления (разрушая слияние)
  
Вы находитесь в ветке master и хотите, чтобы изменения из ветки new_feature 
были включены в master. Вы достаточно уверены, что захотите сохранить изменения, 
но хотите иметь возможность отменить их, если, например, эта функция 
имеет непреднамеренные побочные эффекты.

1.Убедитесь, что вы находитесь на правильной ветке и что у вас чистое рабочее 
состояние.
    Какой бы визуализатор вы ни использовали, выясните, как он показывает вам, 
    где находится ваша текущая ветвь. Или в командной строке введите, 
    > git statusи вы должны увидеть что-то вроде этого:
    # On branch master
    nothing to commit (working directory clean)

2.Создайте новую ветку для использования в качестве точки сохранения, 
    но не переключайтесь на нее.
    > git branch savepoint 
    Теперь, если вы наберете > git status еще раз, вы все еще должны увидеть 
    сообщение о том, что вы находитесь в основной ветке.
    
3.Сделайте слияние.
        > git merge new_feature 
    Если вам повезет, не будет конфликтов слияния, которые вы не сможете разрешить.
    Если вы хотите прервать слияние на этом этапе, просто введите > git reset --hard.

4.Переключитесь на свой визуализатор и предскажите, как изменится его вид, 
    когда вы его обновите.
        Например:
            После слияния вы должны увидеть новый коммит.
            Новый коммит должен иметь сообщение типа 
			  «Объединить ветку new_feature с мастером».
            Метка вашей главной ветки должна быть перемещена в этот новый коммит, 
	    а метка ветки new_feature должна оставаться на том же месте.

5.Обновите свой визуализатор и посмотрите, был ли ваш прогноз верным.
    Вы довольны результатом?
    
        Если ДА: удалите точку сохранения.
        > git branch -d savepoint
        
	Если НЕТ: сбросьте вашу ветку до точки сохранения.
        > git reset --hard savepoint
        
	  Если вы хотите очиститься, теперь вы можете удалить точку сохранения 
	  с помощью > git branch -d savepoint

/* 
Здесь можно и не создавать эту точку восстановления т.к. в случае необходимости
откатится на предыдущий коммит нужно только найти его ХЭШ, а точнее начало хэша
Остальное git допишет сам. Например
> git reset --hard 77a39
Откат прошёл, но убил ещё и коммит с new-code т.к. я ветку уже удалил,
а коммиты без ветки не живут.
*/


FAR - manager for Linux

	Для установки нужно подключить репозиторий

		sudo add-apt-repository ppa:far2l-team/ppa
		sudo apt-get update

	Зайти в sinaptic
	В поиске набрать 'far2l'
	И поставить все три пакета (отметить для установки и выполнить установку)
	Так появится программа. Far2l

	Подробнее читай здесь: https://launchpad.net/~far2l-team/+archive/ubuntu/ppa
	(там есть возможность выбора версии OS - Linux в техническом описании)
